<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿龙的博客</title>
  
  <subtitle>AWS, DevOps, IT Infrastructure, and Other Puzzles</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://longshilin.com/blog/"/>
  <updated>2019-08-11T10:05:51.000Z</updated>
  <id>https://longshilin.com/blog/</id>
  
  <author>
    <name>longshilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity双击脚本不会自动跳转到vs中的解决方案</title>
    <link href="https://longshilin.com/blog/f243dbe9.html"/>
    <id>https://longshilin.com/blog/f243dbe9.html</id>
    <published>2019-08-11T15:54:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题复现">问题复现</h4><p>在Unity中点击脚本不能直接打开vs编辑器，检查完Unity设置发现还是打不开</p><h4 id="问题原因">问题原因</h4><p>因为Unity中导入的VS Package版本不支持新版的Virtual Studio所导致的</p><h4 id="解决方案">解决方案</h4><p>升级Unity中的<code>Visual Studio Package</code>版本即可</p><a id="more"></a><p><img src="https://longshilin.com/images/20190522214037.png" alt="选择Package Manager"></p><p><img src="https://longshilin.com/images/20190523101650.png" alt="升级Visual Studio Editor Package"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题复现&quot;&gt;问题复现&lt;/h4&gt;
&lt;p&gt;在Unity中点击脚本不能直接打开vs编辑器，检查完Unity设置发现还是打不开&lt;/p&gt;
&lt;h4 id=&quot;问题原因&quot;&gt;问题原因&lt;/h4&gt;
&lt;p&gt;因为Unity中导入的VS Package版本不支持新版的Virtual Studio所导致的&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;升级Unity中的&lt;code&gt;Visual Studio Package&lt;/code&gt;版本即可&lt;/p&gt;
    
    </summary>
    
      <category term="解决方案" scheme="https://longshilin.com/blog/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="Unity" scheme="https://longshilin.com/blog/tags/Unity/"/>
    
      <category term="Visual Studio" scheme="https://longshilin.com/blog/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>安排工作</title>
    <link href="https://longshilin.com/blog/fdd0c96a.html"/>
    <id>https://longshilin.com/blog/fdd0c96a.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>要在主线程中安排作业，您必须：</p><ul><li>实例化作业。</li><li>填充作业的数据。</li><li>调用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>方法。</li></ul><p>调用<code>Schedule</code>将作业放入作业队列以便在适当的时间执行。一旦安排，你就不能打断工作。</p><a id="more"></a><p><strong>注意</strong>：您只能<code>Schedule</code>从主线程调用。</p><h4 id="安排工作的一个例子">安排工作的一个例子</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a native array of a single float to store the result. This example waits for the job to complete for illustration purposes</span></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the job data</span></span><br><span class="line">MyJob jobData = <span class="keyword">new</span> MyJob();</span><br><span class="line">jobData.a = <span class="number">10</span>;</span><br><span class="line">jobData.b = <span class="number">10</span>;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule the job</span></span><br><span class="line">JobHandle handle = jobData.Schedule();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the job to complete</span></span><br><span class="line">handle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// All copies of the NativeArray point to the same memory, you can access the result in "your" copy of the NativeArray</span></span><br><span class="line"><span class="keyword">float</span> aPlusB = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the memory allocated by the result array</span></span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要在主线程中安排作业，您必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例化作业。&lt;/li&gt;
&lt;li&gt;填充作业的数据。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Schedule&lt;/a&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用&lt;code&gt;Schedule&lt;/code&gt;将作业放入作业队列以便在适当的时间执行。一旦安排，你就不能打断工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>什么是工作制度？</title>
    <link href="https://longshilin.com/blog/2b778a74.html"/>
    <id>https://longshilin.com/blog/2b778a74.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>作业系统通过创建<a href="https://en.wikipedia.org/wiki/Job_(computing)" target="_blank" rel="noopener">作业</a>而不是线程来管理<a href="https://docs.unity3d.com/Manual/JobSystemMultithreading.html" target="_blank" rel="noopener">多线程代码</a>。</p><p>作业系统跨多个核心管理一组<a href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-creating-worker-threads" target="_blank" rel="noopener">工作线程</a>。它通常每个<a href="https://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/" target="_blank" rel="noopener">逻辑CPU核心</a>有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。</p><a id="more"></a><p>作业系统将作业放入<a href="https://en.wikipedia.org/wiki/Job_queue" target="_blank" rel="noopener">作业队列中</a>以执行。作业系统中的工作线程从作业队列中获取项目并执行它们。作业系统管理<a href="http://tutorials.jenkov.com/ood/understanding-dependencies.html" target="_blank" rel="noopener">依赖关系</a>并确保作业以适当的顺序执行。</p><h4 id="什么是工作？">什么是工作？</h4><p>工作是完成一项特定任务的一小部分工作。作业接收参数并对数据进行操作，类似于方法调用的行为方式。作业可以是自包含的，也可以依赖其他作业在运行之前完成。</p><h4 id="什么是工作依赖？">什么是工作依赖？</h4><p>在复杂的系统中，如游戏开发所需的系统，每个作业都不可能是独立的。一项工作通常是为下一份工作准备数据。工作人员知道并支持依赖关系以使其工作。如果<code>jobA</code>具有依赖性<code>jobB</code>，则作业系统确保在完成<code>jobA</code>之前不会开始执行<code>jobB</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作业系统通过创建&lt;a href=&quot;https://en.wikipedia.org/wiki/Job_(computing)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作业&lt;/a&gt;而不是线程来管理&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemMultithreading.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程代码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;作业系统跨多个核心管理一组&lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/parallel/multithreading-creating-worker-threads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工作线程&lt;/a&gt;。它通常每个&lt;a href=&quot;https://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;逻辑CPU核心&lt;/a&gt;有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>HelloCube</title>
    <link href="https://longshilin.com/blog/8282d3d8.html"/>
    <id>https://longshilin.com/blog/8282d3d8.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>此示例演示了一个简单的ECS系统，它可以旋转一对立方体。</p><a id="more"></a><h4 id="它显示了什么？">它显示了什么？</h4><p>此示例演示了ECS中数据和功能的分离。<br>数据存储在组件中，如下RadiansPerSecond属性存储在RotationSpeed_ForEach组件中， 该结构体数据组件有[Serializable]修饰符，表示实例化属性。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line"> [<span class="meta">Serializable</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">struct</span> RotationSpeed_ForEach : IComponentData</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">float</span> RadiansPerSecond;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而功能则写入系统，如下<strong>RotationSpeedSystem_ForEach</strong> 使用存储在 <strong>RotationSpeed_ForEach</strong> 组件中的<em>data</em>更新对象的旋转。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This system updates all entities in the scene with both a RotationSpeed_ForEach and Rotation component.</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedSystem_ForEach</span> : <span class="title">ComponentSystem</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="comment">// Entities.ForEach processes each set of ComponentData on the main thread. This is not the recommended</span></span><br><span class="line">         <span class="comment">// method for best performance. However, we start with it here to demonstrate the clearer separation</span></span><br><span class="line">         <span class="comment">// between ComponentSystem Update (logic) and ComponentData (data).</span></span><br><span class="line">         <span class="comment">// There is no update logic on the individual ComponentData.</span></span><br><span class="line">         Entities.ForEach((<span class="keyword">ref</span> RotationSpeed_ForEach rotationSpeed, <span class="keyword">ref</span> Rotation rotation) =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">var</span> deltaTime = Time.deltaTime;</span><br><span class="line">             rotation.Value = math.mul(math.normalize(rotation.Value),</span><br><span class="line">                 quaternion.AxisAngle(math.up(), rotationSpeed.RadiansPerSecond * deltaTime));</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="componentsystems和entities-foreach">ComponentSystems和Entities.ForEach</h4><p>RotationSpeedSystem_ForEach是一个ComponentSystem，它使用Entities.ForEach委托来遍历实体。<br>此示例仅创建单个实体，但如果向场景添加了更多实体，则RotationSpeedSystem_ForEach会更新所有实体 - 只要它们具有RotationSpeed_ForEach组件（并且在将GameObject的Transform转换为ECS组件时添加了旋转组件）。<br>请注意，使用Entities.ForEach的ComponentSystems在主线程上运行。<br>要利用多个内核，可以使用JobComponentSystem（如下一个HelloCube示例所示）。</p><h4 id="从gameobject转换为entity">从GameObject转换为Entity</h4><p><strong>ConvertToEntity</strong> MonoBehaviour在Awake时将GameObject及其子节点转换为实体和ECS组件。<br>目前，ConvertToEntity可以转换的内置Unity MonoBehaviours集包括Transform和MeshRenderer。<br>您可以使用<strong>实体调试器</strong>（菜单：<strong>窗口</strong>&gt; <strong>分析</strong>&gt; <strong>实体调试器</strong>）来检查转换创建的ECS实体和组件。<br>您可以在自己的MonoBehaviours上实现IConvertGameObjectEntity接口，以提供ConvertToEntity用于将存储在MonoBehavi中的数据转换为ECS组件的转换函数。<br>在此示例中， <strong>RotationSpeedAuthoring_ForEach</strong> MonoBehaviour使用IConvertGameObjectEntity在转换时将RotationSpeed_ForEach组件添加到实体。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"> <span class="keyword">using</span> Unity.Entities;</span><br><span class="line"> <span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"> <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"> [<span class="meta">RequiresEntityConversion</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedAuthoring_ForEach</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">float</span> DegreesPerSecond;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// The MonoBehaviour data is converted to ComponentData on the entity.</span></span><br><span class="line">​     <span class="comment">// We are specifically transforming from a good editor representation of the data (Represented in degrees)</span></span><br><span class="line">​     <span class="comment">// To a good runtime representation (Represented in radians)</span></span><br><span class="line">​     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function">​</span>     &#123;</span><br><span class="line">​         <span class="keyword">var</span> data = <span class="keyword">new</span> RotationSpeed_ForEach &#123; RadiansPerSecond = math.radians(DegreesPerSecond) &#125;;</span><br><span class="line">​         dstManager.AddComponentData(entity, data);</span><br><span class="line">​     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="hellocube-1b-foreachwithentitychanges">HelloCube_1b_ForEachWithEntityChanges</h3><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要更新的正确实体集。然后它在ForEach lambda函数内部修改这些实体。</p><p>该示例定义了两个标记组件，名为MovingCube_ForEachWithEntityChanges和MoveUp_ForEachWithEntityChanges。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> MoveUp_ForEachWithEntityChanges : IComponentData</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MoveUp is a "tag" component and contains no data. Tag components can be used to mark entities that a system should process.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> MovingCube_ForEachWithEntityChanges : IComponentData</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MovingCube_ForEachWithEntityChanges is a "tag" component and contains no data.</span></span><br><span class="line">        <span class="comment">// Tag components can be used to mark entities that a system should process.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>系统中的一个查询选择同时具有MoveUp_ForEachWithEntityChanges组件和Translation组件的所有实体。与此查询关联的ForEach lambda函数向上移动每个选定的实体，直到达到某个高度时，该函数将删除MoveUp_ForEachWithEntityChanges组件，以便下次系统更新时，将不会选择该实体，因此它不会向上移动任何更远的位置。</p><p>第二个查询选择具有Translation组件但没有MoveUp_ForEachWithEntityChanges组件的所有实体。与第二个查询关联的ForEach函数将实体向下移动到其起始位置，并添加新的MoveUp_ForEachWithEntityChanges组件。由于实体再次具有MoveUp_ForEachWithEntityChanges组件，因此下次系统更新时，实体将被第一个ForEach函数向上移动并被第二个查询跳过。</p><p>MovingCube_ForEachWithEntityChanges是一个标记组件，用于确保系统仅适用于为此示例标记的组件。示例中的两个查询都需要MovingCube_ForEachWithEntityChanges组件。</p><h4 id="它显示了什么？-v2">它显示了什么？</h4><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要向上移动的一组实体。当它们达到一定高度时，系统会删除一个组件并使用另一个查询在较低的高度重新生成它们。它还演示了使用“标签”组件来提供选择具有待处理标记组件的特定entite组的方法。最后，此示例演示了如何在ForEach lambda函数内修改实体。</p><h4 id="组件系统和实体-foreach">组件系统和实体.ForEach</h4><p>MovementSystem_ForEachWithEntityChanges是一个ComponentSystem，它使用Entities.ForEach lambda函数迭代实体。此示例使用WithAll和WithNone约束来选择要处理的特定实体集。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">using</span> Unity.Entities;</span><br><span class="line"> <span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"> <span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"> <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">// This system updates all entities in the scene with Translation components.</span></span><br><span class="line">     <span class="comment">// It treats entities differently depending on whether or not they also have a MoveUp component.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MovementSystem_ForEachWithEntityChanges</span> : <span class="title">ComponentSystem</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>         &#123;</span><br><span class="line">             <span class="comment">// If a MoveUp component is present, then the system updates the Translation component to move the entity upwards.</span></span><br><span class="line">             <span class="comment">// Once the entity reaches a predetermined height, the function removes the MoveUp component.</span></span><br><span class="line">             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges, MoveUp_ForEachWithEntityChanges&gt;().ForEach(</span><br><span class="line">                 (Entity id, <span class="keyword">ref</span> Translation translation) =&gt;</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">var</span> deltaTime = Time.deltaTime;</span><br><span class="line">                     translation = <span class="keyword">new</span> Translation()</span><br><span class="line">                     &#123;</span><br><span class="line">                         Value = <span class="keyword">new</span> float3(translation.Value.x, translation.Value.y + deltaTime, translation.Value.z)</span><br><span class="line">                     &#125;;</span><br><span class="line"></span><br><span class="line">​                    <span class="keyword">if</span> (translation.Value.y &gt; <span class="number">10.0f</span>)</span><br><span class="line">​                         EntityManager.RemoveComponent&lt;MoveUp_ForEachWithEntityChanges&gt;(id);</span><br><span class="line">​                 &#125;</span><br><span class="line">​             );</span><br><span class="line"></span><br><span class="line">​            <span class="comment">// If an entity does not have a MoveUp component (but does have a Translation component),</span></span><br><span class="line">​             <span class="comment">// then the system moves the entity down to its starting point and adds a MoveUp component.</span></span><br><span class="line">​             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges&gt;().WithNone&lt;MoveUp_ForEachWithEntityChanges&gt;().ForEach(</span><br><span class="line">​                 (Entity id, <span class="keyword">ref</span> Translation translation) =&gt;</span><br><span class="line">​                 &#123;</span><br><span class="line">​                     translation = <span class="keyword">new</span> Translation()</span><br><span class="line">​                     &#123;</span><br><span class="line">​                         Value = <span class="keyword">new</span> float3(translation.Value.x, <span class="number">-10.0f</span>, translation.Value.z)</span><br><span class="line">​                     &#125;;</span><br><span class="line"></span><br><span class="line">​                    EntityManager.AddComponentData(id, <span class="keyword">new</span> MoveUp_ForEachWithEntityChanges());</span><br><span class="line">​                 &#125;</span><br><span class="line">​             );</span><br><span class="line">​         &#125;</span><br><span class="line">​     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意：使用Entities.ForEach的组件系统在主线程上运行。要利用多个内核，可以使用JobComponentSystem（如其他HelloCube示例所示）。这也允许更改ForEach lambda函数内的实体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此示例演示了一个简单的ECS系统，它可以旋转一对立方体。&lt;/p&gt;
    
    </summary>
    
      <category term="ECS" scheme="https://longshilin.com/blog/categories/ECS/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/ECS/ECS-Samples/"/>
    
    
      <category term="ECS" scheme="https://longshilin.com/blog/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>并行工作</title>
    <link href="https://longshilin.com/blog/3c908d6c.html"/>
    <id>https://longshilin.com/blog/3c908d6c.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>当<a href="https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html" target="_blank" rel="noopener">调度工作</a>，只能有一个工作做一个任务。在游戏中，通常希望对大量对象执行相同的操作。有一个名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobParallelFor.html" target="_blank" rel="noopener">IJobParallelFor</a>的独立作业类型来处理这个问题。</p><p><strong>注意</strong>：“ParallelFor”作业是Unity中用于实现<code>IJobParallelFor</code>接口的任何结构的集合术语。</p><a id="more"></a><p>ParallelFor作业使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html" target="_blank" rel="noopener">NativeArray</a>数据作为其数据源。ParallelFor作业跨多个核心运行。每个核心有一个作业，每个作业处理一部分工作量。<code>IJobParallelFor</code>表现得像<code>IJob</code>，但它不是单个<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.Execute.html" target="_blank" rel="noopener">Execute</a>方法，而是<code>Execute</code>在数据源中的每个项目上调用一次方法。方法中有一个整数参数<code>Execute</code>。该索引用于访问和操作作业实现中的数据源的单个元素。</p><h4 id="parallelfor作业定义的示例：">ParallelFor作业定义的示例：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> IncrementByDeltaTimeJob: IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; values;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span> (<span class="params"><span class="keyword">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">float</span> temp = values[index];</span><br><span class="line">        temp += deltaTime;</span><br><span class="line">        values[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调度parallelfor作业">调度ParallelFor作业</h4><p>在调度ParallelFor作业时，必须指定<code>NativeArray</code>要拆分的数据源的长度。<code>NativeArray</code>如果结构中有多个，Unity C＃作业系统无法知道您要将哪个用作数据源。长度还告诉C＃作业系统需要多少<code>Execute</code>方法。</p><p>幕后花絮，ParallelFor作业的调度更复杂。在调度ParallelFor作业时，C＃作业系统将工作分成批处理以在核心之间分配。每批包含一组<code>Execute</code>方法。然后，C＃作业系统在每个CPU核心的Unity本机作业系统中调度最多一个作业，并将该本机作业通过一些批次来完成。</p><p><a href="https://docs.unity3d.com/uploads/Main/jobsystem_parallelfor_job_batches.svg" target="_blank" rel="noopener"><img src="https://longshilin.com/images/20190811161551.png" alt="ParallelFor在核心之间划分批次的作业"></a></p><p>当本地作业在其他作业之前完成其批处理时，它会从其他本机作业中<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener">窃取</a>剩余批处理。它一次只能窃取本机作业剩余批次的一半，以确保<a href="https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance" target="_blank" rel="noopener">缓存局部性</a>。</p><p>要优化过程，您需要指定批次计数。批次计数控制您获得的作业数量，以及线程之间工作重新分配的细化程度。批量计数较低（例如1）可以使线程之间的工作分布更均匀。它确实带来了一些开销，所以有时候增加批量计数会更好。从1开始并增加批次计数直到可忽略不计的性能增益是一种有效的策略。</p><h4 id="调度parallelfor作业的示例">调度ParallelFor作业的示例</h4><p><strong>工作代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Job adding two floating point values together</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyParallelJob : IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>]</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">    [<span class="meta">ReadOnly</span>]</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        result[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主线程代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; a = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; b = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2.2</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.3</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">MyParallelJob jobData = <span class="keyword">new</span> MyParallelJob();</span><br><span class="line">jobData.a = a;</span><br><span class="line">jobData.b = b;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule the job with one Execute per index in the results array and only 1 item per processing batch</span></span><br><span class="line">JobHandle handle = jobData.Schedule(result.Length, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the job to complete</span></span><br><span class="line">handle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the memory allocated by the arrays</span></span><br><span class="line">a.Dispose();</span><br><span class="line">b.Dispose();</span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调度工作&lt;/a&gt;，只能有一个工作做一个任务。在游戏中，通常希望对大量对象执行相同的操作。有一个名为&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobParallelFor.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IJobParallelFor&lt;/a&gt;的独立作业类型来处理这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：“ParallelFor”作业是Unity中用于实现&lt;code&gt;IJobParallelFor&lt;/code&gt;接口的任何结构的集合术语。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>创建作业</title>
    <link href="https://longshilin.com/blog/208be653.html"/>
    <id>https://longshilin.com/blog/208be653.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>要在Unity中创建作业，您需要实现<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.html" target="_blank" rel="noopener">IJob</a>接口。<code>IJob</code>允许您安排与正在运行的任何其他作业并行运行的单个作业。</p><p>注意：“作业”是Unity中用于实现<code>IJob</code>接口的任何结构的集合术语。</p><a id="more"></a><p>要创建工作，您需要：</p><ul><li>创建一个实现的结构<code>IJob</code>。</li><li>添加作业使用的成员变量（<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable类型</a>或<a href="https://docs.unity3d.com/Manual/JobSystemNativeContainer.html" target="_blank" rel="noopener">NativeContainer</a>类型）。</li><li>在结构中创建一个名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.Execute.html" target="_blank" rel="noopener">Execute</a>的方法，并在其中实现作业。</li></ul><p>执行作业时，该<code>Execute</code>方法在单个核心上运行一次。</p><p>注意：在设计作业时，请记住它们对数据副本进行操作，除非是<code>NativeContainer</code>。因此，从主线程中的作业访问数据的唯一方法是写入<code>NativeContainer</code>。</p><h2 id="简单作业定义的一个示例">简单作业定义的一个示例</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Job adding two floating point values together</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        result[<span class="number">0</span>] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要在Unity中创建作业，您需要实现&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IJob&lt;/a&gt;接口。&lt;code&gt;IJob&lt;/code&gt;允许您安排与正在运行的任何其他作业并行运行的单个作业。&lt;/p&gt;
&lt;p&gt;注意：“作业”是Unity中用于实现&lt;code&gt;IJob&lt;/code&gt;接口的任何结构的集合术语。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>C＃作业系统提示和故障排除</title>
    <link href="https://longshilin.com/blog/feab267f.html"/>
    <id>https://longshilin.com/blog/feab267f.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Unity C＃作业系统时，请确保遵守以下内容：</p><h4 id="不要从作业访问静态数据">不要从作业访问静态数据</h4><p>从作业访问静态数据会绕过所有安全系统。如果您访问错误的数据，您可能会以意想不到的方式崩溃Unity。例如，访问<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank" rel="noopener">MonoBehaviour</a>可能会导致域重新加载崩溃。</p><p><strong>注意</strong>：由于存在这种风险，Unity的未来版本将阻止使用<a href="https://www.youtube.com/watch?v=VxeC7WFfg3Q" target="_blank" rel="noopener">静态分析</a>从作业进行全局变量访问。如果您确实访问作业中的静态数据，则应该期望您的代码在Unity的未来版本中中断。</p><a id="more"></a><h4 id="刷新预定批次">刷新预定批次</h4><p>如果希望作业开始执行，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html" target="_blank" rel="noopener">JobHandle.ScheduleBatchedJobs</a>刷新计划批处理。请注意，调用此方法会对性能产生负面影响。不刷新批处理会延迟调度，直到主线程等待结果。在所有其他情况下，使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.Complete.html" target="_blank" rel="noopener">JobHandle.Complete</a>来启动执行过程。</p><p><strong>注意</strong>：在<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">实体组件系统</a>（ECS）中，将为您隐式刷新批处理，因此<code>JobHandle.ScheduleBatchedJobs</code>不需要调用。</p><h4 id="不要尝试更新nativecontainer内容">不要尝试更新NativeContainer内容</h4><p>由于缺少<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns" target="_blank" rel="noopener">ref返回</a>，因此无法直接更改<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>的内容。例如，<code>nativeArray[0]++;</code>与<code>var temp = nativeArray[0]; temp++;</code>不更新值的<code>nativeArray</code>写入相同。</p><p>相反，您必须将索引中的数据复制到本地临时副本，修改该副本并将其保存回来，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyStruct temp = myNativeArray[i];</span><br><span class="line">temp.memberVariable = 0;</span><br><span class="line">myNativeArray[i] = temp;</span><br></pre></td></tr></table></figure><h4 id="致电jobhandle-complete以重新获得所有权">致电JobHandle.Complete以重新获得所有权</h4><p>跟踪数据所有权需要在主线程再次使用它们之前完成依赖项。检查<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.IsCompleted.html" target="_blank" rel="noopener">JobHandle.IsCompleted</a>是不够的。您必须调用该方法<code>JobHandle.Complete</code>以重新获得<code>NativeContainer</code>主线程的类型的所有权。调用<code>Complete</code>还可以清除安全系统中的状态。不这样做会引入内存泄漏。如果您在每个帧中安排新作业，并且依赖于前一帧的作业，则此过程也适用。</p><h4 id="在主线程中使用schedule和complete">在主线程中使用Schedule和Complete</h4><p>你只能调用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>和<code>Complete</code>主线程。如果一个作业依赖于另一个作业，则使用<code>JobHandle</code>管理依赖关系而不是尝试在作业内安排作业。</p><h4 id="在合适的时间使用计划和完成">在合适的时间使用计划和完成</h4><p><code>Schedule</code>只要您拥有所需的数据就立即打电话给工作，并且<code>Complete</code>在您需要结果之前不要打电话给它。优秀的做法是安排一个您不需要等待的工作，而不是与正在运行的任何其他工作竞争。例如，如果在一帧结束和下一帧的开始之间没有作业正在运行，并且可以接受一帧延迟，则可以将作业调度到帧的末尾并使用其结果在以下框架中。或者，如果您的游戏与其他工作的转换期间相比，并且框架中的其他位置存在大量未充分利用的时间段，则更有效地安排您的工作。</p><h4 id="将nativecontainer类型标记为只读">将NativeContainer类型标记为只读</h4><p>请记住，作业<code>NativeContainer</code>默认情况下对类型具有读写访问权限。<code>[ReadOnly]</code>适当时使用该属性可提高性能。</p><h4 id="检查数据依赖性">检查数据依赖性</h4><p>在Unity Profiler 窗口，主线程上的标记“WaitForJobGroup”表示Unity正在等待工作线程上的作业完成。此标记可能意味着您已在某处应引入数据依赖关系。寻找<code>JobHandle.Complete</code>跟踪数据依赖关系的位置，这些数据依赖关系迫使主线程等待。</p><h4 id="调试作业">调试作业</h4><p>作业具有一个<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Run.html" target="_blank" rel="noopener">Run</a>函数，您可以使用它来代替<code>Schedule</code>在主线程上立即执行作业。您可以将其用于调试目的。</p><h4 id="不要在作业中分配托管内存">不要在作业中分配托管内存</h4><p>在作业中分配托管内存非常慢，并且该作业无法使用Unity <a href="https://www.youtube.com/watch?v=NF6kcNS6U80&amp;t=2s" target="_blank" rel="noopener">Burst编译器</a>来提高性能。Burst是一种新的基于<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM</a>的后端编译器技术，可以让您更轻松。它需要C＃作业并利用您平台的特定功能生成高度优化的机器代码。</p><h4 id="更多的信息">更多的信息</h4><ul><li>观看<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">Unity GDC 2018：</a>剪辑的<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">C＃作业系统</a>播放列表。</li><li>有关C＃作业系统如何与ECS相关的更多高级信息，请参阅<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">GitHub上</a>的<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">ECS包文档</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Unity C＃作业系统时，请确保遵守以下内容：&lt;/p&gt;
&lt;h4 id=&quot;不要从作业访问静态数据&quot;&gt;不要从作业访问静态数据&lt;/h4&gt;
&lt;p&gt;从作业访问静态数据会绕过所有安全系统。如果您访问错误的数据，您可能会以意想不到的方式崩溃Unity。例如，访问&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MonoBehaviour.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MonoBehaviour&lt;/a&gt;可能会导致域重新加载崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于存在这种风险，Unity的未来版本将阻止使用&lt;a href=&quot;https://www.youtube.com/watch?v=VxeC7WFfg3Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;静态分析&lt;/a&gt;从作业进行全局变量访问。如果您确实访问作业中的静态数据，则应该期望您的代码在Unity的未来版本中中断。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>JobHandle和依赖项</title>
    <link href="https://longshilin.com/blog/9bdee974.html"/>
    <id>https://longshilin.com/blog/9bdee974.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要当您调用作业的schedule方法时-它将返回jobhandle-您可以在代码中使用一个jobhandle作为其他作业的依赖项-如果作业取决于另一个作业的结果-您可以将第一个作业jobhandle作为参数传递给第二个作业的schedule方法-如下所示：">要当您调用作业的<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>方法时，它将返回<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html" target="_blank" rel="noopener">JobHandle</a>。您可以在代码中使用一个<code>JobHandle</code>作为其他作业的依赖项。如果作业取决于另一个作业的结果，您可以将第一个作业<code>JobHandle</code>作为参数传递给第二个作业的<code>Schedule</code>方法，如下所示：</h4><a id="more"></a><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">JobHandle firstJobHandle = firstJob.Schedule();</span><br><span class="line">secondJob.Schedule(firstJobHandle);</span><br></pre></td></tr></table></figure><h4 id="结合依赖关系">结合依赖关系</h4><p>如果作业具有许多依赖项，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.CombineDependencies.html" target="_blank" rel="noopener">JobHandle.CombineDependencies</a>方法合并它们。<code>CombineDependencies</code>允许您将它们传递给<code>Schedule</code>方法。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;JobHandle&gt; handles = <span class="keyword">new</span> NativeArray&lt;JobHandle&gt;(numJobs, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Populate `handles` with `JobHandles` from multiple scheduled jobs...</span></span><br><span class="line"></span><br><span class="line">JobHandle jh = JobHandle.CombineDependencies(handles);</span><br></pre></td></tr></table></figure><h4 id="在主线程中等待工作">在主线程中等待工作</h4><p>使用<code>JobHandle</code>强迫你的代码在主线程等待您的工作执行完毕。要做到这一点，调用<code>JobHandle的Complete方法</code>。此时，您知道主线程可以安全地访问作业正在使用的<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>。</p><p><strong>注意</strong>：在计划作业时，作业不会开始执行。如果您正在等待主线程中的作业，并且您需要访问作业正在使用的NativeContainer数据，则可以调用该方法<code>JobHandle.Complete</code>。此方法从内存高速缓存中刷新作业并启动执行过程。在`JobHandle<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">否则，如果您不需要访问数据，则需要明确刷新批处理。为此，请调用静态方法[JobHandle.ScheduleBatchedJobs](https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html)。请注意，调用此方法会对性能产生负面影响。</span><br><span class="line"></span><br><span class="line">#### 多个作业和依赖项的示例</span><br><span class="line"></span><br><span class="line">**工作代码**：</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line">// Job adding two floating point values together</span><br><span class="line">public struct MyJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public float a;</span><br><span class="line">    public float b;</span><br><span class="line">    public NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Job adding one to a value</span><br><span class="line">public struct AddOneJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] = result[0] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>主线程代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a native array of a single float to store the result in. This example waits for the job to complete</span></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the data for job #1</span></span><br><span class="line">MyJob jobData = <span class="keyword">new</span> MyJob();</span><br><span class="line">jobData.a = <span class="number">10</span>;</span><br><span class="line">jobData.b = <span class="number">10</span>;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule job #1</span></span><br><span class="line">JobHandle firstHandle = jobData.Schedule();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the data for job #2</span></span><br><span class="line">AddOneJob incJobData = <span class="keyword">new</span> AddOneJob();</span><br><span class="line">incJobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule job #2</span></span><br><span class="line">JobHandle secondHandle = incJobData.Schedule(firstHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for job #2 to complete</span></span><br><span class="line">secondHandle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// All copies of the NativeArray point to the same memory, you can access the result in "your" copy of the NativeArray</span></span><br><span class="line"><span class="keyword">float</span> aPlusB = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the memory allocated by the result array</span></span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要当您调用作业的schedule方法时-它将返回jobhandle-您可以在代码中使用一个jobhandle作为其他作业的依赖项-如果作业取决于另一个作业的结果-您可以将第一个作业jobhandle作为参数传递给第二个作业的schedule方法-如下所示：&quot;&gt;要当您调用作业的&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Schedule&lt;/a&gt;方法时，它将返回&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JobHandle&lt;/a&gt;。您可以在代码中使用一个&lt;code&gt;JobHandle&lt;/code&gt;作为其他作业的依赖项。如果作业取决于另一个作业的结果，您可以将第一个作业&lt;code&gt;JobHandle&lt;/code&gt;作为参数传递给第二个作业的&lt;code&gt;Schedule&lt;/code&gt;方法，如下所示：&lt;/h4&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>什么是多线程？</title>
    <link href="https://longshilin.com/blog/b293e36.html"/>
    <id>https://longshilin.com/blog/b293e36.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在单线程计算系统中，一次进入一条指令，一次出现一条结果。加载和完成程序的时间取决于CPU需要完成的工作量。</p><p>多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力。它们不是一个接一个地执行任务或指令，而是同时运行。</p><a id="more"></a><p>默认情况下，一个线程在程序的开头运行。这是“主线”。主线程创建新线程来处理任务。这些新线程彼此并行运行，并且通常在完成后将其结果与主线程同步。</p><p>如果您有一些运行很长时间的任务，这种多线程方法很有效。但是，游戏开发代码通常包含许多一次执行的小指令。如果为每个线程创建一个线程，最终可能会有许多线程，每个线程的生命周期都很短。这可以推动CPU和操作系统处理能力的极限。</p><p>通过拥有一个<a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener">线程池</a>可以缓解线程生存期的问题。但是，即使您使用线程池，也可能同时激活大量线程。线程数多于CPU核心导致线程相互竞争CPU资源，导致频繁的<a href="https://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener">上下文切换</a>。上下文切换是通过执行保存线程状态，然后处理另一个线程，然后重新构建第一个线程以继续处理它的过程。上下文切换是资源密集型的，因此您应尽可能避免使用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在单线程计算系统中，一次进入一条指令，一次出现一条结果。加载和完成程序的时间取决于CPU需要完成的工作量。&lt;/p&gt;
&lt;p&gt;多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力。它们不是一个接一个地执行任务或指令，而是同时运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>C＃作业系统中的安全系统</title>
    <link href="https://longshilin.com/blog/70ae4a2e.html"/>
    <id>https://longshilin.com/blog/70ae4a2e.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="比赛条件">比赛条件</h4><p>编写<a href="https://docs.unity3d.com/Manual/JobSystemMultithreading.html" target="_blank" rel="noopener">多线程代码时</a>，总是存在<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞争条件</a>的风险。当一个操作的输出取决于其控制之外的另一个过程的定时时，发生竞争条件。</p><p>竞争条件并不总是一个错误，但它是不确定行为的来源。当竞争条件确实导致错误时，可能很难找到问题的根源，因为它取决于时间，因此您只能在极少数情况下重新创建问题。调试它可能会导致问题消失，因为断点和日志记录可以改变单个线程的时间。竞争条件是编写多线程代码时最重大的挑战。</p><a id="more"></a><h4 id="安全系统">安全系统</h4><p>为了更容易编写多线程代码，Unity C＃作业系统可以检测所有潜在的竞争条件，并保护您免受可能导致的错误的影响。</p><p>例如：如果C＃作业系统将主线程中代码中的数据<a href="https://docs.microsoft.com/en-us/cpp/cpp/references-cpp" target="_blank" rel="noopener">引用</a>发送到作业，则无法验证主线程是否在作业写入数据的同时读取数据。此方案会创建竞争条件。</p><p>C＃作业系统通过向每个作业发送它需要操作的数据的副本来解决这个问题，而不是对主线程中的数据的引用。此副本隔离数据，从而消除竞争条件。</p><p>C＃作业系统复制数据的方式意味着作业只能访问<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable数据类型</a>。在<a href="https://en.wikipedia.org/wiki/Managed_code" target="_blank" rel="noopener">托管</a>代码和本机代码之间传递时，这些类型不需要转换。</p><p>C＃Job System可以使用<a href="http://www.cplusplus.com/reference/cstring/memcpy/" target="_blank" rel="noopener">memcpy</a>复制blittable类型，并在Unity的托管和本机部分之间传输数据。它用于<code>memcpy</code>在调度作业时将数据放入本机内存，并在执行作业时为受管方提供对该副本的访问权限。有关更多信息，请参阅<a href="https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html" target="_blank" rel="noopener">计划作业</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;比赛条件&quot;&gt;比赛条件&lt;/h4&gt;
&lt;p&gt;编写&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemMultithreading.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程代码时&lt;/a&gt;，总是存在&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;竞争条件&lt;/a&gt;的风险。当一个操作的输出取决于其控制之外的另一个过程的定时时，发生竞争条件。&lt;/p&gt;
&lt;p&gt;竞争条件并不总是一个错误，但它是不确定行为的来源。当竞争条件确实导致错误时，可能很难找到问题的根源，因为它取决于时间，因此您只能在极少数情况下重新创建问题。调试它可能会导致问题消失，因为断点和日志记录可以改变单个线程的时间。竞争条件是编写多线程代码时最重大的挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>NativeContainer</title>
    <link href="https://longshilin.com/blog/ac3c63a9.html"/>
    <id>https://longshilin.com/blog/ac3c63a9.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.unity3d.com/Manual/JobSystemSafetySystem.html" target="_blank" rel="noopener">安全系统</a>复制数据<a href="https://docs.unity3d.com/Manual/JobSystemSafetySystem.html" target="_blank" rel="noopener">的</a>过程的缺点是它还隔离了每个副本中作业的结果。要克服此限制，您需要将结果存储在一种名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>的共享内存中。</p><a id="more"></a><h2 id="什么是nativecontainer？">什么是NativeContainer？</h2><p>A <code>NativeContainer</code>是托管值类型，为本机内存提供相对安全的C＃包装器。它包含指向非托管分配的指针。与Unity C＃作业系统一起使用时，a <code>NativeContainer</code>允许作业访问与主线程共享的数据，而不是使用副本。</p><h2 id="有哪些类型的nativecontainer？">有哪些类型的NativeContainer？</h2><p>Unity附带一个<code>NativeContainer</code>名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html" target="_blank" rel="noopener">NativeArray的程序</a>。您还可以<code>NativeArray</code>使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeSlice_1.html" target="_blank" rel="noopener">NativeSlice</a>操作a 以获取<code>NativeArray</code>从特定位置到特定长度的子集。</p><p>注意：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">实体组件系统</a>（ECS）包扩展了<code>Unity.Collections</code>命名空间以包括其他类型<code>NativeContainer</code>：</p><ul><li><code>NativeList</code>- 可调整大小<code>NativeArray</code>。</li><li><code>NativeHashMap</code> - 键和值对。</li><li><code>NativeMultiHashMap</code> - 每个键有多个值。</li><li><code>NativeQueue</code>- <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener">先进先出</a>（<a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener">FIFO</a>）队列。</li></ul><h2 id="nativecontainer和安全系统">NativeContainer和安全系统</h2><p>安全系统内置于所有<code>NativeContainer</code>类型。它跟踪什么是读写任何内容<code>NativeContainer</code>。</p><p>注意：所有<code>NativeContainer</code>类型的安全检查（例如越界检查，重新分配检查和竞争条件检查）仅在Unity 编辑器和播放模式下可用。</p><p>该安全系统的一部分是<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.DisposeSentinel.html" target="_blank" rel="noopener">DisposeSentinel</a>和<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle.html" target="_blank" rel="noopener">AtomicSafetyHandle</a>。该<code>DisposeSentinel</code>检测内存泄漏，给你一个错误，如果你没有正确地释放你的记忆。泄漏发生后很久就会发生内存泄漏错误。</p><p>使用<code>AtomicSafetyHandle</code>转移<code>NativeContainer</code>代码的所有权。例如，如果两个预定作业写入相同<code>NativeArray</code>，则安全系统会抛出异常，并显示明确的错误消息，说明解决问题的原因和方法。安排违规工作时，安全系统会抛出此异常。</p><p>在这种情况下，您可以安排具有依赖关系的作业。第一个作业可以写入<code>NativeContainer</code>，一旦完成执行，下一个作业就可以安全地读取和写入相同的作业<code>NativeContainer</code>。从主线程访问数据时，读写限制也适用。安全系统允许多个作业并行读取相同的数据。</p><p>默认情况下，当作业有权访问a时<code>NativeContainer</code>，它具有读写访问权限。此配置可能会降低性能。C＃作业系统不允许您计划与写入其中的<code>NativeContainer</code>另一个作业同时具有写访问权限的作业。</p><p>如果作业不需要写入a <code>NativeContainer</code>，请<code>NativeContainer</code>使用<code>[ReadOnly]</code>属性标记，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ReadOnly]</span><br><span class="line">public NativeArray&lt;int&gt; input;</span><br></pre></td></tr></table></figure><p>在上面的示例中，您可以与其他对第一个也具有只读访问权限的作业同时执行作业<code>NativeArray</code>。</p><p>注意：无法防止从作业中访问静态数据。访问静态数据会绕过所有安全系统，并可能导致Unity崩溃。有关更多信息，请参阅<a href="https://docs.unity3d.com/Manual/JobSystemTroubleshooting.html" target="_blank" rel="noopener">C＃作业系统提示和故障排除</a>。</p><h2 id="nativecontainer分配器">NativeContainer分配器</h2><p>创建时<code>NativeContainer</code>，必须指定所需的内存分配类型。分配类型取决于作业运行的时间长度。通过这种方式，您可以定制分配以在每种情况下获得最佳性能。</p><p>内存分配和释放有三种<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html" target="_blank" rel="noopener">Allocator</a>类型<code>NativeContainer</code>。在实例化你的时候需要指定合适的一个<code>NativeContainer</code>。</p><ul><li>Allocator.Temp分配最快。它适用于寿命为一帧或更少的分配。您不应将<code>NativeContainer</code>分配<code>Temp</code>用于作业。您还需要<code>Dispose</code>在从方法调用返回之前调用该方法（例如<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html" target="_blank" rel="noopener">MonoBehaviour.Update</a>，或从本机代码到托管代码的任何其他回调）。</li><li>Allocator.TempJob是一个比较慢的分配，<code>Temp</code>但速度比<code>Persistent</code>。它适用于四帧生命周期内的分配，并且是线程安全的。如果<code>Dispose</code>在四帧内没有，则控制台会打印一条警告，该警告是从本机代码生成的。大多数小型工作都使用此<code>NativeContainer</code>分配类型。</li><li>Allocator.Persistent是最慢的分配，但只要你需要它，并且如果有必要，可以持续整个应用程序的生命周期。它是直接调用<a href="http://www.cplusplus.com/reference/cstdlib/malloc/" target="_blank" rel="noopener">malloc</a>的包装器。较长的作业可以使用此<code>NativeContainer</code>分配类型。你不应该使用<code>Persistent</code>性能至关重要的地方。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;float&gt; result = new NativeArray&lt;float&gt;(1, Allocator.TempJob);</span><br></pre></td></tr></table></figure><p>注意：上例中的数字1表示的大小<code>NativeArray</code>。在这种情况下，它只有一个数组元素（因为它只存储一个数据<code>result</code>）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemSafetySystem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全系统&lt;/a&gt;复制数据&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemSafetySystem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;的&lt;/a&gt;过程的缺点是它还隔离了每个副本中作业的结果。要克服此限制，您需要将结果存储在一种名为&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NativeContainer&lt;/a&gt;的共享内存中。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>ParallelForTransform作业</title>
    <link href="https://longshilin.com/blog/894c6889.html"/>
    <id>https://longshilin.com/blog/894c6889.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>ParallelForTransform作业是另一种<a href="https://docs.unity3d.com/Manual/JobSystemParallelForJobs.html" target="_blank" rel="noopener">ParallelFor作业</a> ; 专为在<a href="https://docs.unity3d.com/Manual/Transforms.html" target="_blank" rel="noopener">变形上</a>操作而设计。</p><p><strong>注意</strong>：ParallelForTransform作业是Unity中用于实现<a href="https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransform.html" target="_blank" rel="noopener">IJobParallelForTransform</a>接口的任何作业的集合术语。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ParallelForTransform作业是另一种&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemParallelForJobs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ParallelFor作业&lt;/a&gt; ; 专为在&lt;a href=&quot;https://docs.unity3d.com/Manual/Transforms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;变形上&lt;/a&gt;操作而设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：ParallelForTransform作业是Unity中用于实现&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransform.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IJobParallelForTransform&lt;/a&gt;接口的任何作业的集合术语。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>C# Job System 概述</title>
    <link href="https://longshilin.com/blog/c28c374b.html"/>
    <id>https://longshilin.com/blog/c28c374b.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-作业系统是如何工作">C# 作业系统是如何工作</h3><ul><li>允许用户编写与Unity其余部分良好交互的<a href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)" target="_blank" rel="noopener">多线程代码</a>，并使编写正确的代码变得更加容易。</li><li>编写多线程代码可以提供高性能的好处，其中包括<strong>帧速率的显著提高</strong>、以及将Burst编译器与C#作业一起使用<strong>可以提高代码生成质量</strong>，<strong>从而大大降低移动设备的电池消耗。</strong></li><li>一个重要方面是它与Unity内部使用的集成（Unity的本地作业系统）。用户编写的diamante和Unity共享<a href="https://docs.microsoft.com/zh-cn/cpp/parallel/multithreading-creating-worker-threads?view=vs-2019" target="_blank" rel="noopener">工作线程</a>，这种合作避免了创建比CPU核心更多的线程，从而降低对CPU资源的争用。</li></ul><a id="more"></a><p>相关资料整理：</p><ul><li>官方文档：<a href="https://docs.unity3d.com/Manual/JobSystem.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/JobSystem.html</a></li><li>官方示例：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md</a></li><li>官方视频：<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-作业系统是如何工作&quot;&gt;C# 作业系统是如何工作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;允许用户编写与Unity其余部分良好交互的&lt;a href=&quot;https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程代码&lt;/a&gt;，并使编写正确的代码变得更加容易。&lt;/li&gt;
&lt;li&gt;编写多线程代码可以提供高性能的好处，其中包括&lt;strong&gt;帧速率的显著提高&lt;/strong&gt;、以及将Burst编译器与C#作业一起使用&lt;strong&gt;可以提高代码生成质量&lt;/strong&gt;，&lt;strong&gt;从而大大降低移动设备的电池消耗。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个重要方面是它与Unity内部使用的集成（Unity的本地作业系统）。用户编写的diamante和Unity共享&lt;a href=&quot;https://docs.microsoft.com/zh-cn/cpp/parallel/multithreading-creating-worker-threads?view=vs-2019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工作线程&lt;/a&gt;，这种合作避免了创建比CPU核心更多的线程，从而降低对CPU资源的争用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>GameFramework框架学习流程</title>
    <link href="https://longshilin.com/blog/b42dd2c7.html"/>
    <id>https://longshilin.com/blog/b42dd2c7.html</id>
    <published>2019-05-29T00:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<div style="padding-bottom:56.25%; position:relative; display:block; width: 100%"> <iframe width="100%" height="100%" src="https://www.processon.com/embed/5cb99469e4b0841b84374217" frameborder="0" allowfullscreen style="position:absolute; top:0; left: 0"></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;padding-bottom:56.25%; position:relative; display:block; width: 100%&quot;&gt;
 &lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;https://www.proc
      
    
    </summary>
    
      <category term="框架" scheme="https://longshilin.com/blog/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="GameFramework" scheme="https://longshilin.com/blog/categories/%E6%A1%86%E6%9E%B6/GameFramework/"/>
    
    
      <category term="GameFramework" scheme="https://longshilin.com/blog/tags/GameFramework/"/>
    
  </entry>
  
  <entry>
    <title>virtual和override实现继承关系</title>
    <link href="https://longshilin.com/blog/3e7c0e8a.html"/>
    <id>https://longshilin.com/blog/3e7c0e8a.html</id>
    <published>2019-05-24T02:25:21.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/inheritance" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/inheritance</a></p><p>详细信息直接看官方文档，我只记录自己的一点感受。</p><ol><li>子类继承父类时，需要用virtual和override配合。</li><li>子类重载方法中调用父类的该重载源方法，例如：<code>base.method();</code>，如果子类中没有调用，则不会执行父类该源方法的逻辑。</li></ol><a id="more"></a><p>------ 示例 ------</p><p><kbd>BaseClass.cs</kbd></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LearnCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"我是Base类！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><kbd>ChildClass.cs</kbd></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LearnCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ChildClass</span> : <span class="title">BaseClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// 调用子类的逻辑</span></span><br><span class="line">            Console.WriteLine(<span class="string">"我是Child类!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用父类的逻辑</span></span><br><span class="line">            <span class="keyword">base</span>.method();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            ChildClass childClass = <span class="keyword">new</span> ChildClass();</span><br><span class="line">            childClass.method();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><kbd>控制台输出</kbd><br><img src="https://longshilin.com/images/20190524142854.png" alt="控制台输出"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/inheritance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/inheritance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细信息直接看官方文档，我只记录自己的一点感受。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子类继承父类时，需要用virtual和override配合。&lt;/li&gt;
&lt;li&gt;子类重载方法中调用父类的该重载源方法，例如：&lt;code&gt;base.method();&lt;/code&gt;，如果子类中没有调用，则不会执行父类该源方法的逻辑。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="语言" scheme="https://longshilin.com/blog/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="CSharp" scheme="https://longshilin.com/blog/categories/%E8%AF%AD%E8%A8%80/CSharp/"/>
    
    
      <category term="继承" scheme="https://longshilin.com/blog/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Atom自定义代码片段以提高编码效率</title>
    <link href="https://longshilin.com/blog/f427fb19.html"/>
    <id>https://longshilin.com/blog/f427fb19.html</id>
    <published>2019-05-23T10:48:03.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过在Atom中自定义代码片段，绑定指定的文件类型，就可以在编辑该类型文件时实现快速提示功能。<br><img src="https://longshilin.com/images/20190523104526.gif" alt="Atom定制快捷提示片段示例"></p><a id="more"></a><p><img src="https://longshilin.com/images/20190523104940.png" alt="打开Atom的Snippets设置"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下面是我的自定义</span><br><span class="line">&apos;.text.md&apos;:</span><br><span class="line">  &apos;more&apos;:</span><br><span class="line">    &apos;prefix&apos;: &apos;more&apos;</span><br><span class="line">    &apos;body&apos;: &apos;&lt;!-- more --&gt;&apos;</span><br><span class="line"></span><br><span class="line">  &apos;title&apos;:</span><br><span class="line">    &apos;prefix&apos;: &apos;title&apos;</span><br><span class="line">    &apos;body&apos;: &apos;--- \ntitle: $1 \nlayout: post \ntags: \n  - $2 \ncategories: \n  - $3 \ncomments: true \ntoc: false \ndate: $4  \n---\n&apos;</span><br></pre></td></tr></table></figure><p>具体Snippets文件中的语法参考下面的官方文档：</p><p><a href="https://flight-manual.atom.io/using-atom/sections/basic-customization/#_cson" title="Atom基本定制" target="_blank" rel="noopener">1.Atom基本定制官方文档</a></p><p><a href="https://flight-manual.atom.io/using-atom/sections/snippets/" target="_blank" rel="noopener">2.Atom片段设置</a></p><p><img src="https://longshilin.com/images/20190523105720.png" alt="查看文件类型的快速方式"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过在Atom中自定义代码片段，绑定指定的文件类型，就可以在编辑该类型文件时实现快速提示功能。&lt;br&gt;
&lt;img src=&quot;https://longshilin.com/images/20190523104526.gif&quot; alt=&quot;Atom定制快捷提示片段示例&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://longshilin.com/blog/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Atom" scheme="https://longshilin.com/blog/categories/%E5%B7%A5%E5%85%B7/Atom/"/>
    
    
      <category term="Atom Snippets" scheme="https://longshilin.com/blog/tags/Atom-Snippets/"/>
    
      <category term="效率" scheme="https://longshilin.com/blog/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>创建ECS项目</title>
    <link href="https://longshilin.com/blog/ac01c54a.html"/>
    <id>https://longshilin.com/blog/ac01c54a.html</id>
    <published>2019-05-22T18:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择unity版本">选择Unity版本</h3><p>我这里安装的是Unity2019.2.0b1版本，通过Unity Hub直接安装的，顺便推荐下Unity Hub这个软件。它是Unity官方用来在同一电脑上管理多个Unity版本的协同工具。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190522212113.png" alt="选择Unity版本"></p><p><img src="https://longshilin.com/images/20190522212923.png" alt="创建项目"></p><p><img src="https://longshilin.com/images/20190522213442.png" alt="这是刚打开的样子"></p><h3 id="安装package">安装Package</h3><p><img src="https://longshilin.com/images/20190522214037.png" alt="打开Package Manager窗口"></p><p>由于ECS还没有作为正式组件公之于众，因此只能在预览包中看到它们的身影，ps：ECS作为正式组件预计在Unity2020.1版本中。</p><p><img src="https://longshilin.com/images/20190522214903.png" alt="预览版Package"></p><p>安装两个Package：</p><ul><li>Entities</li><li>Hybrid.Renderer</li></ul><p><img src="https://longshilin.com/images/20190522215142.png" alt="Entities Package"></p><p><img src="https://longshilin.com/images/20190522215208.png" alt="Hybrid.Renderer Package"></p><p>下面我们来对比下安装之前和安装之后，到底多了哪些包依赖，下面图是通过对比工具得到的，其实刚好就是增加安装的那两个包。</p><p><img src="https://longshilin.com/images/20190522214752.png" alt="安装package前后对比结果"></p><h3 id="了解package的依赖关系">了解Package的依赖关系</h3><p>另外需要补充的是，在安装这两个package的时候，下面这些包也已经被加入到项目中：</p><ul><li>Burst</li><li>Collections</li><li>Jobs</li><li>Mathematics</li></ul><p>可以通过勾选Advance -&gt; show dependencies查看两个package包依赖关系。</p><p><img src="https://longshilin.com/images/20190522215605.png" alt="Entities Package Dependence"></p><p><img src="https://longshilin.com/images/20190522215759.png" alt="Hybrid.Renderer Package Dependence"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;选择unity版本&quot;&gt;选择Unity版本&lt;/h3&gt;
&lt;p&gt;我这里安装的是Unity2019.2.0b1版本，通过Unity Hub直接安装的，顺便推荐下Unity Hub这个软件。它是Unity官方用来在同一电脑上管理多个Unity版本的协同工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="Project" scheme="https://longshilin.com/blog/tags/Project/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D中使用委托</title>
    <link href="https://longshilin.com/blog/30526cbb.html"/>
    <id>https://longshilin.com/blog/30526cbb.html</id>
    <published>2019-05-14T20:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先来了解委托是什么，在《Unity3D脚本编程》一书中，指明委托要确定一个回调方法签名，包括参数以及返回类型等。在下面的例子中，MyDelegate委托定制的回调方法的参数类型是int型，同时返回类型为void。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个委托类型，它的实例引用一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="keyword">int</span> num</span>)</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在为委托实例引用方法时，C#允许引用类型的协变性和逆变性。协变性是指方法的返回类型可以是从委托的返回类型派生的一个派生类，逆变性则是指方法获取的参数的类型可以是委托的参数的类型的基类。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个委托类型</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> Object <span class="title">TellMeYourName</span>(<span class="params">SoldierClass soldier</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个方法，该方法的返回值是委托的返回类型派生的一个派生类</span></span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">TellMeYourNameMethod</span>(<span class="params">BaseUnitClass <span class="keyword">base</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这里该方法不能被绑定到委托实例上，编译器会报错。</span></span><br><span class="line"><span class="comment">// 这是因为虽然int型和string型一样，都派生自Object类，但是int型是值类型，因此是不支持协变性的。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TellMeYourNameMethod</span>(<span class="params">BaseUnitClass <span class="keyword">base</span></span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先来了解委托是什么，在《Unity3D脚本编程》一书中，指明委托要确定一个回调方法签名，包括参数以及返回类型等。在下面的例子中，MyDelegate委托定制的回调方法的参数类型是int型，同时返回类型为void。&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//声明一个委托类型，它的实例引用一个方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;delegate&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyDelegate&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="脚本编程" scheme="https://longshilin.com/blog/categories/Unity/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Unity" scheme="https://longshilin.com/blog/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>1. Scripts as Behaviour Components</title>
    <link href="https://longshilin.com/blog/d6acd003.html"/>
    <id>https://longshilin.com/blog/d6acd003.html</id>
    <published>2019-05-14T19:00:00.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是本栏目的开篇文章，从一开始就了解游戏开发的编程。</p><a id="more"></a><h3 id="流程">流程</h3><p>创建一个Scene并添加一个Cube，在Cube上挂载<code>ExampleBehaviourScript.cs</code>这个文件，然后启动游戏。通过键盘输入 <kbd>R</kbd> 或 <kbd>G</kbd> 或 <kbd>B</kbd> 来改变Cube的颜色。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.R))</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Renderer&gt; ().material.color = Color.red;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.G))</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Renderer&gt;().material.color = Color.green;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.B))</span><br><span class="line">        &#123;</span><br><span class="line">            GetComponent&lt;Renderer&gt;().material.color = Color.blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本栏目的开篇文章，从一开始就了解游戏开发的编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Unity基础入门学习笔记" scheme="https://longshilin.com/blog/categories/Unity/Unity%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Scripts" scheme="https://longshilin.com/blog/categories/Unity/Unity%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Scripts/"/>
    
    
      <category term="Unity" scheme="https://longshilin.com/blog/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>windows和mac上安装Tower破解版</title>
    <link href="https://longshilin.com/blog/b5410c9.html"/>
    <id>https://longshilin.com/blog/b5410c9.html</id>
    <published>2019-02-02T14:42:24.000Z</published>
    <updated>2019-08-11T10:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tower确实蛮好用的，才试用了几天就爱上了它。在<a href="https://www.git-tower.com" target="_blank" rel="noopener">Tower官网</a>这里有关它的介绍，以及有专门的<a href="https://www.git-tower.com/learn/" target="_blank" rel="noopener">电子书和视频</a>来让你快速上手Tower和git。</p><p><img src="https://ws1.sinaimg.cn/large/005EsThygy1fzs24oey0aj31z413ztdg.jpg" alt=""></p><a id="more"></a><p>#<kbd>Tower for windows</kbd><br>版本号截图<br><img src="https://longshilin.com/images/20190507100004.jpg" alt=""></p><p>Tower内部界面<br><img src="https://longshilin.com/images/20190507100014.jpg" alt=""></p><blockquote><p>下载地址：<a href="https://pan.baidu.com/s/1uFCJ3m18RUA1vhPfs27Zvw" target="_blank" rel="noopener">https://pan.baidu.com/s/1uFCJ3m18RUA1vhPfs27Zvw</a> 密码：r1ys</p></blockquote><p>#<kbd>Tower for Mac</kbd><br>版本号截图<br><img src="https://longshilin.com/images/20190507100042.jpg" alt=""></p><p>Tower内部界面<br><img src="https://longshilin.com/images/20190507100050.jpg" alt=""></p><blockquote><p>下载链接：<a href="https://pan.baidu.com/s/1mIQQXm-bEZcbnz06G-FJ2w" target="_blank" rel="noopener">https://pan.baidu.com/s/1mIQQXm-bEZcbnz06G-FJ2w</a> 密码：6fbn</p></blockquote><blockquote><p>有任何问题，请在留言区留言给我~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tower确实蛮好用的，才试用了几天就爱上了它。在&lt;a href=&quot;https://www.git-tower.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tower官网&lt;/a&gt;这里有关它的介绍，以及有专门的&lt;a href=&quot;https://www.git-tower.com/learn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电子书和视频&lt;/a&gt;来让你快速上手Tower和git。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/005EsThygy1fzs24oey0aj31z413ztdg.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://longshilin.com/blog/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="版本控制" scheme="https://longshilin.com/blog/categories/%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="tower" scheme="https://longshilin.com/blog/tags/tower/"/>
    
      <category term="git" scheme="https://longshilin.com/blog/tags/git/"/>
    
  </entry>
  
</feed>
