<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gamedev</title>
  
  <subtitle>AWS, DevOps, IT Infrastructure, and Other Puzzles</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://longshilin.com/blog/"/>
  <updated>2019-08-12T01:46:45.000Z</updated>
  <id>https://longshilin.com/blog/</id>
  
  <author>
    <name>longshilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是多线程？</title>
    <link href="https://longshilin.com/blog/b293e36.html"/>
    <id>https://longshilin.com/blog/b293e36.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在单线程计算系统中，一次进入一条指令，一次出现一条结果。加载和完成程序的时间取决于CPU需要完成的工作量。</p><p>多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力。它们不是一个接一个地执行任务或指令，而是同时运行。</p><a id="more"></a><p>默认情况下，一个线程在程序的开头运行。这是“主线”。主线程创建新线程来处理任务。这些新线程彼此并行运行，并且通常在完成后将其结果与主线程同步。</p><p>如果您有一些运行很长时间的任务，这种多线程方法很有效。但是，游戏开发代码通常包含许多一次执行的小指令。如果为每个线程创建一个线程，最终可能会有许多线程，每个线程的生命周期都很短。这可以推动CPU和操作系统处理能力的极限。</p><p>通过拥有一个<a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener">线程池</a>可以缓解线程生存期的问题。但是，即使您使用线程池，也可能同时激活大量线程。线程数多于CPU核心导致线程相互竞争CPU资源，导致频繁的<a href="https://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener">上下文切换</a>。上下文切换是通过执行保存线程状态，然后处理另一个线程，然后重新构建第一个线程以继续处理它的过程。上下文切换是资源密集型的，因此您应尽可能避免使用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在单线程计算系统中，一次进入一条指令，一次出现一条结果。加载和完成程序的时间取决于CPU需要完成的工作量。&lt;/p&gt;
&lt;p&gt;多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力。它们不是一个接一个地执行任务或指令，而是同时运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>并行工作</title>
    <link href="https://longshilin.com/blog/3c908d6c.html"/>
    <id>https://longshilin.com/blog/3c908d6c.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>当<a href="https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html" target="_blank" rel="noopener">调度工作</a>，只能有一个工作做一个任务。在游戏中，通常希望对大量对象执行相同的操作。有一个名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobParallelFor.html" target="_blank" rel="noopener">IJobParallelFor</a>的独立作业类型来处理这个问题。</p><p><strong>注意</strong>：“ParallelFor”作业是Unity中用于实现<code>IJobParallelFor</code>接口的任何结构的集合术语。</p><a id="more"></a><p>ParallelFor作业使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html" target="_blank" rel="noopener">NativeArray</a>数据作为其数据源。ParallelFor作业跨多个核心运行。每个核心有一个作业，每个作业处理一部分工作量。<code>IJobParallelFor</code>表现得像<code>IJob</code>，但它不是单个<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.Execute.html" target="_blank" rel="noopener">Execute</a>方法，而是<code>Execute</code>在数据源中的每个项目上调用一次方法。方法中有一个整数参数<code>Execute</code>。该索引用于访问和操作作业实现中的数据源的单个元素。</p><h4 id="parallelfor作业定义的示例：">ParallelFor作业定义的示例：</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> IncrementByDeltaTimeJob: IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; values;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span> (<span class="params"><span class="keyword">int</span> index</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">float</span> temp = values[index];</span><br><span class="line">        temp += deltaTime;</span><br><span class="line">        values[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调度parallelfor作业">调度ParallelFor作业</h4><p>在调度ParallelFor作业时，必须指定<code>NativeArray</code>要拆分的数据源的长度。<code>NativeArray</code>如果结构中有多个，Unity C＃作业系统无法知道您要将哪个用作数据源。长度还告诉C＃作业系统需要多少<code>Execute</code>方法。</p><p>幕后花絮，ParallelFor作业的调度更复杂。在调度ParallelFor作业时，C＃作业系统将工作分成批处理以在核心之间分配。每批包含一组<code>Execute</code>方法。然后，C＃作业系统在每个CPU核心的Unity本机作业系统中调度最多一个作业，并将该本机作业通过一些批次来完成。</p><p><a href="https://docs.unity3d.com/uploads/Main/jobsystem_parallelfor_job_batches.svg" target="_blank" rel="noopener"><img src="https://longshilin.com/images/20190811161551.png" alt="ParallelFor在核心之间划分批次的作业"></a></p><p>当本地作业在其他作业之前完成其批处理时，它会从其他本机作业中<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener">窃取</a>剩余批处理。它一次只能窃取本机作业剩余批次的一半，以确保<a href="https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance" target="_blank" rel="noopener">缓存局部性</a>。</p><p>要优化过程，您需要指定批次计数。批次计数控制您获得的作业数量，以及线程之间工作重新分配的细化程度。批量计数较低（例如1）可以使线程之间的工作分布更均匀。它确实带来了一些开销，所以有时候增加批量计数会更好。从1开始并增加批次计数直到可忽略不计的性能增益是一种有效的策略。</p><h4 id="调度parallelfor作业的示例">调度ParallelFor作业的示例</h4><p><strong>工作代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Job adding two floating point values together</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyParallelJob : IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ReadOnly</span>]</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">    [<span class="meta">ReadOnly</span>]</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        result[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主线程代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; a = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; b = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2.2</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.3</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">4.4</span>;</span><br><span class="line"></span><br><span class="line">MyParallelJob jobData = <span class="keyword">new</span> MyParallelJob();</span><br><span class="line">jobData.a = a;</span><br><span class="line">jobData.b = b;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule the job with one Execute per index in the results array and only 1 item per processing batch</span></span><br><span class="line">JobHandle handle = jobData.Schedule(result.Length, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the job to complete</span></span><br><span class="line">handle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the memory allocated by the arrays</span></span><br><span class="line">a.Dispose();</span><br><span class="line">b.Dispose();</span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调度工作&lt;/a&gt;，只能有一个工作做一个任务。在游戏中，通常希望对大量对象执行相同的操作。有一个名为&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobParallelFor.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IJobParallelFor&lt;/a&gt;的独立作业类型来处理这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：“ParallelFor”作业是Unity中用于实现&lt;code&gt;IJobParallelFor&lt;/code&gt;接口的任何结构的集合术语。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>解读GitHub EntityComponentSystemSamples</title>
    <link href="https://longshilin.com/blog/c763759a.html"/>
    <id>https://longshilin.com/blog/c763759a.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>出自Unity官方的ECS项目示例，该项目的第一次Commit是在2018年3月20号，距离现在一年半的时间，这期间ECS本身的生态在快速发展，稳定性也是逐步提升，期待在2020年的Unity版本中作为正式组件发布。好了，下面进入正题~ 对该项目的README做简单翻译和总结。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190811214015.png" alt=""></p><h3 id="欢迎">欢迎</h3><p>欢迎来到DOTS样品资源！</p><p>在这里，您可以找到今天开始使用这些新系统构建所需的资源。</p><p>我们还提供了一个论坛，您可以在其中找到更多信息并与这些新系统分享您的经验。</p><p><a href="https://unity3d.com/performance-by-default" target="_blank" rel="noopener">点击此处访问论坛</a></p><h4 id="什么是面向unity数据的技术堆栈？">什么是面向Unity数据的技术堆栈？</h4><p>我们一直在研究一种新的<strong>高性能多线程系统</strong>，这将使<strong>游戏能够充分利用当今可用的多核处理器而不会出现繁重的编程问题</strong>。面向数据的技术栈包括以下主要系统：</p><ul><li>该<strong>实体组件系统</strong>提供了一种默认编写高性能的代码。</li><li>在<strong>C＃作业系统</strong>提供了一种方法来运行多个CPU内核并行游戏代码</li><li>该<strong>突发编译</strong>一个新的数学感知，后台编译器调整的产生高度优化的机器代码。</li></ul><p>通过这些系统，Unity可以为您正在编译的平台的特定功能生成高度优化的代码。</p><h4 id="entity-component-system">Entity Component System</h4><p>实体组件系统提供了一种更好的游戏设计方法，使您可以专注于您正在解决的实际问题：组成游戏的数据和行为。它利用C＃Job System和Burst Compiler使您能够充分利用当今的多核处理器。从面向对象的设计转向面向数据的设计使您可以更轻松地重用代码，并使其他人更容易理解和处理代码。</p><p>实体组件系统作为实验包提供，目前支持Unity 2018.3及更高版本。重要的是要强调实体组件系统不是生产就绪的。<em>（译者注：ECS目前是预览版发布，其稳定性还不能应用于生产环境~）</em></p><h4 id="c-job-system">C# Job System</h4><p>新的C＃作业系统以安全简便的方式利用多个核心。简单，因为它旨在将此方法打开到用户脚本，并允许您编写安全，快速，有效的代码，同时提供保护，以防止多线程的一些陷阱，如竞争条件。</p><p>C＃作业系统是Unity 2018.1+中包含的内置模块。</p><p><a href="https://github.com/stella3d/job-system-cookbook" target="_blank" rel="noopener">可以在此处找到有关C＃作业系统的更多示例项目</a></p><h4 id="burst">Burst</h4><p>Burst是一种新的基于LLVM的数学感知后端编译器。它将C＃作业编译为高度优化的机器代码，利用您正在编译的平台的特定功能。</p><p>Burst是一个实验包，目前支持Unity 2018.3及更高版本。重要的是要强调Burst没有准备好生产。</p><p><a href="https://youtu.be/tGmnZdY5Y-E" target="_blank" rel="noopener">观看Joachim Ante在Unite Austin展示这些新系统</a></p><h4 id="样例">样例</h4><p>为了帮助您入门，我们提供了此示例存储库，用于学习如何大规模编写系统。</p><h5 id="hellocube">HelloCube</h5><p>这是一组展示Unity ECS架构绝对基础的项目：</p><ul><li><strong>ForEach</strong> - 创建一对旋转立方体。此示例演示了使用System和Components分离数据和行为。</li><li><strong>IJobForEach</strong> - 使用基于作业的系统构建在ForEach示例上。基于IJobForEach的系统是推荐的方法，可以利用可用的CPU内核。</li><li><strong>IJobChunk</strong> - 演示如何使用IJobChunk编写系统。IJobChunk是处理组件的推荐方法，用于比简单IJobForEach可以描述的更复杂的情况。</li><li><strong>SubScene</strong> - 演示如何在Unity编辑器中使用SubScenes创建和修改实体。</li><li><strong>SpawnFromMonoBehaviour</strong> - 演示如何基于Prefab GameObject从MonoBehaviour函数中生成多个实体。</li><li><strong>SpawnFromEntity</strong> - 演示如何使用系统中的生成作业在运行时生成多个实体。</li><li><strong>FluentQuery</strong> - 演示如何使用流畅查询来选择要更新的正确实体集。</li><li><strong>SpawnAndRemove</strong> - 演示产生和从世界中删除实体。</li></ul><h5 id="boids">Boids</h5><p>Boids示例提供了包含数千个实体的更复杂场景。Boids模拟水下场景，鲨鱼和学校包含数千条鱼。（它使用经典的Boids植绒算法来教育鱼类行为。）</p><h4 id="空白ecs项目安装指南">空白ECS项目安装指南</h4><ol><li>打开Unity编辑器（<code>2019.1.0f1</code>或更高版本）</li><li>创建一个新项目。</li><li>打开包管理器（菜单：<strong>Window</strong> &gt; <strong>Package Manager</strong>）。</li><li>单击窗口顶部的“ **高级”**按钮，然后启用“ **显示预览包”**选项。</li><li>将以下包添加到项目中：</li></ol><ul><li>Entities</li><li>Hybrid.Renderer</li></ul><p>将实体包添加到项目中还会添加以下包：</p><ul><li>Burst</li><li>Collections</li><li>Jobs</li><li>Mathematics</li></ul><p>**注意：**您可以使用<a href="https://unity3d.com/get-unity/download" target="_blank" rel="noopener">Unity Hub</a>在同一台计算机上安装多个版本的Unity。</p><h4 id="文档">文档</h4><p>寻找有关如何入门或具体问题的信息？访问我们的ECS和工作系统文档。</p><p><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/ECSSamples/Documentation/index.md" target="_blank" rel="noopener">转到ECS Samples文档</a></p><p><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/UnityPhysicsSamples/Documentation/samples.md" target="_blank" rel="noopener">转到Unity Physics Samples文档</a></p><p>（原文链接：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/README.md" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/README.md</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出自Unity官方的ECS项目示例，该项目的第一次Commit是在2018年3月20号，距离现在一年半的时间，这期间ECS本身的生态在快速发展，稳定性也是逐步提升，期待在2020年的Unity版本中作为正式组件发布。好了，下面进入正题~ 对该项目的README做简单翻译和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>组件</title>
    <link href="https://longshilin.com/blog/34778b46.html"/>
    <id>https://longshilin.com/blog/34778b46.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>组件是实体组件系统体系结构的三个主要元素之一。它们代表您的游戏或程序的数据。实体本质上是标识符，用于索引组件集合。系统提供行为。</p><a id="more"></a><p>具体地说，ECS中的组件是具有以下“标记接口”之一的结构：</p><p>IComponentData<br>ISharedComponentData<br>ISystemStateComponentData<br>ISharedSystemStateComponentData<br>EntityManager将实体上出现的组件的唯一组合组织到Archetypes中。它将具有相同原型的所有实体的组件一起存储在名为Chunks的内存块中。给定Chunk中的实体都具有相同的组件原型。</p><p>共享组件是一种特殊的数据组件，您可以使用它来根据共享组件中的特定值（除了它们的原型之外）细分实体。将共享组件添加到实体时，EntityManager将具有相同共享数据值的所有实体放入同一块中。共享组件允许您的系统一起处理类似的实体。例如，共享组件Rendering.RenderMesh是Hybrid.rendering包的一部分，它定义了几个字段，包括mesh，material，receiveShadows等。渲染时，最有效的是处理所有具有相同值的3D对象。由于这些属性是在共享组件中指定的，因此EntityManager将匹配的实体放在内存中，以便呈现系统可以有效地迭代它们。</p><p>注意：过度使用共享组件会导致较差的块利用率，因为它涉及基于原型和每个共享组件字段的每个唯一值组合扩展所需的内存块数。避免向共享组件添加不必要的字段，使用Entity Debugger查看当前的Chunk利用率。</p><p>如果从实体添加或删除组件，或更改SharedComponent的值，EntityManager会将实体移动到其他Chunk，必要时创建新Chunk。</p><p>系统状态组件的行为类似于普通组件或共享组件，但在销毁实体时，EntityManager不会删除任何系统状态组件，也不会在删除实体ID之前回收它们。这种行为差异允许系统在销毁实体时清理其内部状态或释放资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件是实体组件系统体系结构的三个主要元素之一。它们代表您的游戏或程序的数据。实体本质上是标识符，用于索引组件集合。系统提供行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/categories/Unity/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/tags/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>什么是ECS？</title>
    <link href="https://longshilin.com/blog/1bcc4240.html"/>
    <id>https://longshilin.com/blog/1bcc4240.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="https://longshilin.com/images/20190811211342.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;https://longshilin.com/images/20190811211342.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>HelloCube</title>
    <link href="https://longshilin.com/blog/8282d3d8.html"/>
    <id>https://longshilin.com/blog/8282d3d8.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>此示例演示了一个简单的ECS系统，它可以旋转一对立方体。</p><a id="more"></a><h4 id="它显示了什么？">它显示了什么？</h4><p>此示例演示了ECS中数据和功能的分离。<br>数据存储在组件中，如下RadiansPerSecond属性存储在RotationSpeed_ForEach组件中， 该结构体数据组件有[Serializable]修饰符，表示实例化属性。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line"> [<span class="meta">Serializable</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">struct</span> RotationSpeed_ForEach : IComponentData</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">float</span> RadiansPerSecond;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而功能则写入系统，如下<strong>RotationSpeedSystem_ForEach</strong> 使用存储在 <strong>RotationSpeed_ForEach</strong> 组件中的<em>data</em>更新对象的旋转。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This system updates all entities in the scene with both a RotationSpeed_ForEach and Rotation component.</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedSystem_ForEach</span> : <span class="title">ComponentSystem</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="comment">// Entities.ForEach processes each set of ComponentData on the main thread. This is not the recommended</span></span><br><span class="line">         <span class="comment">// method for best performance. However, we start with it here to demonstrate the clearer separation</span></span><br><span class="line">         <span class="comment">// between ComponentSystem Update (logic) and ComponentData (data).</span></span><br><span class="line">         <span class="comment">// There is no update logic on the individual ComponentData.</span></span><br><span class="line">         Entities.ForEach((<span class="keyword">ref</span> RotationSpeed_ForEach rotationSpeed, <span class="keyword">ref</span> Rotation rotation) =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">var</span> deltaTime = Time.deltaTime;</span><br><span class="line">             rotation.Value = math.mul(math.normalize(rotation.Value),</span><br><span class="line">                 quaternion.AxisAngle(math.up(), rotationSpeed.RadiansPerSecond * deltaTime));</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="componentsystems和entities-foreach">ComponentSystems和Entities.ForEach</h4><p>RotationSpeedSystem_ForEach是一个ComponentSystem，它使用Entities.ForEach委托来遍历实体。<br>此示例仅创建单个实体，但如果向场景添加了更多实体，则RotationSpeedSystem_ForEach会更新所有实体 - 只要它们具有RotationSpeed_ForEach组件（并且在将GameObject的Transform转换为ECS组件时添加了旋转组件）。<br>请注意，使用Entities.ForEach的ComponentSystems在主线程上运行。<br>要利用多个内核，可以使用JobComponentSystem（如下一个HelloCube示例所示）。</p><h4 id="从gameobject转换为entity">从GameObject转换为Entity</h4><p><strong>ConvertToEntity</strong> MonoBehaviour在Awake时将GameObject及其子节点转换为实体和ECS组件。<br>目前，ConvertToEntity可以转换的内置Unity MonoBehaviours集包括Transform和MeshRenderer。<br>您可以使用<strong>实体调试器</strong>（菜单：<strong>窗口</strong>&gt; <strong>分析</strong>&gt; <strong>实体调试器</strong>）来检查转换创建的ECS实体和组件。<br>您可以在自己的MonoBehaviours上实现IConvertGameObjectEntity接口，以提供ConvertToEntity用于将存储在MonoBehavi中的数据转换为ECS组件的转换函数。<br>在此示例中， <strong>RotationSpeedAuthoring_ForEach</strong> MonoBehaviour使用IConvertGameObjectEntity在转换时将RotationSpeed_ForEach组件添加到实体。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"> <span class="keyword">using</span> Unity.Entities;</span><br><span class="line"> <span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"> <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"> [<span class="meta">RequiresEntityConversion</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedAuthoring_ForEach</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">float</span> DegreesPerSecond;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// The MonoBehaviour data is converted to ComponentData on the entity.</span></span><br><span class="line">​     <span class="comment">// We are specifically transforming from a good editor representation of the data (Represented in degrees)</span></span><br><span class="line">​     <span class="comment">// To a good runtime representation (Represented in radians)</span></span><br><span class="line">​     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function">​</span>     &#123;</span><br><span class="line">​         <span class="keyword">var</span> data = <span class="keyword">new</span> RotationSpeed_ForEach &#123; RadiansPerSecond = math.radians(DegreesPerSecond) &#125;;</span><br><span class="line">​         dstManager.AddComponentData(entity, data);</span><br><span class="line">​     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="hellocube-1b-foreachwithentitychanges">HelloCube_1b_ForEachWithEntityChanges</h3><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要更新的正确实体集。然后它在ForEach lambda函数内部修改这些实体。</p><p>该示例定义了两个标记组件，名为MovingCube_ForEachWithEntityChanges和MoveUp_ForEachWithEntityChanges。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> MoveUp_ForEachWithEntityChanges : IComponentData</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MoveUp is a "tag" component and contains no data. Tag components can be used to mark entities that a system should process.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> MovingCube_ForEachWithEntityChanges : IComponentData</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MovingCube_ForEachWithEntityChanges is a "tag" component and contains no data.</span></span><br><span class="line">        <span class="comment">// Tag components can be used to mark entities that a system should process.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>系统中的一个查询选择同时具有MoveUp_ForEachWithEntityChanges组件和Translation组件的所有实体。与此查询关联的ForEach lambda函数向上移动每个选定的实体，直到达到某个高度时，该函数将删除MoveUp_ForEachWithEntityChanges组件，以便下次系统更新时，将不会选择该实体，因此它不会向上移动任何更远的位置。</p><p>第二个查询选择具有Translation组件但没有MoveUp_ForEachWithEntityChanges组件的所有实体。与第二个查询关联的ForEach函数将实体向下移动到其起始位置，并添加新的MoveUp_ForEachWithEntityChanges组件。由于实体再次具有MoveUp_ForEachWithEntityChanges组件，因此下次系统更新时，实体将被第一个ForEach函数向上移动并被第二个查询跳过。</p><p>MovingCube_ForEachWithEntityChanges是一个标记组件，用于确保系统仅适用于为此示例标记的组件。示例中的两个查询都需要MovingCube_ForEachWithEntityChanges组件。</p><h4 id="它显示了什么？-v2">它显示了什么？</h4><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要向上移动的一组实体。当它们达到一定高度时，系统会删除一个组件并使用另一个查询在较低的高度重新生成它们。它还演示了使用“标签”组件来提供选择具有待处理标记组件的特定entite组的方法。最后，此示例演示了如何在ForEach lambda函数内修改实体。</p><h4 id="组件系统和实体-foreach">组件系统和实体.ForEach</h4><p>MovementSystem_ForEachWithEntityChanges是一个ComponentSystem，它使用Entities.ForEach lambda函数迭代实体。此示例使用WithAll和WithNone约束来选择要处理的特定实体集。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">using</span> Unity.Entities;</span><br><span class="line"> <span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"> <span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"> <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">// This system updates all entities in the scene with Translation components.</span></span><br><span class="line">     <span class="comment">// It treats entities differently depending on whether or not they also have a MoveUp component.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MovementSystem_ForEachWithEntityChanges</span> : <span class="title">ComponentSystem</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>         &#123;</span><br><span class="line">             <span class="comment">// If a MoveUp component is present, then the system updates the Translation component to move the entity upwards.</span></span><br><span class="line">             <span class="comment">// Once the entity reaches a predetermined height, the function removes the MoveUp component.</span></span><br><span class="line">             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges, MoveUp_ForEachWithEntityChanges&gt;().ForEach(</span><br><span class="line">                 (Entity id, <span class="keyword">ref</span> Translation translation) =&gt;</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">var</span> deltaTime = Time.deltaTime;</span><br><span class="line">                     translation = <span class="keyword">new</span> Translation()</span><br><span class="line">                     &#123;</span><br><span class="line">                         Value = <span class="keyword">new</span> float3(translation.Value.x, translation.Value.y + deltaTime, translation.Value.z)</span><br><span class="line">                     &#125;;</span><br><span class="line"></span><br><span class="line">​                    <span class="keyword">if</span> (translation.Value.y &gt; <span class="number">10.0f</span>)</span><br><span class="line">​                         EntityManager.RemoveComponent&lt;MoveUp_ForEachWithEntityChanges&gt;(id);</span><br><span class="line">​                 &#125;</span><br><span class="line">​             );</span><br><span class="line"></span><br><span class="line">​            <span class="comment">// If an entity does not have a MoveUp component (but does have a Translation component),</span></span><br><span class="line">​             <span class="comment">// then the system moves the entity down to its starting point and adds a MoveUp component.</span></span><br><span class="line">​             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges&gt;().WithNone&lt;MoveUp_ForEachWithEntityChanges&gt;().ForEach(</span><br><span class="line">​                 (Entity id, <span class="keyword">ref</span> Translation translation) =&gt;</span><br><span class="line">​                 &#123;</span><br><span class="line">​                     translation = <span class="keyword">new</span> Translation()</span><br><span class="line">​                     &#123;</span><br><span class="line">​                         Value = <span class="keyword">new</span> float3(translation.Value.x, <span class="number">-10.0f</span>, translation.Value.z)</span><br><span class="line">​                     &#125;;</span><br><span class="line"></span><br><span class="line">​                    EntityManager.AddComponentData(id, <span class="keyword">new</span> MoveUp_ForEachWithEntityChanges());</span><br><span class="line">​                 &#125;</span><br><span class="line">​             );</span><br><span class="line">​         &#125;</span><br><span class="line">​     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意：使用Entities.ForEach的组件系统在主线程上运行。要利用多个内核，可以使用JobComponentSystem（如其他HelloCube示例所示）。这也允许更改ForEach lambda函数内的实体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此示例演示了一个简单的ECS系统，它可以旋转一对立方体。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/tags/ECS-Samples/"/>
    
  </entry>
  
  <entry>
    <title>实体组件系统</title>
    <link href="https://longshilin.com/blog/68fc35ba.html"/>
    <id>https://longshilin.com/blog/68fc35ba.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>栏目概述</strong></p><a id="more"></a><ul><li>Core ECS<ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_entities.html" target="_blank" rel="noopener">Entities</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/world.html" target="_blank" rel="noopener">Worlds</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">Components</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_data.html" target="_blank" rel="noopener">General Purpose Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/shared_component_data.html" target="_blank" rel="noopener">Shared Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/system_state_components.html" target="_blank" rel="noopener">System State Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/dynamic_buffers.html" target="_blank" rel="noopener">Dynamic Buffer Components</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">System</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_system.html" target="_blank" rel="noopener">Component Systems</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/job_component_system.html" target="_blank" rel="noopener">Job Component Systems</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_command_buffer.html" target="_blank" rel="noopener">Entity Command Buffers</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/system_update_order.html" target="_blank" rel="noopener">System Update Order</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html" target="_blank" rel="noopener">Accessing Entity Data</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_iteration_job.html" target="_blank" rel="noopener">Using IJobForEach</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration_job.html" target="_blank" rel="noopener">Using IJobChunk</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_iteration_foreach.html" target="_blank" rel="noopener">Using ComponentSystem and ForEach</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/manual_iteration.html" target="_blank" rel="noopener">Manual iteration</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_group.html" target="_blank" rel="noopener">Component Groups</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_write_groups.html" target="_blank" rel="noopener">Component WriteGroups</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/version_numbers.html" target="_blank" rel="noopener">Versions and Generations</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_job_overview.html" target="_blank" rel="noopener">Jobs in ECS</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_job_extensions.html" target="_blank" rel="noopener">ECS Job System extensions</a></li></ul></li></ul></li><li>Creating Gameplay<ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/transform_system.html" target="_blank" rel="noopener">Transforms</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/gp_rendering.html" target="_blank" rel="noopener">Rendering</a></li></ul></li></ul><p>实体组件系统（ECS）是Unity数据导向技术堆栈的核心。顾名思义，ECS有三个主要部分：</p><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_entities.html" target="_blank" rel="noopener">实体</a> - 填充您的游戏或程序的实体或事物</li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a> - 与您的实体关联的数据，但由数据本身而不是按实体组织。（这种组织差异是面向对象和面向数据的设计之间的关键差异之一。）</li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">系统</a> - 将组件数据从其当前状态转换到其下一状态的逻辑 - 例如，系统可以通过其速度乘以自前一帧以来的时间间隔来更新所有移动实体的位置。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;栏目概述&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/categories/Unity/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/tags/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>ECS适合你吗？</title>
    <link href="https://longshilin.com/blog/43b8c1c3.html"/>
    <id>https://longshilin.com/blog/43b8c1c3.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>实体组件系统处于预览状态。不建议用于生产。</p><p>目前有两个很好的理由使用它。</p><a id="more"></a><h5 id="你想试验">你想试验</h5><p>这是令人兴奋的新技术，并且大规模性能提升的承诺正在引诱。试试看。给我们您的反馈。我们很乐意在论坛上与您交谈。</p><h5 id="您正在尝试构建一个在没有实体组件系统的情况下无法完成的游戏">您正在尝试构建一个在没有实体组件系统的情况下无法完成的游戏</h5><p>我们很想知道您的游戏。请随时在论坛上发布您正在尝试实现的内容以及您认为实体组件系统为您提供的无法实现的内容。</p><h4 id="尝试实体组件系统">尝试实体组件系统</h4><p>您已经听说过ECS不仅可以提高性能，还可以帮助您编写更清晰，更清晰，更易于维护的代码。你想看看它在实践中是如何运作的。这是一个有趣的场景，因为您可以从头开始编写简单的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实体组件系统处于预览状态。不建议用于生产。&lt;/p&gt;
&lt;p&gt;目前有两个很好的理由使用它。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>C＃作业系统中的安全系统</title>
    <link href="https://longshilin.com/blog/70ae4a2e.html"/>
    <id>https://longshilin.com/blog/70ae4a2e.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="比赛条件">比赛条件</h4><p>编写<a href="https://docs.unity3d.com/Manual/JobSystemMultithreading.html" target="_blank" rel="noopener">多线程代码时</a>，总是存在<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞争条件</a>的风险。当一个操作的输出取决于其控制之外的另一个过程的定时时，发生竞争条件。</p><p>竞争条件并不总是一个错误，但它是不确定行为的来源。当竞争条件确实导致错误时，可能很难找到问题的根源，因为它取决于时间，因此您只能在极少数情况下重新创建问题。调试它可能会导致问题消失，因为断点和日志记录可以改变单个线程的时间。竞争条件是编写多线程代码时最重大的挑战。</p><a id="more"></a><h4 id="安全系统">安全系统</h4><p>为了更容易编写多线程代码，Unity C＃作业系统可以检测所有潜在的竞争条件，并保护您免受可能导致的错误的影响。</p><p>例如：如果C＃作业系统将主线程中代码中的数据<a href="https://docs.microsoft.com/en-us/cpp/cpp/references-cpp" target="_blank" rel="noopener">引用</a>发送到作业，则无法验证主线程是否在作业写入数据的同时读取数据。此方案会创建竞争条件。</p><p>C＃作业系统通过向每个作业发送它需要操作的数据的副本来解决这个问题，而不是对主线程中的数据的引用。此副本隔离数据，从而消除竞争条件。</p><p>C＃作业系统复制数据的方式意味着作业只能访问<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable数据类型</a>。在<a href="https://en.wikipedia.org/wiki/Managed_code" target="_blank" rel="noopener">托管</a>代码和本机代码之间传递时，这些类型不需要转换。</p><p>C＃Job System可以使用<a href="http://www.cplusplus.com/reference/cstring/memcpy/" target="_blank" rel="noopener">memcpy</a>复制blittable类型，并在Unity的托管和本机部分之间传输数据。它用于<code>memcpy</code>在调度作业时将数据放入本机内存，并在执行作业时为受管方提供对该副本的访问权限。有关更多信息，请参阅<a href="https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html" target="_blank" rel="noopener">计划作业</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;比赛条件&quot;&gt;比赛条件&lt;/h4&gt;
&lt;p&gt;编写&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemMultithreading.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程代码时&lt;/a&gt;，总是存在&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;竞争条件&lt;/a&gt;的风险。当一个操作的输出取决于其控制之外的另一个过程的定时时，发生竞争条件。&lt;/p&gt;
&lt;p&gt;竞争条件并不总是一个错误，但它是不确定行为的来源。当竞争条件确实导致错误时，可能很难找到问题的根源，因为它取决于时间，因此您只能在极少数情况下重新创建问题。调试它可能会导致问题消失，因为断点和日志记录可以改变单个线程的时间。竞争条件是编写多线程代码时最重大的挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>C＃作业系统提示和故障排除</title>
    <link href="https://longshilin.com/blog/feab267f.html"/>
    <id>https://longshilin.com/blog/feab267f.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Unity C＃作业系统时，请确保遵守以下内容：</p><h4 id="不要从作业访问静态数据">不要从作业访问静态数据</h4><p>从作业访问静态数据会绕过所有安全系统。如果您访问错误的数据，您可能会以意想不到的方式崩溃Unity。例如，访问<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank" rel="noopener">MonoBehaviour</a>可能会导致域重新加载崩溃。</p><p><strong>注意</strong>：由于存在这种风险，Unity的未来版本将阻止使用<a href="https://www.youtube.com/watch?v=VxeC7WFfg3Q" target="_blank" rel="noopener">静态分析</a>从作业进行全局变量访问。如果您确实访问作业中的静态数据，则应该期望您的代码在Unity的未来版本中中断。</p><a id="more"></a><h4 id="刷新预定批次">刷新预定批次</h4><p>如果希望作业开始执行，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html" target="_blank" rel="noopener">JobHandle.ScheduleBatchedJobs</a>刷新计划批处理。请注意，调用此方法会对性能产生负面影响。不刷新批处理会延迟调度，直到主线程等待结果。在所有其他情况下，使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.Complete.html" target="_blank" rel="noopener">JobHandle.Complete</a>来启动执行过程。</p><p><strong>注意</strong>：在<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">实体组件系统</a>（ECS）中，将为您隐式刷新批处理，因此<code>JobHandle.ScheduleBatchedJobs</code>不需要调用。</p><h4 id="不要尝试更新nativecontainer内容">不要尝试更新NativeContainer内容</h4><p>由于缺少<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns" target="_blank" rel="noopener">ref返回</a>，因此无法直接更改<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>的内容。例如，<code>nativeArray[0]++;</code>与<code>var temp = nativeArray[0]; temp++;</code>不更新值的<code>nativeArray</code>写入相同。</p><p>相反，您必须将索引中的数据复制到本地临时副本，修改该副本并将其保存回来，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyStruct temp = myNativeArray[i];</span><br><span class="line">temp.memberVariable = 0;</span><br><span class="line">myNativeArray[i] = temp;</span><br></pre></td></tr></table></figure><h4 id="致电jobhandle-complete以重新获得所有权">致电JobHandle.Complete以重新获得所有权</h4><p>跟踪数据所有权需要在主线程再次使用它们之前完成依赖项。检查<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.IsCompleted.html" target="_blank" rel="noopener">JobHandle.IsCompleted</a>是不够的。您必须调用该方法<code>JobHandle.Complete</code>以重新获得<code>NativeContainer</code>主线程的类型的所有权。调用<code>Complete</code>还可以清除安全系统中的状态。不这样做会引入内存泄漏。如果您在每个帧中安排新作业，并且依赖于前一帧的作业，则此过程也适用。</p><h4 id="在主线程中使用schedule和complete">在主线程中使用Schedule和Complete</h4><p>你只能调用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>和<code>Complete</code>主线程。如果一个作业依赖于另一个作业，则使用<code>JobHandle</code>管理依赖关系而不是尝试在作业内安排作业。</p><h4 id="在合适的时间使用计划和完成">在合适的时间使用计划和完成</h4><p><code>Schedule</code>只要您拥有所需的数据就立即打电话给工作，并且<code>Complete</code>在您需要结果之前不要打电话给它。优秀的做法是安排一个您不需要等待的工作，而不是与正在运行的任何其他工作竞争。例如，如果在一帧结束和下一帧的开始之间没有作业正在运行，并且可以接受一帧延迟，则可以将作业调度到帧的末尾并使用其结果在以下框架中。或者，如果您的游戏与其他工作的转换期间相比，并且框架中的其他位置存在大量未充分利用的时间段，则更有效地安排您的工作。</p><h4 id="将nativecontainer类型标记为只读">将NativeContainer类型标记为只读</h4><p>请记住，作业<code>NativeContainer</code>默认情况下对类型具有读写访问权限。<code>[ReadOnly]</code>适当时使用该属性可提高性能。</p><h4 id="检查数据依赖性">检查数据依赖性</h4><p>在Unity Profiler 窗口，主线程上的标记“WaitForJobGroup”表示Unity正在等待工作线程上的作业完成。此标记可能意味着您已在某处应引入数据依赖关系。寻找<code>JobHandle.Complete</code>跟踪数据依赖关系的位置，这些数据依赖关系迫使主线程等待。</p><h4 id="调试作业">调试作业</h4><p>作业具有一个<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Run.html" target="_blank" rel="noopener">Run</a>函数，您可以使用它来代替<code>Schedule</code>在主线程上立即执行作业。您可以将其用于调试目的。</p><h4 id="不要在作业中分配托管内存">不要在作业中分配托管内存</h4><p>在作业中分配托管内存非常慢，并且该作业无法使用Unity <a href="https://www.youtube.com/watch?v=NF6kcNS6U80&amp;t=2s" target="_blank" rel="noopener">Burst编译器</a>来提高性能。Burst是一种新的基于<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM</a>的后端编译器技术，可以让您更轻松。它需要C＃作业并利用您平台的特定功能生成高度优化的机器代码。</p><h4 id="更多的信息">更多的信息</h4><ul><li>观看<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">Unity GDC 2018：</a>剪辑的<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">C＃作业系统</a>播放列表。</li><li>有关C＃作业系统如何与ECS相关的更多高级信息，请参阅<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">GitHub上</a>的<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">ECS包文档</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Unity C＃作业系统时，请确保遵守以下内容：&lt;/p&gt;
&lt;h4 id=&quot;不要从作业访问静态数据&quot;&gt;不要从作业访问静态数据&lt;/h4&gt;
&lt;p&gt;从作业访问静态数据会绕过所有安全系统。如果您访问错误的数据，您可能会以意想不到的方式崩溃Unity。例如，访问&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MonoBehaviour.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MonoBehaviour&lt;/a&gt;可能会导致域重新加载崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于存在这种风险，Unity的未来版本将阻止使用&lt;a href=&quot;https://www.youtube.com/watch?v=VxeC7WFfg3Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;静态分析&lt;/a&gt;从作业进行全局变量访问。如果您确实访问作业中的静态数据，则应该期望您的代码在Unity的未来版本中中断。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>JobHandle和依赖项</title>
    <link href="https://longshilin.com/blog/9bdee974.html"/>
    <id>https://longshilin.com/blog/9bdee974.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要当您调用作业的schedule方法时-它将返回jobhandle-您可以在代码中使用一个jobhandle作为其他作业的依赖项-如果作业取决于另一个作业的结果-您可以将第一个作业jobhandle作为参数传递给第二个作业的schedule方法-如下所示：">要当您调用作业的<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>方法时，它将返回<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html" target="_blank" rel="noopener">JobHandle</a>。您可以在代码中使用一个<code>JobHandle</code>作为其他作业的依赖项。如果作业取决于另一个作业的结果，您可以将第一个作业<code>JobHandle</code>作为参数传递给第二个作业的<code>Schedule</code>方法，如下所示：</h4><a id="more"></a><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">JobHandle firstJobHandle = firstJob.Schedule();</span><br><span class="line">secondJob.Schedule(firstJobHandle);</span><br></pre></td></tr></table></figure><h4 id="结合依赖关系">结合依赖关系</h4><p>如果作业具有许多依赖项，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.CombineDependencies.html" target="_blank" rel="noopener">JobHandle.CombineDependencies</a>方法合并它们。<code>CombineDependencies</code>允许您将它们传递给<code>Schedule</code>方法。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;JobHandle&gt; handles = <span class="keyword">new</span> NativeArray&lt;JobHandle&gt;(numJobs, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Populate `handles` with `JobHandles` from multiple scheduled jobs...</span></span><br><span class="line"></span><br><span class="line">JobHandle jh = JobHandle.CombineDependencies(handles);</span><br></pre></td></tr></table></figure><h4 id="在主线程中等待工作">在主线程中等待工作</h4><p>使用<code>JobHandle</code>强迫你的代码在主线程等待您的工作执行完毕。要做到这一点，调用<code>JobHandle的Complete方法</code>。此时，您知道主线程可以安全地访问作业正在使用的<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>。</p><p><strong>注意</strong>：在计划作业时，作业不会开始执行。如果您正在等待主线程中的作业，并且您需要访问作业正在使用的NativeContainer数据，则可以调用该方法<code>JobHandle.Complete</code>。此方法从内存高速缓存中刷新作业并启动执行过程。在`JobHandle<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">否则，如果您不需要访问数据，则需要明确刷新批处理。为此，请调用静态方法[JobHandle.ScheduleBatchedJobs](https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html)。请注意，调用此方法会对性能产生负面影响。</span><br><span class="line"></span><br><span class="line">#### 多个作业和依赖项的示例</span><br><span class="line"></span><br><span class="line">**工作代码**：</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line">// Job adding two floating point values together</span><br><span class="line">public struct MyJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public float a;</span><br><span class="line">    public float b;</span><br><span class="line">    public NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Job adding one to a value</span><br><span class="line">public struct AddOneJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] = result[0] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>主线程代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a native array of a single float to store the result in. This example waits for the job to complete</span></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the data for job #1</span></span><br><span class="line">MyJob jobData = <span class="keyword">new</span> MyJob();</span><br><span class="line">jobData.a = <span class="number">10</span>;</span><br><span class="line">jobData.b = <span class="number">10</span>;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule job #1</span></span><br><span class="line">JobHandle firstHandle = jobData.Schedule();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the data for job #2</span></span><br><span class="line">AddOneJob incJobData = <span class="keyword">new</span> AddOneJob();</span><br><span class="line">incJobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule job #2</span></span><br><span class="line">JobHandle secondHandle = incJobData.Schedule(firstHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for job #2 to complete</span></span><br><span class="line">secondHandle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// All copies of the NativeArray point to the same memory, you can access the result in "your" copy of the NativeArray</span></span><br><span class="line"><span class="keyword">float</span> aPlusB = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the memory allocated by the result array</span></span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要当您调用作业的schedule方法时-它将返回jobhandle-您可以在代码中使用一个jobhandle作为其他作业的依赖项-如果作业取决于另一个作业的结果-您可以将第一个作业jobhandle作为参数传递给第二个作业的schedule方法-如下所示：&quot;&gt;要当您调用作业的&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Schedule&lt;/a&gt;方法时，它将返回&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JobHandle&lt;/a&gt;。您可以在代码中使用一个&lt;code&gt;JobHandle&lt;/code&gt;作为其他作业的依赖项。如果作业取决于另一个作业的结果，您可以将第一个作业&lt;code&gt;JobHandle&lt;/code&gt;作为参数传递给第二个作业的&lt;code&gt;Schedule&lt;/code&gt;方法，如下所示：&lt;/h4&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>NativeContainer</title>
    <link href="https://longshilin.com/blog/ac3c63a9.html"/>
    <id>https://longshilin.com/blog/ac3c63a9.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.unity3d.com/Manual/JobSystemSafetySystem.html" target="_blank" rel="noopener">安全系统</a>复制数据<a href="https://docs.unity3d.com/Manual/JobSystemSafetySystem.html" target="_blank" rel="noopener">的</a>过程的缺点是它还隔离了每个副本中作业的结果。要克服此限制，您需要将结果存储在一种名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>的共享内存中。</p><a id="more"></a><h2 id="什么是nativecontainer？">什么是NativeContainer？</h2><p>A <code>NativeContainer</code>是托管值类型，为本机内存提供相对安全的C＃包装器。它包含指向非托管分配的指针。与Unity C＃作业系统一起使用时，a <code>NativeContainer</code>允许作业访问与主线程共享的数据，而不是使用副本。</p><h2 id="有哪些类型的nativecontainer？">有哪些类型的NativeContainer？</h2><p>Unity附带一个<code>NativeContainer</code>名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html" target="_blank" rel="noopener">NativeArray的程序</a>。您还可以<code>NativeArray</code>使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeSlice_1.html" target="_blank" rel="noopener">NativeSlice</a>操作a 以获取<code>NativeArray</code>从特定位置到特定长度的子集。</p><p>注意：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">实体组件系统</a>（ECS）包扩展了<code>Unity.Collections</code>命名空间以包括其他类型<code>NativeContainer</code>：</p><ul><li><code>NativeList</code>- 可调整大小<code>NativeArray</code>。</li><li><code>NativeHashMap</code> - 键和值对。</li><li><code>NativeMultiHashMap</code> - 每个键有多个值。</li><li><code>NativeQueue</code>- <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener">先进先出</a>（<a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener">FIFO</a>）队列。</li></ul><h2 id="nativecontainer和安全系统">NativeContainer和安全系统</h2><p>安全系统内置于所有<code>NativeContainer</code>类型。它跟踪什么是读写任何内容<code>NativeContainer</code>。</p><p>注意：所有<code>NativeContainer</code>类型的安全检查（例如越界检查，重新分配检查和竞争条件检查）仅在Unity 编辑器和播放模式下可用。</p><p>该安全系统的一部分是<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.DisposeSentinel.html" target="_blank" rel="noopener">DisposeSentinel</a>和<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle.html" target="_blank" rel="noopener">AtomicSafetyHandle</a>。该<code>DisposeSentinel</code>检测内存泄漏，给你一个错误，如果你没有正确地释放你的记忆。泄漏发生后很久就会发生内存泄漏错误。</p><p>使用<code>AtomicSafetyHandle</code>转移<code>NativeContainer</code>代码的所有权。例如，如果两个预定作业写入相同<code>NativeArray</code>，则安全系统会抛出异常，并显示明确的错误消息，说明解决问题的原因和方法。安排违规工作时，安全系统会抛出此异常。</p><p>在这种情况下，您可以安排具有依赖关系的作业。第一个作业可以写入<code>NativeContainer</code>，一旦完成执行，下一个作业就可以安全地读取和写入相同的作业<code>NativeContainer</code>。从主线程访问数据时，读写限制也适用。安全系统允许多个作业并行读取相同的数据。</p><p>默认情况下，当作业有权访问a时<code>NativeContainer</code>，它具有读写访问权限。此配置可能会降低性能。C＃作业系统不允许您计划与写入其中的<code>NativeContainer</code>另一个作业同时具有写访问权限的作业。</p><p>如果作业不需要写入a <code>NativeContainer</code>，请<code>NativeContainer</code>使用<code>[ReadOnly]</code>属性标记，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ReadOnly]</span><br><span class="line">public NativeArray&lt;int&gt; input;</span><br></pre></td></tr></table></figure><p>在上面的示例中，您可以与其他对第一个也具有只读访问权限的作业同时执行作业<code>NativeArray</code>。</p><p>注意：无法防止从作业中访问静态数据。访问静态数据会绕过所有安全系统，并可能导致Unity崩溃。有关更多信息，请参阅<a href="https://docs.unity3d.com/Manual/JobSystemTroubleshooting.html" target="_blank" rel="noopener">C＃作业系统提示和故障排除</a>。</p><h2 id="nativecontainer分配器">NativeContainer分配器</h2><p>创建时<code>NativeContainer</code>，必须指定所需的内存分配类型。分配类型取决于作业运行的时间长度。通过这种方式，您可以定制分配以在每种情况下获得最佳性能。</p><p>内存分配和释放有三种<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html" target="_blank" rel="noopener">Allocator</a>类型<code>NativeContainer</code>。在实例化你的时候需要指定合适的一个<code>NativeContainer</code>。</p><ul><li>Allocator.Temp分配最快。它适用于寿命为一帧或更少的分配。您不应将<code>NativeContainer</code>分配<code>Temp</code>用于作业。您还需要<code>Dispose</code>在从方法调用返回之前调用该方法（例如<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html" target="_blank" rel="noopener">MonoBehaviour.Update</a>，或从本机代码到托管代码的任何其他回调）。</li><li>Allocator.TempJob是一个比较慢的分配，<code>Temp</code>但速度比<code>Persistent</code>。它适用于四帧生命周期内的分配，并且是线程安全的。如果<code>Dispose</code>在四帧内没有，则控制台会打印一条警告，该警告是从本机代码生成的。大多数小型工作都使用此<code>NativeContainer</code>分配类型。</li><li>Allocator.Persistent是最慢的分配，但只要你需要它，并且如果有必要，可以持续整个应用程序的生命周期。它是直接调用<a href="http://www.cplusplus.com/reference/cstdlib/malloc/" target="_blank" rel="noopener">malloc</a>的包装器。较长的作业可以使用此<code>NativeContainer</code>分配类型。你不应该使用<code>Persistent</code>性能至关重要的地方。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;float&gt; result = new NativeArray&lt;float&gt;(1, Allocator.TempJob);</span><br></pre></td></tr></table></figure><p>注意：上例中的数字1表示的大小<code>NativeArray</code>。在这种情况下，它只有一个数组元素（因为它只存储一个数据<code>result</code>）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemSafetySystem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全系统&lt;/a&gt;复制数据&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemSafetySystem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;的&lt;/a&gt;过程的缺点是它还隔离了每个副本中作业的结果。要克服此限制，您需要将结果存储在一种名为&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NativeContainer&lt;/a&gt;的共享内存中。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>ParallelForTransform作业</title>
    <link href="https://longshilin.com/blog/894c6889.html"/>
    <id>https://longshilin.com/blog/894c6889.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>ParallelForTransform作业是另一种<a href="https://docs.unity3d.com/Manual/JobSystemParallelForJobs.html" target="_blank" rel="noopener">ParallelFor作业</a> ; 专为在<a href="https://docs.unity3d.com/Manual/Transforms.html" target="_blank" rel="noopener">变形上</a>操作而设计。</p><p><strong>注意</strong>：ParallelForTransform作业是Unity中用于实现<a href="https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransform.html" target="_blank" rel="noopener">IJobParallelForTransform</a>接口的任何作业的集合术语。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ParallelForTransform作业是另一种&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemParallelForJobs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ParallelFor作业&lt;/a&gt; ; 专为在&lt;a href=&quot;https://docs.unity3d.com/Manual/Transforms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;变形上&lt;/a&gt;操作而设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：ParallelForTransform作业是Unity中用于实现&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransform.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IJobParallelForTransform&lt;/a&gt;接口的任何作业的集合术语。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>C# Job System 概述</title>
    <link href="https://longshilin.com/blog/c28c374b.html"/>
    <id>https://longshilin.com/blog/c28c374b.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-作业系统是如何工作">C# 作业系统是如何工作</h3><ul><li>允许用户编写与Unity其余部分良好交互的<a href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)" target="_blank" rel="noopener">多线程代码</a>，并使编写正确的代码变得更加容易。</li><li>编写多线程代码可以提供高性能的好处，其中包括<strong>帧速率的显著提高</strong>、以及将Burst编译器与C#作业一起使用<strong>可以提高代码生成质量</strong>，<strong>从而大大降低移动设备的电池消耗。</strong></li><li>一个重要方面是它与Unity内部使用的集成（Unity的本地作业系统）。用户编写的diamante和Unity共享<a href="https://docs.microsoft.com/zh-cn/cpp/parallel/multithreading-creating-worker-threads?view=vs-2019" target="_blank" rel="noopener">工作线程</a>，这种合作避免了创建比CPU核心更多的线程，从而降低对CPU资源的争用。</li></ul><a id="more"></a><p>相关资料整理：</p><ul><li>官方文档：<a href="https://docs.unity3d.com/Manual/JobSystem.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/JobSystem.html</a></li><li>官方示例：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md</a></li><li>官方视频：<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;c-作业系统是如何工作&quot;&gt;C# 作业系统是如何工作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;允许用户编写与Unity其余部分良好交互的&lt;a href=&quot;https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程代码&lt;/a&gt;，并使编写正确的代码变得更加容易。&lt;/li&gt;
&lt;li&gt;编写多线程代码可以提供高性能的好处，其中包括&lt;strong&gt;帧速率的显著提高&lt;/strong&gt;、以及将Burst编译器与C#作业一起使用&lt;strong&gt;可以提高代码生成质量&lt;/strong&gt;，&lt;strong&gt;从而大大降低移动设备的电池消耗。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个重要方面是它与Unity内部使用的集成（Unity的本地作业系统）。用户编写的diamante和Unity共享&lt;a href=&quot;https://docs.microsoft.com/zh-cn/cpp/parallel/multithreading-creating-worker-threads?view=vs-2019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工作线程&lt;/a&gt;，这种合作避免了创建比CPU核心更多的线程，从而降低对CPU资源的争用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>DOTS默认情况下的性能</title>
    <link href="https://longshilin.com/blog/9c7fc9b9.html"/>
    <id>https://longshilin.com/blog/9c7fc9b9.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用Unity全新的高性能多线程数据导向技术堆栈（DOTS），充分利用当今的多核处理器。您的游戏运行速度更快，您的代码更易于在其他项目中阅读和重用。</p><a id="more"></a><h4 id="重建unity的核心">重建Unity的核心</h4><p>我们正在使用高性能多线程数据导向技术堆栈重建Unity的核心基础。DOTS使您的游戏可以充分利用最新的多核处理器，而不会遇到繁重的编程问题。DOTS包括以下功能：</p><ul><li>用于高效运行多线程代码<strong>的C＃作业系统</strong>。</li><li>用于编写高性能代码<strong>的实体组件系统（ECS）</strong>。</li><li><strong>Burst Compiler</strong>用于生成高度优化的本机代码。</li></ul><p>这些DOTS功能为程序员提供了方便的沙箱，可以编写具有巨大性能提升的多线程代码。DOTS目前在预览中可用。</p><p>DOTS的多线程系统使您能够创建在各种硬件上运行的游戏，通过更多元素和更复杂的模拟构建更丰富的游戏世界，甚至优化玩家移动设备上的热控制和电池寿命。通过从面向对象的设计转向面向数据的设计，您可以更轻松地重用代码，并让其他人理解和处理代码。</p><h5 id="c-作业系统">C＃作业系统</h5><p><em>新的C＃作业系统利用了当今计算机中的多核。它旨在将此方法打开到C＃用户脚本，并允许用户编写安全，快速，有效的代码，同时防止多线程的一些陷阱，如竞争条件。</em></p><h6 id="利用多个核心">利用多个核心</h6><p>C＃作业系统公开了Native C ++作业系统，允许C＃脚本与Unity内部组件一起工作。</p><h6 id="安全的环境">安全的环境</h6><p>提供对多线程的一些陷阱的保护，例如竞争条件。</p><h5 id="实体组件系统-ecs">实体组件系统（ECS）</h5><h6 id="更好的游戏设计方法">更好的游戏设计方法</h6><p>ECS是一种编写代码的方式，专注于您正在解决的实际问题：组成游戏的数据和行为。</p><p>除了出于设计原因更好地接近游戏编程之外，使用ECS使您处于利用Unity的C＃作业系统和Burst Compiler的理想位置，让您充分利用当今的多核处理器。</p><p>使用ECS，我们正在从面向对象转向数据导向设计，这意味着重用代码更容易，并且更容易让其他人掌握并做出贡献。</p><h5 id="突发编译器">突发编译器</h5><h6 id="优化的代码">优化的代码</h6><p>新的基于LLVM的后端编译器技术可以获取C＃作业并生成高度优化的机器代码。</p><h6 id="每个平台都是最好的">每个平台都是最好的</h6><p>针对您正在编译的平台的特定功能进行了优化。</p><h6 id="减少手工编码">减少手工编码</h6><p>在多个平台上获得手动调整的汇编程序代码的许多优点，而无需付出艰苦的努力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用Unity全新的高性能多线程数据导向技术堆栈（DOTS），充分利用当今的多核处理器。您的游戏运行速度更快，您的代码更易于在其他项目中阅读和重用。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="DOTS" scheme="https://longshilin.com/blog/categories/Unity/DOTS/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>什么是工作制度？</title>
    <link href="https://longshilin.com/blog/2b778a74.html"/>
    <id>https://longshilin.com/blog/2b778a74.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>作业系统通过创建<a href="https://en.wikipedia.org/wiki/Job_(computing)" target="_blank" rel="noopener">作业</a>而不是线程来管理<a href="https://docs.unity3d.com/Manual/JobSystemMultithreading.html" target="_blank" rel="noopener">多线程代码</a>。</p><p>作业系统跨多个核心管理一组<a href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-creating-worker-threads" target="_blank" rel="noopener">工作线程</a>。它通常每个<a href="https://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/" target="_blank" rel="noopener">逻辑CPU核心</a>有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。</p><a id="more"></a><p>作业系统将作业放入<a href="https://en.wikipedia.org/wiki/Job_queue" target="_blank" rel="noopener">作业队列中</a>以执行。作业系统中的工作线程从作业队列中获取项目并执行它们。作业系统管理<a href="http://tutorials.jenkov.com/ood/understanding-dependencies.html" target="_blank" rel="noopener">依赖关系</a>并确保作业以适当的顺序执行。</p><h4 id="什么是工作？">什么是工作？</h4><p>工作是完成一项特定任务的一小部分工作。作业接收参数并对数据进行操作，类似于方法调用的行为方式。作业可以是自包含的，也可以依赖其他作业在运行之前完成。</p><h4 id="什么是工作依赖？">什么是工作依赖？</h4><p>在复杂的系统中，如游戏开发所需的系统，每个作业都不可能是独立的。一项工作通常是为下一份工作准备数据。工作人员知道并支持依赖关系以使其工作。如果<code>jobA</code>具有依赖性<code>jobB</code>，则作业系统确保在完成<code>jobA</code>之前不会开始执行<code>jobB</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作业系统通过创建&lt;a href=&quot;https://en.wikipedia.org/wiki/Job_(computing)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作业&lt;/a&gt;而不是线程来管理&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemMultithreading.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程代码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;作业系统跨多个核心管理一组&lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/parallel/multithreading-creating-worker-threads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;工作线程&lt;/a&gt;。它通常每个&lt;a href=&quot;https://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;逻辑CPU核心&lt;/a&gt;有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>创建作业</title>
    <link href="https://longshilin.com/blog/208be653.html"/>
    <id>https://longshilin.com/blog/208be653.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>要在Unity中创建作业，您需要实现<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.html" target="_blank" rel="noopener">IJob</a>接口。<code>IJob</code>允许您安排与正在运行的任何其他作业并行运行的单个作业。</p><p>注意：“作业”是Unity中用于实现<code>IJob</code>接口的任何结构的集合术语。</p><a id="more"></a><p>要创建工作，您需要：</p><ul><li>创建一个实现的结构<code>IJob</code>。</li><li>添加作业使用的成员变量（<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable类型</a>或<a href="https://docs.unity3d.com/Manual/JobSystemNativeContainer.html" target="_blank" rel="noopener">NativeContainer</a>类型）。</li><li>在结构中创建一个名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.Execute.html" target="_blank" rel="noopener">Execute</a>的方法，并在其中实现作业。</li></ul><p>执行作业时，该<code>Execute</code>方法在单个核心上运行一次。</p><p>注意：在设计作业时，请记住它们对数据副本进行操作，除非是<code>NativeContainer</code>。因此，从主线程中的作业访问数据的唯一方法是写入<code>NativeContainer</code>。</p><h2 id="简单作业定义的一个示例">简单作业定义的一个示例</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Job adding two floating point values together</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        result[<span class="number">0</span>] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要在Unity中创建作业，您需要实现&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IJob&lt;/a&gt;接口。&lt;code&gt;IJob&lt;/code&gt;允许您安排与正在运行的任何其他作业并行运行的单个作业。&lt;/p&gt;
&lt;p&gt;注意：“作业”是Unity中用于实现&lt;code&gt;IJob&lt;/code&gt;接口的任何结构的集合术语。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>安排工作</title>
    <link href="https://longshilin.com/blog/fdd0c96a.html"/>
    <id>https://longshilin.com/blog/fdd0c96a.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>要在主线程中安排作业，您必须：</p><ul><li>实例化作业。</li><li>填充作业的数据。</li><li>调用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>方法。</li></ul><p>调用<code>Schedule</code>将作业放入作业队列以便在适当的时间执行。一旦安排，你就不能打断工作。</p><a id="more"></a><p><strong>注意</strong>：您只能<code>Schedule</code>从主线程调用。</p><h4 id="安排工作的一个例子">安排工作的一个例子</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a native array of a single float to store the result. This example waits for the job to complete for illustration purposes</span></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the job data</span></span><br><span class="line">MyJob jobData = <span class="keyword">new</span> MyJob();</span><br><span class="line">jobData.a = <span class="number">10</span>;</span><br><span class="line">jobData.b = <span class="number">10</span>;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule the job</span></span><br><span class="line">JobHandle handle = jobData.Schedule();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the job to complete</span></span><br><span class="line">handle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// All copies of the NativeArray point to the same memory, you can access the result in "your" copy of the NativeArray</span></span><br><span class="line"><span class="keyword">float</span> aPlusB = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the memory allocated by the result array</span></span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要在主线程中安排作业，您必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例化作业。&lt;/li&gt;
&lt;li&gt;填充作业的数据。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Schedule&lt;/a&gt;方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用&lt;code&gt;Schedule&lt;/code&gt;将作业放入作业队列以便在适当的时间执行。一旦安排，你就不能打断工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>实体</title>
    <link href="https://longshilin.com/blog/f345f685.html"/>
    <id>https://longshilin.com/blog/f345f685.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>实体是实体组件系统体系结构的三个主要元素之一。它们代表游戏或程序中的个人“事物”。一个实体既没有行为也没有数据; 相反，它识别哪些数据属于一起。<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">系统</a>提供行为，<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a>存储数据。</p><a id="more"></a><p>实体本质上是一个ID。您可以将其视为一个超级轻量级<a href="https://docs.unity3d.com/Manual/class-GameObject.html" target="_blank" rel="noopener">GameObject</a>，默认情况下甚至没有名称。实体ID是稳定的。它们是存储对另一个组件或实体的引用的唯一稳定方式。</p><p>一个<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html" target="_blank" rel="noopener">EntityManager</a>管理一个<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.World.html" target="_blank" rel="noopener">世界</a>中的所有实体。EntityManager维护实体列表并组织与实体关联的数据以获得最佳性能。</p><p>虽然实体没有类型，但实体组可以根据与它们相关联的数据组件的类型进行分类。在创建实体并向其添加组件时，EntityManager会跟踪现有实体上组件的唯一组合。这种独特的组合称为<em>原型</em>。在向实体添加组件时，EntityManager会创建<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityArchetype.html" target="_blank" rel="noopener">EntityArchetype</a>结构。您可以使用现有的EntityArchetypes来创建符合该原型的新实体。您还可以提前创建EntityArchetype并使用它来创建实体。</p><h4 id="创建实体">创建实体</h4><p>创建实体的最简单方法是使用Unity编辑器。您可以设置放置在场景中的游戏对象和要在运行时转换为实体的预制件。对于游戏或程序的更多动态部分，您可以创建在作业中创建多个实体的衍生系统。最后，您可以使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">EntityManager.CreateEntity</a>函数之一一次创建一个实体。</p><h5 id="使用entitymanager创建实体">使用EntityManager创建实体</h5><p>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">EntityManager.CreateEntity</a>函数之一来创建实体。实体在与EntityManager相同的World中创建。</p><p>您可以通过以下方式逐个创建实体：</p><ul><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.ComponentType.html" target="_blank" rel="noopener">ComponentType</a>对象数组创建包含组件的实体。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityArchetype.html" target="_blank" rel="noopener">EntityArchetype</a>创建包含组件的实体。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_" target="_blank" rel="noopener">Instantiate</a>复制现有实体（包括其当前数据）</li><li>创建一个没有组件的实体，然后向其中添加组件。（您可以立即添加组件，也可以添加其他组件。）</li></ul><p>您也可以一次创建多个实体：</p><ul><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">CreateEntity</a>使用具有相同原型的新实体填充NativeArray 。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_" target="_blank" rel="noopener">Instantiate</a>向NativeArray填充现有实体的副本，包括其当前数据。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateChunk_" target="_blank" rel="noopener">CreateChunk</a>显式创建使用给定原型填充指定数量的实体的块。</li></ul><h4 id="添加和删除组件">添加和删除组件</h4><p>创建实体后，可以添加或删除组件执行此操作时，受影响实体的原型会发生变化，EntityManager必须将更改的数据移动到新的内存块，并在原始块中压缩组件数组。</p><p>导致结构更改的实体的更改（即添加或删除更改SharedComponentData的值的组件以及销毁实体）无法在Job内部完成，因为这些操作可能会使Job正在处理的数据无效。而是添加命令以对<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityCommandBuffer.html" target="_blank" rel="noopener">EntityCommandBuffer</a>进行这些类型的更改，并在Job完成后执行此命令缓冲区。</p><p>EntityManager提供了从单个实体以及NativeArray中的所有实体中删除组件的功能。有关更多信息，请参阅<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a></p><h4 id="迭代实体">迭代实体</h4><p>迭代具有匹配组件集的所有实体，是ECS体系结构的核心。请参阅<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html" target="_blank" rel="noopener">访问实体数据</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实体是实体组件系统体系结构的三个主要元素之一。它们代表游戏或程序中的个人“事物”。一个实体既没有行为也没有数据; 相反，它识别哪些数据属于一起。&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统&lt;/a&gt;提供行为，&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;组件&lt;/a&gt;存储数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/categories/Unity/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/tags/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>DOTS原则和愿景</title>
    <link href="https://longshilin.com/blog/5628dba2.html"/>
    <id>https://longshilin.com/blog/5628dba2.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-08-12T01:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity Data Oriented Tech Stack基于一系列原则。这些原则为我们正在努力实现的目标提供了良好的背景。一些原则清楚地反映在代码中。其他则只是我们为自己设定的目标。</p><a id="more"></a><h4 id="默认情况下的性能">默认情况下的性能</h4><p>我们希望为所有平台创建高效的机器代码变得简单。</p><p>我们使用手写的高度优化的<a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="noopener">simd</a>内在函数来衡量C ++中可以实现的性能。</p><p>我们使用编译器技术（Burst），容器（Unity.Collections），数据布局组件（ECS）的组合，以便在默认情况下轻松编写高效代码。</p><ul><li>数据布局和迭代 - 实体组件系统在默认情况下以块的形式迭代实体时保证线性数据布局。这是面向统一数据的技术栈提供性能提升的关键部分。</li><li>C＃作业系统允许您以简单的方式编写多线程代码。这也很安全。C＃Job Debugger可以检测任何竞争条件。</li><li>Burst是我们专门针对C＃作业的编译器。C＃作业代码遵循我们可用于生成更高效的机器代码的某些模式。使用SIMD指令为每个目标平台编译和优化代码。</li></ul><p>这方面的一个例子是Instantiation的性能。与实例化具有320字节memcpy的100,000个实体需要9ms的理论限制相比，通过实体组件系统实例化这些实体需要10ms。所以我们非常接近理论极限。</p><p>在Unite Austin，我们在60 FPS的大型战斗模拟中展示了一个包含100,000个独立单元的演示。所有游戏代码都运行多核。 [参见ECS性能演示<a href="https://www.youtube.com/watch?v=0969LalB7vw" target="_blank" rel="noopener">视频]</a></p><h4 id="简单">简单</h4><p>编写<a href="https://en.wiktionary.org/wiki/performant" target="_blank" rel="noopener">高性能</a>代码必须简单。我们相信我们可以编写快速代码，就像<strong>MonoBehaviour.Update</strong>一样简单。</p><blockquote><p>注意：为了正确设定期望，我们认为我们仍有一些方法可以实现这一目标。</p></blockquote><h4 id="编写代码的一种方法">编写代码的一种方法</h4><p>我们想要定义编写游戏代码、编辑器代码、资产管道代码以及引擎代码的单一方式。我们相信这为我们的用户创造了一个更简单的工具，并且更有能力改变现状。</p><p>物理学是一个很好的例子。目前物理学是一种黑盒解决方案。在实践中，许多开发人员希望调整模拟代码以适应他们的游戏需求。如果使用ECS以与游戏代码相同的方式编写物理引擎代码，则可以轻松地在现有物理仿真阶段之间插入您自己的仿真代码或完全控制。</p><p>另一个例子，让我们想象你想制作一个可以进行大规模修改的游戏。</p><p>如果我们的导入管道是作为一组<strong>ComponentSystems实现的</strong>。我们有一些FBX导入管道代码，默认情况下在资产管道中用于导入和后处理FBX文件。（在编辑器中使用Mesh和FBX导入代码。）</p><p>然后，很容易配置程序包管理器，可以在已部署的游戏中使用相同的FBX导入和后处理代码进行修改。</p><p>我们相信，在基础层面，这将使Unity比现在更加灵活。</p><h4 id="联网">联网</h4><p>我们想要定义一种编写所有游戏代码的简单方法。遵循此方法，您的游戏可以使用三种网络架构中的一种，具体取决于您创建的游戏类型。</p><p>我们专注于为托管游戏提供最佳的网络引擎支持。使用最近收购的<a href="http://multiplay.com/" target="_blank" rel="noopener">Multiplay.com</a>服务，我们提供了一个简单的管道来托管所述游戏。</p><ul><li>FPS - 服务器上的模拟</li><li>RTS - 确定性锁步模拟</li><li>街机游戏 - GGPO</li></ul><blockquote><p>注意：为了正确设置期望，我们尚未在实体组件系统之上提供任何网络代码。它正在进行中。</p></blockquote><h4 id="确定性">确定性</h4><p>我们的构建管道必须是<a href="https://en.wikipedia.org/wiki/Deterministic_algorithm" target="_blank" rel="noopener">确定性的</a>。用户可以选择是否所有模拟代码都应该确定性地运行。</p><p>无论使用何种设备，您都应该使用相同的输入获得相同的结果。这对于网络，重放功能甚至高级调试工具都很重要。</p><p>为此，我们将利用Burst编译器在不同平台之间生成精确的浮点数学运算。想象一下，运行相同浮点数学代码的linux服务器和iOS设备。这对于许多场景非常有用，特别是对于连接的游戏，还有调试，重放等。</p><blockquote><p>注意：浮点数学差异是Unity决定解决的问题。这个问题已经有一段时间了解，但到目前为止还没有足够的需要来鼓励人们解决它。为了解决这个问题，包括避免解决问题所需的一些解决方法，请考虑阅读<a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/" target="_blank" rel="noopener">Bruce Dawson的浮点确定性</a>。</p></blockquote><h4 id="沙盒">沙盒</h4><p>Unity是一个沙盒，安全而简单。</p><p>当错误地使用API时，我们提供了很好的错误消息，我们从未将自己置于不正确的使用导致崩溃的位置，这是设计上的（而不是我们可以快速修复的错误）。</p><p>沙箱行为的一个很好的例子是我们的C＃作业系统保证您的C＃作业代码都没有竞争条件。我们通过静态代码分析和运行时检查的组合确定性地检查所有可能的竞争条件。我们会立即为您提供有关任何竞赛条件的错误信息。因此，您可以相信您的代码可以正常工作并且感觉安全，即使是第一次编写多线程游戏代码的开发人员也会做得很好。</p><h4 id="极小性">极小性</h4><p>我们希望Unity可用于从&lt;50kb可执行文件，到千兆字节大小的游戏的所有内容。我们希望Unity在不到1秒的时间内加载小内容。</p><h4 id="迭代时间">迭代时间</h4><p>我们的目标是在大型项目文件夹中任何常见操作的迭代时间保持500ms以下。</p><p>作为一个例子，我们正在努力将C＃编译器重写为完全增量，目标是：</p><blockquote><p>在大型项目中更改单个.cs文件时。组合的编译和热重载时间应小于500毫秒。</p></blockquote><h4 id="我们的代码提供完整的单元测试覆盖率">我们的代码提供完整的单元测试覆盖率</h4><p>我们相信从一开始就提供强大的代码。我们使用单元测试来证明我们的代码在开发人员编写和提交时正常工作。测试作为包的一部分提供。</p><h4 id="演化">演化</h4><p>我们知道我们在如何编写代码方面提出了相当大的改变。从MonoBehaviour.Update到ComponentSystem并使用作业。</p><p>我们相信，最终唯一可以说服游戏开发者的是<strong>尝试它，并亲眼看到自己的游戏结果</strong>。</p><p>因此，在现有项目中应用ECS方法应该容易且快速。我们的目标是在30分钟内，用户可以在大型项目中将一些代码从MonoBehaviour.Update更改为ComponentSystem，并拥有优化游戏代码的成功经验。</p><h4 id="包">包</h4><p>我们希望我们的大多数引擎代码都是用C＃编写的，并部署在一个Package中。所有Unity Pro客户均可使用所有源代码。</p><p>我们希望与客户建立快速反馈循环，因为我们可以推送代码并在包中快速获得反馈，而不会破坏其他部分的稳定性。</p><p>以前我们的大多数引擎代码都是用C ++编写的，这与我们的客户编写代码的方式以及Unity的程序员如何编写代码产生了脱节。由于Burst编译器技术和ECS，我们可以用C＃代码实现比C ++更好的结果，因此我们都能以完全相同的方式编写代码。</p><h4 id="合作">合作</h4><p>我们相信Unity用户和Unity开发人员都在同一个团队中。我们的目的是帮助所有Unity用户更快，更高质量和更好的性能创建最佳游戏体验。</p><p>我们相信，我们开发的每个功能都必须尽早开发真实的场景和真实的生产反馈。包管理器促进了这一点。</p><p>对于那些希望贡献引擎代码的社区用户，我们的目标是通过直接处理贡献者可以提交的相同代码存储库来实现这一目标。通过明确的原则和所有功能的全面测试覆盖，我们希望保持高贡献的质量。</p><p>源代码存储库将适用于所有Unity Pro客户。</p><h4 id="透明度">透明度</h4><p>我们相信透明度。我们公开发展我们的功能，我们在论坛和博客上积极沟通。我们保留时间，以便每个开发人员都可以花时间与客户一起了解用户的痛点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unity Data Oriented Tech Stack基于一系列原则。这些原则为我们正在努力实现的目标提供了良好的背景。一些原则清楚地反映在代码中。其他则只是我们为自己设定的目标。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="DOTS" scheme="https://longshilin.com/blog/categories/Unity/DOTS/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
</feed>
