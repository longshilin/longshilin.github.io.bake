<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gamedev</title>
  
  <subtitle>AWS, DevOps, GameDev, and Other Puzzles</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://longshilin.com/blog/"/>
  <updated>2020-07-19T16:45:19.000Z</updated>
  <id>https://longshilin.com/blog/</id>
  
  <author>
    <name>Shilin Long</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UnityTips</title>
    <link href="https://longshilin.com/blog/84a8576b.html"/>
    <id>https://longshilin.com/blog/84a8576b.html</id>
    <published>2020-05-30T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集一些实用的Unity Tips</p><a id="more"></a><h1>设置在非播放情况下编译脚本</h1><p>可以在Preferences-&gt;General中设置<br><img src="https://longshilin.com/images/20200530181748.png" alt=""></p><hr><h1>OnDrawGizmosSelected</h1><p>您可以使用OnDrawGizmosSelected()来对所选GameObject进行调试。<br><img src="https://longshilin.com/images/20200530182658.gif" alt=""></p><hr><h1>Debug.Log的第二个参数可以用来定位是哪个GameObject调用的该方法</h1><p><img src="https://longshilin.com/images/20200530183354.png" alt=""></p><hr><h1>Debug.Break()可以暂停编辑器</h1><p><img src="https://longshilin.com/images/20200530183659.png" alt=""></p><hr><h1>Inspector中的变量标签 Header, Tooltip and Space</h1><p><img src="https://longshilin.com/images/20200530184758.png" alt=""></p><hr><h1>对任意类扩展方法</h1><p>可以对任意类进行扩展方法</p><pre><code class="language-c#">using System.Collections;using System.Collections.Generic;using UnityEngine;public class test : MonoBehaviour{    public SpriteRenderer sr;    public Material mat;    void Start()    {        sr.transform.ResetTransform();        sr.color = sr.color.ChangeAlpha(.3f);        mat.color = mat.color.ChangeAlpha(.4f);    }}public static class Extension{    public static void ResetTransform(this Transform transform)    {        transform.localPosition = Vector3.zero;        transform.localScale = Vector3.one;        transform.localRotation = Quaternion.identity;    }    public static Color ChangeAlpha(this Color color, float alpha)    {        color.a = alpha;        return color;    }}</code></pre><hr><h1>Built-in shaders</h1><p>下载 Unity’s built-in shaders (including all CGinc files)  <a href="https://unity3d.com/get-unity/download/archive/" target="_blank" rel="noopener">Unity’s Archive download page</a></p><hr><h1>MinMax Attribute</h1><p>最小值和最大值属性，可以用来选取一段中间值<br><img src="https://longshilin.com/images/MinMax%20Attribute.gif" alt=""></p><hr><h1>OnValidate</h1><p>变量的合法性检测与修改<br><img src="https://longshilin.com/images/OnValidate.gif" alt=""></p><hr><h1>Rich Text</h1><p>You can use rich text in Unity’s console.<br>Read more about <a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/StyledText.html" target="_blank" rel="noopener">Rich Text</a>.</p><hr><h1>ContextMenu</h1><p>使用ContextMenu属性从Inspector调用方法。可以在Inspector中的组件菜单中直接调用方法。</p><h1>SerializeField &amp; HideInInspector</h1><p>通过使用属性SerializeField和HideInInspector选择要显示和序列化的变量。</p><h1>FormerlySerializedAs</h1><p>在修改一个Inspector面板上的变量名时，使用FormerlySerializedAs标签定义之前的名称，可以防止修改时的赋值丢失问题。<br>Read more about <a href="https://docs.unity3d.com/ScriptReference/Serialization.FormerlySerializedAsAttribute.html" target="_blank" rel="noopener">FormerlySerializedAs attribute</a>.</p><h1>AddComponentMenu</h1><p>使用AddComponentMenu属性在检查器的“ AddComponent”菜单中组织脚本。<br>Read more about <a href="">AddComponent</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文收集一些实用的Unity Tips&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="UnityTips" scheme="https://longshilin.com/blog/categories/Unity/UnityTips/"/>
    
    
      <category term="UnityTips" scheme="https://longshilin.com/blog/tags/UnityTips/"/>
    
  </entry>
  
  <entry>
    <title>好代码的示例和不好的示例比较</title>
    <link href="https://longshilin.com/blog/7cddb564.html"/>
    <id>https://longshilin.com/blog/7cddb564.html</id>
    <published>2020-05-28T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="名副其实">名副其实</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;int[]&gt; getThem() &#123;</span><br><span class="line">　List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;();</span><br><span class="line">　for (int[] x : theList) </span><br><span class="line">　　 if (x[0] == 4) </span><br><span class="line">　　　 list1.add(x);</span><br><span class="line">　return list1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改良过后的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;int[]&gt; getFlaggedCells()　&#123;</span><br><span class="line">　List&lt;int[]&gt; flaggedCells = new ArrayList&lt;int[]&gt;();</span><br><span class="line">　for (int[] cell : gameBoard)</span><br><span class="line">　　if (cell[STATUS_VALUE] == FLAGGED)</span><br><span class="line">　　　flaggedCells.add(cell);</span><br><span class="line">　return flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道自己在写什么很重要，命名·要有意义</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;名副其实&quot;&gt;名副其实&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public List&amp;lt
      
    
    </summary>
    
      <category term="Coding" scheme="https://longshilin.com/blog/categories/Coding/"/>
    
      <category term="代码整洁之道" scheme="https://longshilin.com/blog/categories/Coding/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="Coding" scheme="https://longshilin.com/blog/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>使用Rider构建和集成简单的DLL示例</title>
    <link href="https://longshilin.com/blog/1dbc6beb.html"/>
    <id>https://longshilin.com/blog/1dbc6beb.html</id>
    <published>2020-04-19T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Reference: <a href="https://docs.unity3d.com/Manual/UsingDLL.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/UsingDLL.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reference: &lt;a href=&quot;https://docs.unity3d.com/Manual/UsingDLL.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.unity3d.com/Manual/UsingDL
      
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Toolset" scheme="https://longshilin.com/blog/categories/Unity/Toolset/"/>
    
    
      <category term="Unity DLL" scheme="https://longshilin.com/blog/tags/Unity-DLL/"/>
    
  </entry>
  
  <entry>
    <title>支持自定义菜单项和编辑器功能</title>
    <link href="https://longshilin.com/blog/146377c6.html"/>
    <id>https://longshilin.com/blog/146377c6.html</id>
    <published>2020-04-19T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在编辑器脚本中，使用<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/ObjectFactory.html">ObjectFactory</a>类创建新的GameObject，组件和资产。创建这些项目时，<code>ObjectFactory</code>该类会自动使用默认预设。您的脚本不必搜索并应用默认的<a href="https://longshilin.com/UnityDoc2019.3/Manual/Presets.html">Presets</a>，因为<code>ObjectFactory</code>它可以为您处理。</p><a id="more"></a><h1>支持新类型</h1><p>要默认支持和启用预设，您的类必须继承以下内容之一：</p><ul><li><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/MonoBehaviour.html">UnityEngine.Monobehaviour</a></li><li><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/ScriptableObject.html">UnityEngine.ScriptableObject</a></li><li><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/Experimental.AssetImporters.ScriptedImporter.html">UnityEngine.ScriptedImporter</a></li></ul><p>预设检查器会创建您的类的临时实例，以便用户可以修改其值，因此请确保您的类不影响或依赖于其他对象，例如静态值，Project Assets或Scene实例。</p><p><strong>提示</strong>：使用<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/CustomEditor.html">CustomEditor</a>属性是可选的。</p><h1>用例示例：自定义“编辑器”窗口中的预设设置</h1><p>使用可以使用“预设”的设置设置自定义<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/EditorWindow.html">EditorWindow</a>类时：</p><ul><li>使用<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/ScriptableObject.html">ScriptableObject</a>存储设置的副本。它也可以具有<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/CustomEditor.html">CustomEditor</a>属性。预设系统处理此对象。</li><li>始终使用此临时<code>ScriptableObject</code>检查器在UI中显示“预设”设置。这样，您的用户<code>EditorWindow</code>和您在编辑已保存的预设时可以拥有相同的UI 。</li><li>当在“ **选择预设”<strong>窗口中</strong>选择“预设”**时，公开一个“预设”按钮，并使用自己的<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/Presets.PresetSelectorReceiver.html">PresetSelectorReceiver</a>实现使<code>EditorWindow</code>设置保持最新。</li></ul><p>以下脚本示例演示了如何将Preset设置添加到简单的<code>EditorWindow</code>。</p><p>此脚本示例演示了一个ScriptableObject，该脚本可保留并显示自定义窗口中的设置（保存到名为<em>Editor / MyWindowSettings.cs</em>的文件中）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">// Temporary ScriptableObject used by the Preset system</span><br><span class="line"></span><br><span class="line">public class MyWindowSettings : ScriptableObject</span><br><span class="line">&#123;</span><br><span class="line">  [SerializeField]</span><br><span class="line">  string m_SomeSettings;</span><br><span class="line">  </span><br><span class="line">  public void Init(MyEditorWindow window)</span><br><span class="line">  &#123;</span><br><span class="line">      m_SomeSettings = window.someSettings;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void ApplySettings(MyEditorWindow window)</span><br><span class="line">  &#123;</span><br><span class="line">      window.someSettings = m_SomeSettings;</span><br><span class="line">      window.Repaint();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本示例，<code>PresetSelectorReceiver</code>用于更新<code>ScriptableObject</code>自定义窗口中使用的脚本（保存到名为<em>Editor / MySettingsReceiver.cs</em>的文件中*）*：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEditor.Presets;</span><br><span class="line"></span><br><span class="line">// PresetSelector receiver to update the EditorWindow with the selected values.</span><br><span class="line"></span><br><span class="line">public class MySettingsReceiver : PresetSelectorReceiver</span><br><span class="line">&#123;</span><br><span class="line">  Preset initialValues;</span><br><span class="line">  MyWindowSettings currentSettings;</span><br><span class="line">  MyEditorWindow currentWindow;</span><br><span class="line">  </span><br><span class="line">  public void Init(MyWindowSettings settings, MyEditorWindow window)</span><br><span class="line">  &#123;</span><br><span class="line">      currentWindow = window;</span><br><span class="line">      currentSettings = settings;</span><br><span class="line">      initialValues = new Preset(currentSettings);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public override void OnSelectionChanged(Preset selection)</span><br><span class="line">  &#123;</span><br><span class="line">      if (selection != null)</span><br><span class="line">      &#123;</span><br><span class="line">          // Apply the selection to the temporary settings</span><br><span class="line">          selection.ApplyTo(currentSettings);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          // None have been selected. Apply the Initial values back to the temporary selection.</span><br><span class="line">          initialValues.ApplyTo(currentSettings);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // Apply the new temporary settings to our manager instance</span><br><span class="line">      currentSettings.ApplySettings(currentWindow);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public override void OnSelectionClosed(Preset selection)</span><br><span class="line">  &#123;</span><br><span class="line">      // Call selection change one last time to make sure you have the last selection values.</span><br><span class="line">      OnSelectionChanged(selection);</span><br><span class="line">      // Destroy the receiver here, so you don&apos;t need to keep a reference to it.</span><br><span class="line">      DestroyImmediate(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/EditorWindow.html">EditorWindow的</a>脚本示例，该脚本使用临时的ScriptableObject Inspector及其“预设”按钮（保存到名为<em>Editor / MyEditorWindow.cs</em>的文件*）*显示自定义设置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEditor;</span><br><span class="line">using UnityEditor.Presets;</span><br><span class="line"></span><br><span class="line">public class MyEditorWindow : EditorWindow</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // get the Preset icon and a style to display it</span><br><span class="line">  private static class Styles</span><br><span class="line">  &#123;</span><br><span class="line">      public static GUIContent presetIcon = EditorGUIUtility.IconContent(&quot;Preset.Context&quot;);</span><br><span class="line">      public static GUIStyle iconButton = new GUIStyle(&quot;IconButton&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Editor m_SettingsEditor;</span><br><span class="line">  MyWindowSettings m_SerializedSettings;</span><br><span class="line">  </span><br><span class="line">  public string someSettings</span><br><span class="line">  &#123;</span><br><span class="line">      get &#123; return EditorPrefs.GetString(&quot;MyEditorWindow_SomeSettings&quot;); &#125;</span><br><span class="line">      set &#123; EditorPrefs.SetString(&quot;MyEditorWindow_SomeSettings&quot;, value); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // Method to open the window</span><br><span class="line">  [MenuItem(&quot;Window/MyEditorWindow&quot;)]</span><br><span class="line">  static void OpenWindow()</span><br><span class="line">  &#123;</span><br><span class="line">      GetWindow&lt;MyEditorWindow&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void OnEnable()</span><br><span class="line">  &#123;</span><br><span class="line">      // Create your settings now and its associated Inspector</span><br><span class="line">      // that allows to create only one custom Inspector for the settings in the window and the Preset.</span><br><span class="line">      m_SerializedSettings = ScriptableObject.CreateInstance&lt;MyWindowSettings&gt;();</span><br><span class="line">      m_SerializedSettings.Init(this);</span><br><span class="line">      m_SettingsEditor = Editor.CreateEditor(m_SerializedSettings);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void OnDisable()</span><br><span class="line">  &#123;</span><br><span class="line">      Object.DestroyImmediate(m_SerializedSettings);</span><br><span class="line">      Object.DestroyImmediate(m_SettingsEditor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void OnGUI()</span><br><span class="line">  &#123;</span><br><span class="line">      EditorGUILayout.BeginHorizontal();</span><br><span class="line">      EditorGUILayout.LabelField(&quot;My custom settings&quot;, EditorStyles.boldLabel);</span><br><span class="line">      GUILayout.FlexibleSpace();</span><br><span class="line">      // create the Preset button at the end of the &quot;MyManager Settings&quot; line.</span><br><span class="line">      var buttonPosition = EditorGUILayout.GetControlRect(false, EditorGUIUtility.singleLineHeight, Styles.iconButton);</span><br><span class="line"></span><br><span class="line">      if (EditorGUI.DropdownButton(buttonPosition, Styles.presetIcon, FocusType.Passive, Styles.iconButton))</span><br><span class="line">      &#123;</span><br><span class="line">          // Create a receiver instance. This destroys itself when the window appears, so you don&apos;t need to keep a reference to it.</span><br><span class="line">          var presetReceiver = ScriptableObject.CreateInstance&lt;MySettingsReceiver&gt;();</span><br><span class="line">          presetReceiver.Init(m_SerializedSettings, this);</span><br><span class="line">          // Show the PresetSelector modal window. The presetReceiver updates your data.</span><br><span class="line">          PresetSelector.ShowSelector(m_SerializedSettings, null, true, presetReceiver);</span><br><span class="line">      &#125;</span><br><span class="line">      EditorGUILayout.EndHorizontal();</span><br><span class="line">      </span><br><span class="line">      // Draw the settings default Inspector and catch any change made to it.</span><br><span class="line">      EditorGUI.BeginChangeCheck();</span><br><span class="line">      m_SettingsEditor.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">      if (EditorGUI.EndChangeCheck())</span><br><span class="line">      &#123;</span><br><span class="line">          // Apply changes made in the settings editor to our instance.</span><br><span class="line">          m_SerializedSettings.ApplySettings(this);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编辑器脚本中，使用&lt;a href=&quot;https://longshilin.com/UnityDoc2019.3/ScriptReference/ObjectFactory.html&quot;&gt;ObjectFactory&lt;/a&gt;类创建新的GameObject，组件和资产。创建这些项目时，&lt;code&gt;ObjectFactory&lt;/code&gt;该类会自动使用默认预设。您的脚本不必搜索并应用默认的&lt;a href=&quot;https://longshilin.com/UnityDoc2019.3/Manual/Presets.html&quot;&gt;Presets&lt;/a&gt;，因为&lt;code&gt;ObjectFactory&lt;/code&gt;它可以为您处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Editor" scheme="https://longshilin.com/blog/categories/Unity/Editor/"/>
    
    
      <category term="自定义菜单项" scheme="https://longshilin.com/blog/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E9%A1%B9/"/>
    
      <category term="编辑器功能" scheme="https://longshilin.com/blog/tags/%E7%BC%96%E8%BE%91%E5%99%A8%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>减小构建的文件大小</title>
    <link href="https://longshilin.com/blog/ea658644.html"/>
    <id>https://longshilin.com/blog/ea658644.html</id>
    <published>2020-04-19T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>将构建的应用程序的文件大小保持为最小很重要，对于移动设备或施加大小限制的应用程序商店尤其如此。</p><a id="more"></a><h1>查看包体中哪些文件占比最大</h1><p>减小规模的第一步是确定哪些资产对其贡献最大，因为这些资产是最有可能进行优化的候选对象。完成构建后，此信息可在编辑器日志中找到。转到控制台窗口（菜单：窗口 &gt; 常规 &gt; 控制台），单击右上角的小下拉面板，然后选择打开编辑器日志。</p><p><img src="https://longshilin.com/images/20200419101416.png" alt="执行构建后打开的 Editor 日志或者项目目录下的Build.log文件"></p><p>Editor 日志提供按类型细分的资源摘要，然后按大小比例顺序列出所有各个资源。通常，纹理 (Textures)、声音 (Sounds) 和动画 (Animations) 等内容占用的空间最多，而脚本 (Scripts)、关卡 (Levels) 和着色器 (Shaders) 一般影响最小。列表中显示的__文件标头 (File headers)__ 不是资源，实际上是添加到“原始”资源文件的额外数据，用于存储引用和设置。这些标头通常与资源大小差别很小，但如果在 Resources 文件夹中有许多大型资源，则该值可能会很大。</p><p>Editor 日志有助于识别可能要删除或优化的资源，但在开始之前应考虑以下事项：</p><p>Unity 将导入的资源重新编码为其自己的内部格式，因此源资源类型的选择不是相关因素。例如，如果项目中有一个多层 Photoshop 纹理，在构建之前将其展平并压缩。将纹理导出为 .png 文件对构建大小没有任何影响，因此应该坚持使用在开发过程中最方便的格式。</p><p>Unity 在构建期间会剥离大多数未使用的资源，因此无法通过从项目中手动删除资源来获得任何优化效果。唯一不会删除的资源是脚本（但无论如何，这些脚本通常都非常小）和 Resources 文件夹中的资源（因为 Unity 无法确定哪些是需要的，而哪些不是）。考虑到这一点，应确保 Resources 文件夹中的所有资源都是游戏所必需的资源。也许可以使用 AssetBundle 替换 Resources 文件夹中的资源；这样一来，Unity 就会动态加载资源，从而减小播放器大小。</p><h1>关于减小构建大小的建议</h1><h2 id="纹理">纹理</h2><p>纹理通常在构建中占据最多空间。第一个解决方案是使用压缩的纹理格式。请参阅有关特定于平台的纹理压缩的文档以了解更多信息。</p><p>如果这样做不足以减小文件大小，请尝试减小纹理图像的物理大小（以像素为单位）。若要在不修改实际源内容的情况下执行此操作，请在 Project 视图中选择该纹理，然后在 Inspector 窗口中减小 Max Size。要查看纹理在游戏中的外观，请放大使用该纹理的游戏对象，然后调整 <strong>Max Size</strong>，直至该纹理在 Scene 视图中的外观开始变差。更改最大纹理大小不会影响纹理资源，只会影响纹理在游戏中的分辨率。</p><p><img src="https://longshilin.com/images/20200419155312.png" alt=""></p><p>默认情况下，Unity 在导入时会压缩所有纹理。要在 Editor 中加快工作流程，请选择 Unity &lt; Preferences 并取消选中 Compress Assets on Import 的复选框。无论此设置如何，所有纹理都会在构建中进行压缩。</p><h2 id="网格和动画">网格和动画</h2><p>可以压缩<a href="https://longshilin.com/UnityDoc2019.3/Manual/class-Mesh.html">网格</a>和导入的动画剪辑，使它们在游戏文件中占用较少的空间。要启用网格压缩，请选择网格，然后在 Inspector 窗口中将 <strong>Mesh Compression</strong> 设置为 <strong>Low</strong>、<strong>Medium</strong> 或 <strong>High</strong>。网格和动画压缩使用量化技术，这意味着占用更少的空间，但压缩可能会带来一定程度的不准确性。请针对具体模型尝试找到可接受的压缩程度。</p><p>请注意，网格压缩只是生成较小的数据文件，在运行时不会减少使用的内存。减少动画关键帧会生成较小的数据文件，并会在运行时减少使用的内存；通常应始终启用该功能。请参阅有关<a href="https://longshilin.com/UnityDoc2019.3/Manual/class-AnimationClip.html">动画剪辑</a>的文档以了解与此相关的更多信息。</p><h2 id="减少-net库的大小">减少.NET库的大小</h2><p><a href="http://xn--Unity-qm1hmbz593aqde.NET" target="_blank" rel="noopener">Unity支持两个.NET</a> API兼容性级别：.NET <a href="http://4.xn--x-se9a.NET" target="_blank" rel="noopener">4.x和.NET</a> Standard 2.0。.NET Standard <a href="http://2.xn--0-cr6a90kc9mpyf0o4g.NET" target="_blank" rel="noopener">2.0将您限制为.NET</a> API的较小子集，这有助于减小尺寸。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将构建的应用程序的文件大小保持为最小很重要，对于移动设备或施加大小限制的应用程序商店尤其如此。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="优化" scheme="https://longshilin.com/blog/categories/Unity/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="打包" scheme="https://longshilin.com/blog/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Smart Merge</title>
    <link href="https://longshilin.com/blog/f8ae384d.html"/>
    <id>https://longshilin.com/blog/f8ae384d.html</id>
    <published>2020-04-19T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity 包含一个名为 <strong>UnityYAMLMerge</strong> 的工具，能够以语义正确的方式合并场景和预制件文件。可从命令行中访问该工具，也可将其用于第三方版本控制软件。</p><a id="more"></a><h2 id="在-unity-中设置智能合并">在 Unity 中设置智能合并</h2><p>In the <a href="https://longshilin.com/UnityDoc2019.3/Manual/class-EditorManager.html">Editor</a> window (menu: <strong>Edit &gt; Project Settings</strong>, then select the <strong>Editor</strong> category), you have the option to select a third party version control tool (Perforce or PlasticSCM, for example). When one of these tools is enabled, you will see a <em>Smart Merge</em> menu under the <em>Version Control</em> heading. The menu has four options:</p><ul><li><strong>Off</strong>：仅使用偏好设置中设定的默认合并工具而不进行智能合并。</li><li><strong>Premerge</strong>：启用智能合并，接受纯净的合并。不纯净的合并将创建文件的预先合并基础版本、他们的版本和我的版本。然后，对这些版本使用默认合并工具。</li><li><strong>Ask</strong>：启用智能合并，但发生冲突时显示一个对话框让用户解决冲突（这是默认设置）。</li></ul><h2 id="设置-unityyamlmerge-与第三方工具结合使用">设置 UnityYAMLMerge 与第三方工具结合使用</h2><p>UnityYAMLMerge 工具随附于 Unity Editor；假设 Unity 安装在标准位置，则 UnityYAMLMerge 的路径将是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Unity\Editor\Data\Tools\UnityYAMLMerge.exe</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">C:\Program Files (x86)\Unity\Editor\Data\Tools\UnityYAMLMerge.exe</span><br></pre></td></tr></table></figure><ul><li>在 Windows 上；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Applications/Unity/Unity.app/Contents/Tools/UnityYAMLMerge</span><br></pre></td></tr></table></figure><ul><li>在 Mac OSX 上（使用 Finder 中的 <em>Show Package Contents</em> 命令访问此文件夹）。</li></ul><p>UnityYAMLMerge 附带了一个默认的回退文件（称为 mergespecfile.txt，也在 Tools 文件夹中），用于指定如何处理未解决的冲突或未知文件。此外，还可将其用作不会根据文件扩展名自动选择合并工具的版本控制系统（例如 git）的主要合并工具。默认情况下，mergespecfile.txt 中已列出最常用的工具，但可以编辑此文件以添加新工具或更改选项。</p><p>可从命令行中将 UnityYAMLMerge 作为独立工具运行（若要查看该工具的完整使用说明，可在运行时不带任何参数）。下面给出了常见版本控制系统的设置说明。</p><h3 id="p4v">P4V</h3><ul><li>选择 Preferences &gt; Merge。</li><li>选择 <em>Other application</em>。</li><li>单击 <em>Add</em> 按钮。</li><li>在 Extension 字段中，输入 <code>.unity</code>。</li><li>在 Application 字段中，输入 UnityYAMLMerge 工具的路径（见下文）。</li><li>在 Arguments 字段中，输入 <code>merge -p %b %1 %2 %r</code></li><li>单击 Save。</li></ul><p>然后，按照相同的步骤添加 <code>.prefab</code> 扩展名。</p><h3 id="git">Git</h3><p>将以下文本添加到 <code>.git</code> 或 <code>.gitconfig</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[merge]</span><br><span class="line">    tool = unityyamlmerge</span><br><span class="line"></span><br><span class="line">    [mergetool &quot;unityyamlmerge&quot;]</span><br><span class="line">    trustExitCode = false</span><br><span class="line">    cmd = &apos;&lt;path to UnityYAMLMerge&gt;&apos; merge -p &quot;$BASE&quot; &quot;$REMOTE&quot; &quot;$LOCAL&quot; &quot;$MERGED&quot;</span><br></pre></td></tr></table></figure><h3 id="mercurial">Mercurial</h3><p>将以下文本添加到 <code>.hgrc</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[merge-patterns]</span><br><span class="line">    **.unity = unityyamlmerge</span><br><span class="line">    **.prefab = unityyamlmerge</span><br><span class="line"></span><br><span class="line">    [merge-tools]</span><br><span class="line">    unityyamlmerge.executable = &lt;path to UnityYAMLMerge&gt;</span><br><span class="line">    unityyamlmerge.args = merge -p --force $base $other $local $output</span><br><span class="line">    unityyamlmerge.checkprompt = True</span><br><span class="line">    unityyamlmerge.premerge = False</span><br><span class="line">    unityyamlmerge.binary = False</span><br></pre></td></tr></table></figure><h3 id="svn">SVN</h3><p>将以下文本添加到 <code>~/.subversion/config</code> 文件中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[helpers]</span><br><span class="line">    merge-tool-cmd = &lt;path to UnityYAMLMerge&gt;</span><br></pre></td></tr></table></figure><h3 id="tortoisegit">TortoiseGit</h3><ul><li>选择 Preferences &gt; Diff Viewer &gt; Merge Tool，然后单击 <em>Advanced</em> 按钮。</li><li>在弹出框的 Extension 字段中，输入 <code>.unity</code>。</li><li>在 External Program 字段中，输入：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;path to UnityYAMLMerge&gt; merge -p %base %theirs %mine %merged</span><br></pre></td></tr></table></figure><p>然后，按照相同的步骤添加 <code>.prefab</code> 扩展名。</p><h3 id="plasticscm">PlasticSCM</h3><ul><li>选择 Preferences &gt; Merge Tools，然后单击 <em>Add</em> 按钮。</li><li>选择 <em>External</em> 合并工具。</li><li>选择 <em>Use with files that match the following pattern</em>。</li><li>添加 <code>.unity</code> 扩展名。</li><li>输入以下命令：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;path to UnityYAMLMerge&gt; merge -p &quot;@basefile&quot; &quot;@sourcefile&quot;  &quot;@destinationfile&quot; &quot;@output&quot;</span><br></pre></td></tr></table></figure><p>然后，按照相同的步骤添加 <code>.prefab</code> 扩展名。</p><h3 id="sourcetree">SourceTree</h3><ul><li>选择 Tools &gt; Options &gt; Diff。</li><li>在 Merge Tool 下拉选单中选择 <em>Custom</em>。</li><li>在 <em>Merge Command</em> 文本字段中，输入 UnityYAMLMerge 的路径。</li><li>在 <em>Arguments</em> 文本字段中，输入 <code>merge -p $BASE $REMOTE $LOCAL $MERGED</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unity 包含一个名为 &lt;strong&gt;UnityYAMLMerge&lt;/strong&gt; 的工具，能够以语义正确的方式合并场景和预制件文件。可从命令行中访问该工具，也可将其用于第三方版本控制软件。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="工具集" scheme="https://longshilin.com/blog/categories/Unity/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="Smart Merge" scheme="https://longshilin.com/blog/tags/Smart-Merge/"/>
    
  </entry>
  
  <entry>
    <title>添加随机游戏元素</title>
    <link href="https://longshilin.com/blog/98217773.html"/>
    <id>https://longshilin.com/blog/98217773.html</id>
    <published>2020-04-18T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>随机选择的项或值在许多游戏中都很重要。本部分将介绍如何使用 Unity 的内置随机函数来实现一些常见的游戏机制。</p><a id="more"></a><h2 id="从数组中选择一个随机项">从数组中选择一个随机项</h2><p>随机选取一个数组元素归结为选择零和数组最大索引值（等于数组的长度减去 1）之间的一个随机整数。使用内置的 Random.Range 函数可以轻松实现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var element = myArray[Random.Range(0, myArray.Length)];</span><br></pre></td></tr></table></figure><p>请注意，Random.Range 从包含第一个参数但不包含第二个参数的范围内返回一个值，因此在此处使用 myArray.Length 会得到正确的结果。</p><h2 id="选择具有不同概率的项">选择具有不同概率的项</h2><p>有时需要随机选择项，但有些项比其他项被选中的几率更高。例如，NPC 在遇到玩家时可能会以几种不同的方式做出反应：</p><ul><li>友好问候的几率为 50%</li><li>逃跑的几率为 25%</li><li>立即攻击的几率为 20%</li><li>提供金钱作为礼物的几率为 5%</li></ul><p>可将这些不同的结果可视化为一张纸条，该纸条分成几个部分，每个部分占据纸条总长度的一个比例。占据的比例等于选择结果的概率。选择行为相当于沿着纸条的长度选择一个随机点（例如通过投掷飞镖），然后查看该点处于哪个部分。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/ProbStrip.png" alt="img"></p><p>在脚本中，纸条实际上是一个浮点数组，其中的浮点数按顺序包含项的不同概率。随机点是通过将 Random.value 乘以数组中所有浮点数的总和得到的（这些数值不需要加起来等于 1；重点是不同值的相对大小）。要找到该点“位于”哪个数组元素，首先要检查它是否小于第一个元素中的值。如果是，则第一个元素便是选中的元素。否则，从该点值中减去第一个元素的值，然后将其与第二个元素进行比较，依此类推，直到找到正确的元素。在代码中表示为以下所示的内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float Choose (float[] probs) &#123;</span><br><span class="line"></span><br><span class="line">    float total = 0;</span><br><span class="line"></span><br><span class="line">    foreach (float elem in probs) &#123;</span><br><span class="line">        total += elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float randomPoint = Random.value * total;</span><br><span class="line"></span><br><span class="line">    for (int i= 0; i &lt; probs.Length; i++) &#123;</span><br><span class="line">        if (randomPoint &lt; probs[i]) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            randomPoint -= probs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return probs.Length - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，最后的 return 语句是必要的，因为 Random.value 可以返回 1 的结果。在这种情况下，搜索将无法在任何地方找到随机点。将以下行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (randomPoint &lt; probs[i])</span><br></pre></td></tr></table></figure><p>…更改为“小于或等于”测试将避免额外的 return 语句，但也会允许偶尔选择某个项，即使其概率为零也是如此。</p><h2 id="加权连续随机值">加权连续随机值</h2><p>如果结果是不连续的，那么浮点数组方法会很有效，但在某些情况下希望产生更连续的结果；比如说，希望随机化一个宝箱中发现的金块数量，并希望能够出现 1 到 100 之间的任何数字，但让更小数字的概率更高。使用浮点数组方法来执行此算法将需要设置一个包含 100 个浮点数（即纸条上的部分）的数组，这是很不实用的方法；如果不局限于整数而是想要在该范围内的任何数字，则不可能使用这种方法。</p><p>一种适用于连续结果的更好方法是使用 AnimationCurve 将“原始”随机值转换为“加权”值；通过绘制不同的曲线形状，可产生不同的权重。代码编写起来也更简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float CurveWeightedRandom(AnimationCurve curve) &#123;</span><br><span class="line">    return curve.Evaluate(Random.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法从 <code>Random.value</code> 读取值来选择 0 到 1 之间的“原始”随机值。然后，该值传递给 <code>curve.Evaluate()</code>，在此处将其视为水平坐标，并返回曲线在该水平位置处的相应垂直坐标。曲线较平缓的部分被选取的几率较高，而较陡峭的部分被选取的几率较低。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/WeightedRandomCurve-linear.png" alt="线性曲线根本不对值进行加权；曲线上每个点的水平坐标等于垂直坐标。">线性曲线根本不对值进行加权；曲线上每个点的水平坐标等于垂直坐标。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/WeightedRandomCurve-bias-low.png" alt="这条曲线在开始时较平缓，然后在结束时变得越来越陡峭，因此较低值的几率较高，而较高值的几率较低。此处可以看到 x=0.5 时曲线的高度约为 0.25，这意味着有 50% 的几率得到 0 到 0.25 之间的值。">这条曲线在开始时较平缓，然后在结束时变得越来越陡峭，因此较低值的几率较高，而较高值的几率较低。此处可以看到 x=0.5 时曲线的高度约为 0.25，这意味着有 50% 的几率得到 0 到 0.25 之间的值。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/WeightedRandomCurve-bias-lowhigh.png" alt="这条曲线在开始和结束时都很平缓，因此这些值接近极值的几率较高，而中间的陡峭部分表示得到这些值的几率较低。另外请注意，使用此曲线时，高度值已向上移动：曲线底部为 1，曲线顶部为 10，这意味着曲线产生的值将在 1-10 范围内，而不是像以前的曲线那样在 0-1 范围内。">这条曲线在开始和结束时都很平缓，因此这些值接近极值的几率较高，而中间的陡峭部分表示得到这些值的几率较低。另外请注意，使用此曲线时，高度值已向上移动：曲线底部为 1，曲线顶部为 10，这意味着曲线产生的值将在 1–10 范围内，而不是像以前的曲线那样在 0–1 范围内。</p><p>请注意，这些曲线并非概率论指南中可能介绍的概率分布曲线，而更像是反向累积概率曲线。</p><p>通过在一个脚本上定义 AnimationCurve 公共变量，可使用 Inspector 窗口直观查看和编辑曲线，而无需计算值。</p><p>这种方法会产生浮点数。如果要计算整数结果（例如，需要 82 个金块，而不是 82.1214 个金块），可将计算值传递给 Mathf.RoundToInt() 之类的函数。</p><h2 id="列表洗牌">列表洗牌</h2><p>一种常见的游戏机制是从一组已知的项中进行选择，但让这些项以随机顺序到达。例如，一副纸牌通常需要洗牌，因此不会以可预测的顺序绘制。为了对数组中的项进行随机洗牌，可访问每个元素，然后将其与数组中位于随机索引处的另一个元素进行交换：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Shuffle (int[] deck) &#123;</span><br><span class="line">    for (int i = 0; i &lt; deck.Length; i++) &#123;</span><br><span class="line">        int temp = deck[i];</span><br><span class="line">        int randomIndex = Random.Range(0, deck.Length);</span><br><span class="line">        deck[i] = deck[randomIndex];</span><br><span class="line">        deck[randomIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从一组无重复的项中选择">从一组无重复的项中选择</h2><p>一种常见的任务是从一组中随机选取一些项，但不可多次选取同一项。例如，可能希望在一些随机生成点生成多个 NPC，但要确保每个点只生成一个 NPC。为实现此目的，可按顺序遍历这些项，随机决定是否将每一项添加到所选集合中。当访问每一项时，该项被选取的概率等于仍然需要的项数除以仍然可供选择的项数。</p><p>例如，假设有 10 个可用的生成点，但只能选择其中 5 个。选择第一项的概率为 5/10，即 0.5。如果选择了该项，那么第二项的概率将是 4/9，即 0.44（即仍然需要 4 项，还剩下 9 项可供选择）。但是，如果未选择第一项，那么第二项的概率将是 5/9，即 0.56（即仍然需要 5 项，还剩下 9 项可供选择）。这一直持续到该集合包含所需的 5 项为止。可使用如下所示的代码实现此算法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transform[] spawnPoints;</span><br><span class="line"></span><br><span class="line">Transform[] ChooseSet (int numRequired) &#123;</span><br><span class="line">    Transform[] result = new Transform[numRequired];</span><br><span class="line"></span><br><span class="line">    int numToChoose = numRequired;</span><br><span class="line"></span><br><span class="line">    for (int numLeft = spawnPoints.Length; numLeft &gt; 0; numLeft--) &#123;</span><br><span class="line"></span><br><span class="line">        float prob = (float)numToChoose/(float)numLeft;</span><br><span class="line"></span><br><span class="line">        if (Random.value &lt;= prob) &#123;</span><br><span class="line">            numToChoose--;</span><br><span class="line">            result[numToChoose] = spawnPoints[numLeft - 1];</span><br><span class="line"></span><br><span class="line">            if (numToChoose == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，虽然选择是随机的，但所选集合中的项与原始数组中的项具有相同的顺序。如果要按顺序一次使用一项，那么这种排序可能使它们在一定程度上可预测，因此在使用之前可能需要对数组进行洗牌。</p><h2 id="空间中的随机点">空间中的随机点</h2><p>通过将 Vector3 的每个分量设置为 Random.value 返回的值可以选择立方体中的随机点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var randVec = Vector3(Random.value, Random.value, Random.value);</span><br></pre></td></tr></table></figure><p>这种算法可在边长为一个单位的立方体内部给出一个点。只需将矢量的 X、Y 和 Z 分量乘以期望的边长即可缩放该立方体。如果其中一个轴设置为零，则该点将始终位于单个平面内。例如，在“地面”上选取随机点通常需要随机设置 X 和 Z 分量并将 Y 分量设置为零。</p><p>当体积为球体时（即，希望从原点开始的给定半径内选取随机点时），可使用 Random.insideUnitSphere 乘以所需的半径：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var randWithinRadius = Random.insideUnitSphere * radius;</span><br></pre></td></tr></table></figure><p>请注意，如果将结果矢量的某个分量设置为零，则<em>不能</em>在圆内获得正确的随机点。尽管该点确实是随机点并且位于正确的半径内，但是概率严重偏向于圆的边缘，因此点分布将非常不均匀。对于此任务，应改用 Random.insideUnitCircle：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var randWithinCircle = Random.insideUnitCircle * radius;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随机选择的项或值在许多游戏中都很重要。本部分将介绍如何使用 Unity 的内置随机函数来实现一些常见的游戏机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="游戏内工具集" scheme="https://longshilin.com/blog/categories/Unity/%E6%B8%B8%E6%88%8F%E5%86%85%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="随机游戏元素" scheme="https://longshilin.com/blog/tags/%E9%9A%8F%E6%9C%BA%E6%B8%B8%E6%88%8F%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>Unity Asset DataBase Editor</title>
    <link href="https://longshilin.com/blog/8ee7eed0.html"/>
    <id>https://longshilin.com/blog/8ee7eed0.html</id>
    <published>2020-04-15T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章纪录和Asset DataBase相关，可以通过脚本方式控制。</p><a id="more"></a><h1>Importing an Asset</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEditor;</span><br><span class="line"></span><br><span class="line">public class ImportAsset &#123;</span><br><span class="line">    [MenuItem (&quot;AssetDatabase/ImportExample&quot;)]</span><br><span class="line">    static void ImportExample ()</span><br><span class="line">    &#123;</span><br><span class="line">        AssetDatabase.ImportAsset(&quot;Assets/Textures/texture.jpg&quot;, ImportAssetOptions.Default);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ImportAssetOptions选项：</strong><br>Default默认导入选项。<br>ForceUpdate由用户发起的资源导入。<br>ForceSynchronousImport同步导入所有资源。<br>ImportRecursive导入文件夹时，也要导入其中的所有内容。<br>DontDownloadFromCacheServer强制完全重新导入，但不从缓存服务器下载资源。<br>ForceUncompressedImport强制资源以版本工具的未压缩形式导入。</p><h1>Loading an Asset</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEditor;</span><br><span class="line"></span><br><span class="line">public class ImportAsset &#123;</span><br><span class="line">    [MenuItem (&quot;AssetDatabase/LoadAssetExample&quot;)]</span><br><span class="line">    static void ImportExample ()</span><br><span class="line">    &#123;</span><br><span class="line">        Texture2D t = AssetDatabase.LoadAssetAtPath(&quot;Assets/Textures/texture.jpg&quot;, typeof(Texture2D)) as Texture2D;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>有关AssetDataBase的文件操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AssetDatabaseIOExample &#123;</span><br><span class="line">    [MenuItem (&quot;AssetDatabase/FileOperationsExample&quot;)]</span><br><span class="line">    static void Example ()</span><br><span class="line">    &#123;</span><br><span class="line">        string ret;</span><br><span class="line">        </span><br><span class="line">        // 创建</span><br><span class="line">        Material material = new Material (Shader.Find(&quot;Specular&quot;));</span><br><span class="line">        AssetDatabase.CreateAsset(material, &quot;Assets/MyMaterial.mat&quot;);</span><br><span class="line">        if(AssetDatabase.Contains(material))</span><br><span class="line">            Debug.Log(&quot;Material asset created&quot;);</span><br><span class="line">        </span><br><span class="line">        // 重命名</span><br><span class="line">        ret = AssetDatabase.RenameAsset(&quot;Assets/MyMaterial.mat&quot;, &quot;MyMaterialNew&quot;);</span><br><span class="line">        if(ret == &quot;&quot;)</span><br><span class="line">            Debug.Log(&quot;Material asset renamed to MyMaterialNew&quot;);</span><br><span class="line">        else</span><br><span class="line">            Debug.Log(ret);</span><br><span class="line">        </span><br><span class="line">        // 创建文件夹</span><br><span class="line">        ret = AssetDatabase.CreateFolder(&quot;Assets&quot;, &quot;NewFolder&quot;);</span><br><span class="line">        if(AssetDatabase.GUIDToAssetPath(ret) != &quot;&quot;)</span><br><span class="line">            Debug.Log(&quot;Folder asset created&quot;);</span><br><span class="line">        else</span><br><span class="line">            Debug.Log(&quot;Couldn&apos;t find the GUID for the path&quot;);</span><br><span class="line">        </span><br><span class="line">        // 移动</span><br><span class="line">        ret = AssetDatabase.MoveAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/NewFolder/MyMaterialNew.mat&quot;);</span><br><span class="line">        if(ret == &quot;&quot;)</span><br><span class="line">            Debug.Log(&quot;Material asset moved to NewFolder/MyMaterialNew.mat&quot;);</span><br><span class="line">        else</span><br><span class="line">            Debug.Log(ret);</span><br><span class="line">        </span><br><span class="line">        // 复制</span><br><span class="line">        if(AssetDatabase.CopyAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/MyMaterialNew.mat&quot;))</span><br><span class="line">            Debug.Log(&quot;Material asset copied as Assets/MyMaterialNew.mat&quot;);</span><br><span class="line">        else</span><br><span class="line">            Debug.Log(&quot;Couldn&apos;t copy the material&quot;);</span><br><span class="line">        // 手动刷新数据库以通知更改</span><br><span class="line">        AssetDatabase.Refresh();</span><br><span class="line">        Material MaterialCopy = AssetDatabase.LoadAssetAtPath(&quot;Assets/MyMaterialNew.mat&quot;, typeof(Material)) as Material;</span><br><span class="line">        </span><br><span class="line">        // 移到垃圾箱</span><br><span class="line">        if(AssetDatabase.MoveAssetToTrash(AssetDatabase.GetAssetPath(MaterialCopy)))</span><br><span class="line">            Debug.Log(&quot;MaterialCopy asset moved to trash&quot;);</span><br><span class="line">        </span><br><span class="line">        // 删除</span><br><span class="line">        if(AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(material)))</span><br><span class="line">            Debug.Log(&quot;Material asset deleted&quot;);</span><br><span class="line">        if(AssetDatabase.DeleteAsset(&quot;Assets/NewFolder&quot;))</span><br><span class="line">            Debug.Log(&quot;NewFolder deleted&quot;);</span><br><span class="line">        </span><br><span class="line">        // 进行所有更改后刷新 AssetDatabase</span><br><span class="line">        AssetDatabase.Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章纪录和Asset DataBase相关，可以通过脚本方式控制。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Editor" scheme="https://longshilin.com/blog/categories/Unity/Editor/"/>
    
    
      <category term="Asset DataBase" scheme="https://longshilin.com/blog/tags/Asset-DataBase/"/>
    
      <category term="Editor" scheme="https://longshilin.com/blog/tags/Editor/"/>
    
  </entry>
  
  <entry>
    <title>Unity Asset Bundle Browser tool(中文翻译版)</title>
    <link href="https://longshilin.com/blog/4063a140.html"/>
    <id>https://longshilin.com/blog/4063a140.html</id>
    <published>2020-04-12T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>该工具使用户可以查看和编辑其Unity项目的资产捆绑包的配置。它将阻止将创建无效捆绑软件的编辑，并通知您现有捆绑软件的任何问题。它还提供了基本的构建功能。</p><p>使用此工具作为选择资产和在检查器中手动设置其资产束的替代方法。可以将其放入任何5.6或更高版本的Unity项目中。它将在<strong>Window</strong> &gt; <strong>AssetBundle Browser中</strong>创建一个新的菜单项。捆绑软件配置，构建功能和构建捆绑软件检查在新窗口中分为三个选项卡。</p><a id="more"></a><p><img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/browser_header.png" alt="浏览器标题"></p><h3 id="需要unity-5-6">需要Unity 5.6+</h3><h1>用法-配置</h1><p>该窗口提供了类似于资源管理器的界面，用于管理和修改项目中的资产捆绑包。首次打开时，该工具将在后台解析所有包数据，并慢慢标记它检测到的警告或错误。它会尽其所能与项目保持同步，但不能总是意识到工具外部的活动。要在错误检测时强制快速通过，或使用外部所做的更改来更新工具，请点击左上方的“刷新”按钮。</p><p>该窗口分为四个部分：捆绑包列表，捆绑包详细信息，资产列表和资产详细信息。 <img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/browser_configure2.png" alt="BroserConfigure"></p><h3 id="捆绑清单">捆绑清单</h3><p>左窗格显示项目中所有捆绑包的列表。可用功能：</p><ul><li>选择一个捆绑包或捆绑包集，以在“资产列表”窗格中查看捆绑包中的资产列表。</li><li>带有变体的软件包为深灰色，可以展开以显示变体列表。</li><li>右键单击或缓慢双击以重命名包或包文件夹。</li><li>如果捆绑包有任何错误，警告或信息消息，则图标将出现在右侧。将鼠标悬停在图标上以获取更多信息。</li><li>如果一个捆绑包中至少有一个场景（使其成为一个场景捆绑包）并且显式包括了非场景资产，它将被标记为有错误。除非修复，否则此捆绑包不会生成。</li><li>资产重复的捆绑商品将带有警告标记（有关以下资产清单部分中重复的更多信息）</li><li>空的捆绑包将标记一条信息消息。由于多种原因，空束不是很稳定，有时会从此列表中消失。</li><li>捆绑软件的文件夹将被标记为包含的捆绑软件中的最高消息。</li><li>要修复捆绑资产中重复的资产包含，您可以：<ul><li>右键单击单个捆绑软件，将所有确定为重复的资产移动到新捆绑软件中。</li><li>右键单击多个捆绑，以将资产从所有重复的选定捆绑中移动到新捆绑中，或仅将选择中共享的资产移动到新捆绑中。</li><li>您也可以将重复的资产从“资产列表”窗格中拖出到捆绑包列表中，以将其明确包含在捆绑包中。下面的“资产列表”功能集中提供了更多有关此信息。</li></ul></li><li>右键单击或单击DEL删除捆绑包。</li><li>左右拖动捆绑包以将其移入或移出文件夹，或合并它们。</li><li>将资产从Project Explorer拖到Bundel中以添加它们。</li><li>将资产拖到空白处以创建新的捆绑包。</li><li>右键单击以创建新的捆绑软件或捆绑软件文件夹。</li><li>右键单击以“转换为变体”<ul><li>这会将变体（最初称为“ newvariant”）添加到选定的包中。</li><li>当前选定捆绑销售商品中的所有资产都将移至新变体中</li><li>ComingSoon：变体之间的不匹配检测。</li></ul></li></ul><p>图标指示捆绑包是标准捆绑包还是场景捆绑包。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/ABundleBrowserIconY1756Basic.png" alt="标准捆绑包的图标"></p><p><img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/ABundleBrowserIconY1756Scene.png" alt="场景包的图标"></p><h3 id="捆绑包详细信息">捆绑包详细信息</h3><p>左下方的窗格显示在“捆绑包列表”窗格中选择的捆绑包的详细信息。如果可用，此窗格将显示以下信息：</p><ul><li>捆绑包总大小。这是所有资产的磁盘大小的总和。</li><li>当前捆绑包所依赖的捆绑包</li><li>与当前包关联的任何消息（错误/警告/信息）。</li></ul><h3 id="资产清单">资产清单</h3><p>右上方的窗格提供了在捆绑包列表中选择的捆绑包中包含的资产列表。此列表上方的搜索字段将与任何捆绑包中的资产匹配。资产列表将仅显示匹配的资产，捆绑包列表将仅显示包含匹配资产的捆绑包。可用功能：</p><ul><li>查看预计将包含在捆绑中的所有资产。按任何列标题对资产列表进行排序。</li><li>查看捆绑中明确包含的资产。这些是已明确分配捆绑的资产。检查员将反映捆绑包的包含情况，在此视图中，他们将在资产名称旁边说出捆绑包名称。</li><li>查看包含在捆绑中的资产。这些资产在资产名称旁边将<em>自动</em>说成是捆绑商品的名称。如果在检查器中查看这些资产，它们将说“ *无”*作为分配的捆绑包。<ul><li>由于对其他包含资产的依赖性，这些资产已添加到选定的捆绑包中。只有未明确分配给捆绑包的资产才会隐式包含在任何捆绑包中。</li><li>请注意，此隐式包含列表可能不完整。某些已知的材质和纹理问题并不总是能够正确显示。</li><li>由于多个资产可以共享依赖关系，因此通常将给定资产隐式包含在多个束中。如果工具检测到这种情况，它将使用警告图标标记捆绑商品和有问题的资产。</li><li>要解决包含重复的警告，您可以手动将资产移动到新的捆绑软件中，或右键单击捆绑软件并选择“移动重复”选项之一。</li></ul></li><li>将资产从“项目资源管理器”拖动到该视图中，以将其添加到选定的包中。仅在仅选择一个捆绑包且资产类型兼容（场景捆绑包上的场景等）时才有效。</li><li>将资产（显式或隐式）从资产列表拖到捆绑包列表中（以将其添加到其他捆绑包或新创建的捆绑包中）。</li><li>右键单击或单击DEL从捆绑中删除资产（不会从项目中删除资产）。</li><li>选择或双击资产以在Project Explorer中显示它们。</li></ul><p>关于将文件夹包括在捆绑包中的说明。可以将资产文件夹（从Project Explorer）分配到捆绑包。在浏览器中查看该文件夹时，该文件夹本身将被列出为显式，而其内容则为隐式。这反映了用于将资产分配到捆绑包的优先级系统。例如，假设您的游戏在Assets / Prefabs中有五个预制件，并且您将文件夹“ Prefabs”标记为一个捆，而将一个实际的预制件（“ PrefabA”）标记为另一个。建成后，“ PrefabA”将放在一个捆绑包中，而其他四个预制件将放在另一个捆绑包中。</p><h3 id="资产明细">资产明细</h3><p>右下方的窗格显示了在“资产列表”窗格中选择的资产的详细信息。该窗格不能与之交互，但如果可用，将显示以下信息：</p><ul><li>资产全路径</li><li>包含在包中的隐式原因（如果是隐式的）。</li><li>警告的原因（如果有）。</li><li>错误原因（如果有）。</li></ul><h3 id="故障排除">故障排除</h3><ul><li>*无法重命名或删除特定的捆绑软件。*有时是在首次将此工具添加到现有项目中时引起的。请通过Unity菜单系统强制重新导入资产以刷新数据。</li></ul><h3 id="外部工具整合">外部工具整合</h3><p>生成资产捆绑包数据的其他工具可以选择与浏览器集成。当前主要的例子是<a href="https://bitbucket.org/Unity-Technologies/assetbundlegraphtool" target="_blank" rel="noopener">资产捆绑图工具</a>。如果检测到集成，则选择栏将出现在浏览器顶部附近。它将允许您选择默认数据源（Unity的AssetDatabase）或集成工具。如果未检测到选择器，则不存在选择器，尽管您可以通过右键单击选项卡标题并选择“自定义来源”来添加选择器。</p><h1>用法-构建</h1><p>“构建”选项卡提供了基本的构建功能，可帮助您开始使用资产捆绑包。在大多数专业场景中，用户最终将需要更高级的构建设置。欢迎所有人使用此工具中的构建代码作为不再满足其需求的自己编写代码的起点。在大多数情况下，此处的选项直接与引擎在<a href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.html" target="_blank" rel="noopener">BuildAssetBundleOptions中</a>期望的选项联系在一起。接口：</p><ul><li><em>构建目标</em> -捆绑包的<em>构建</em>平台</li><li><em>输出路径</em> -保存已构建捆绑包的路径。默认情况下，这是AssetBundles /。您可以手动编辑路径，也可以选择“浏览”。要返回默认的命名约定，请单击“重置”。</li><li><em>清除文件夹</em> -这将在构建之前从构建路径文件夹中删除所有数据。</li><li>*复制到StreamingAssets-*构建完成后，这会将结果复制到Assets / StreamingAssets。这对于测试很有用，但不会在生产中使用。</li><li><em>高级设置</em><ul><li><em>压缩</em> -在无压缩，标准LZMA或基于块的LZ4压缩之间选择。</li><li><em>排除类型信息</em> -不要在资产捆绑包中包含类型信息</li><li><em>强制重建</em> -重建需要构建的捆绑包。这与“清除文件夹”不同，因为此选项不会删除不再存在的捆绑软件。</li><li><em>忽略类型树更改</em> -进行增量构建检查时忽略类型树更改。</li><li><em>附加哈希</em> -将哈希附加到资产包名称。</li><li><em>严格模式</em> -如果在构建过程中报告任何错误，则不允许构建成功。</li><li><em>空运行构建</em> -执行空运行构建。</li></ul></li><li><em>构建</em> -执行构建。</li></ul><h1>用法-检查</h1><p>该选项卡使您可以检查已构建的捆绑软件的内容。</p><h3 id="用法">用法</h3><ul><li>如果使用浏览器进行构建，则将在此处自动添加构建的路径。</li><li>单击“添加文件”或“添加文件夹”以添加要检查的捆绑软件。</li><li>单击每行旁边的“-”以删除该文件或文件夹。注意，您不能删除通过添加文件夹添加的单个文件。</li><li>选择列出的任何捆绑包以查看详细信息：<ul><li>名称</li><li>磁盘大小</li><li>源资产路径-显式添加到此捆绑包中的资产。请注意，对于场景包，此列表不完整。</li><li>高级数据-包括有关预载表，容器（显式资产）和依赖项的信息。</li></ul></li></ul><blockquote><p>参考：<a href="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/index.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该工具使用户可以查看和编辑其Unity项目的资产捆绑包的配置。它将阻止将创建无效捆绑软件的编辑，并通知您现有捆绑软件的任何问题。它还提供了基本的构建功能。&lt;/p&gt;
&lt;p&gt;使用此工具作为选择资产和在检查器中手动设置其资产束的替代方法。可以将其放入任何5.6或更高版本的Unity项目中。它将在&lt;strong&gt;Window&lt;/strong&gt; &amp;gt; &lt;strong&gt;AssetBundle Browser中&lt;/strong&gt;创建一个新的菜单项。捆绑软件配置，构建功能和构建捆绑软件检查在新窗口中分为三个选项卡。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Asset Bundle" scheme="https://longshilin.com/blog/categories/Unity/Asset-Bundle/"/>
    
    
      <category term="UnityDoc" scheme="https://longshilin.com/blog/tags/UnityDoc/"/>
    
      <category term="Unity Asset Bundle" scheme="https://longshilin.com/blog/tags/Unity-Asset-Bundle/"/>
    
  </entry>
  
  <entry>
    <title>Asset Bundle介绍</title>
    <link href="https://longshilin.com/blog/e909ed70.html"/>
    <id>https://longshilin.com/blog/e909ed70.html</id>
    <published>2020-04-11T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>AssetBundle是与主游戏或应用程序分开存储并在运行时加载（或下载的，对于移动和在线应用程序而言）的内容。<br>通过允许客户仅下载和安装所需的部件，这有助于最大程度地减少对网络和系统资源的影响。<br>例如，一家汽车制造商拥有一个VR应用程序，该应用程序允许客户“试驾”车辆，而不希望将所有车辆都包含在应用程序中，<br>这会导致下载和安装的体积过大。<br>资产捆绑包允许客户仅下载他想测试驾驶的车辆，并且其平台可以处理的质量级别。</p><a id="more"></a><h1>AssetBundles的优点</h1><p>AssetBundles也可以用于在发布后更新或添加到内容。<br>这可能包括可下载的内容，限时促销活动或主题内容，例如与假期相关的模型。<br>AssetBundles还允许自动更新，并且可以在项目之间重复使用内容。<br>例如，对于已连接的应用程序，您可以将品牌（例如徽标或介绍性视频）存储为在线AssetBundle。<br>品牌变更时，您只需要更新服务器上的相关AssetBundle。<br>通过远程AssetBundle加载这些资产的应用程序会自动显示更新的内容，而不需要更新。<br>可以对下载这些图形的应用进行预编程，以检查在线AssetBundle中的更改并根据需要更新本地存储的包。</p><h1>变体</h1><p>AssetBundle可以进一步分为多个变体。变体是与其一起存储的AssetBundle的选项或子类。<br>如果您有一个名为Vehicles的AssetBundle，则可能有一个针对汽车的变体，另一个针对卡车的变体。<br>如果将捆绑资产分配给变量，则必须将该捆绑中的所有资产分配给变量。<br>您不能在bundlename.variant中拥有资产，而在bundlename（没有变体）中拥有另一资产，其中bundlename两者相同。</p><p>为了说明使用变体来协助AssetBundle组织的一种用法，假设我们正在为多控制台视频游戏创建教程级别。<br>下表列出了一些说明中可能使用的图形，以向播放器显示要按下的按钮。<br>Controller布局是现代控制台所共有的，但是操作按钮上的标签随平台而异。<br>在此示例中，尽管标签不同，但顶部动作按钮在两个版本的游戏上都执行相同的动作。<br>在我们的代码中，我们将为定向图形加载通用变体，但在运行时将加载包含特定系统按钮或键盘图形的变体。</p><p>资产捆绑包ControlImage的内容<br><img src="https://longshilin.com/images/c033e07b-8bb3-4c9c-b668-cf8968323791_Introduction_to_Asset_Bundles___Figure_01A___Click_here_to_assign.png" alt=""></p><p>或者，假设我们捆绑了按键图片，以用于在跨平台桌面应用程序上训练用户。<br>ConsoleA和ConsoleB可以分别成为Windows和macOS，而TopActionButton可能类似于Ctrl和Cmd。</p><h1>创建一个AssetBundle</h1><p>当前，构建AssetBundles的唯一方法是通过脚本编写。<br>以下脚本将此功能添加到Unity Editor。<br>BuildAssetBundles有三个参数：应在其中创建AssetBundles的目录，<br>非标准构建模式的BuildAssetBundleOption（可选）和AssetBundle的构建目标。<br>在Assets文件夹内创建一个名为<strong>Editor</strong>的文件夹。<br>在编辑器中，创建一个名为CreateAssetBundles的新C＃脚本。<br>双击CreateAssetBundles在Visual Studio中将其打开，然后删除所有内容。<br>输入以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEditor;</span><br><span class="line">using System.IO;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class CreateAssetBundles</span><br><span class="line">&#123;</span><br><span class="line">    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]</span><br><span class="line">    static void BuildAllAssetBundles()</span><br><span class="line">    &#123;</span><br><span class="line">        string assetBundleDirectory = &quot;Assets/StreamingAssets&quot;;</span><br><span class="line">        if (!Directory.Exists(Application.streamingAssetsPath))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(assetBundleDirectory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CreateAssetBundles已完成。<br>保存更改并关闭Visual Studio。<br>在Unity编辑器中，您可以在Asset下拉列表的底部找到一个新选项：Build AssetBundles。</p><h1>CreateAssetBundles 参数</h1><p>在构建AssetBundle之前，必须存在指定的AssetBundle目录。<br>BuildAssetBundleOptions参数是可选的，如果未指定任何内容，则默认为None。<br>一些关键选项是：<br><img src="https://longshilin.com/images/37d2fe36-0fd5-41d8-a33e-c43b9dd44b0e_Introduction_to_Asset_Bundles___Figure_01B___Click_here_to_assign.png" alt=""></p><h1>目标平台选项</h1><p>由于AssetBundles所需的格式和处理方式因平台而异，因此必须使用以下选项之一指定目标平台：<br><img src="https://longshilin.com/images/20200412002438.png" alt=""></p><h1>创建一个简单的AssetBundle</h1><p>为了测试加载AssetBundle，我们将使用单个GameObject创建一个AssetBundle。<br>此工作流程假定您已完成前面的CreateAssetBundles脚本。<br>在项目的文件夹结构中镜像您的AssetBundle组织，可以更轻松地根据需要查找和更新捆绑的资产。</p><ul><li>将一个Sprite拖到您的Assets文件夹中。</li><li>在一个新场景中，创建一个名为BundledSpriteObject的GameObject。</li><li>附加一个Sprite Renderer组件，并从步骤1开始分配您的Sprite。*在Assets中创建一个名为BundledAssets的文件夹。<br>在BundledAssets内，创建一个名为testbundle的文件夹。</li><li>将BundledSpriteObject拖入testbundle并将其从层次结构中删除。</li><li>在“项目”视图中单击BundledSpriteObject以打开其检查器。<br>请特别注意检查器的底部。</li><li>单击AssetBundle旁边的None将BundledSpriteObject分配给AssetBundle。<br><img src="https://longshilin.com/images/20200412010248.png" alt=""></li></ul><h1>加载本地存储的AssetBundle</h1><p>假设没有发生错误，我们准备从本地存储加载AssetBundle。<br>为了方便演示，我们正在Start中加载软件包。<br>在生产中，仅在必要时才加载AssetBundle。<br>在X和Y中将主摄像机的变换位置设置为0。*创建一个名为Loader的新GameObject。<br>创建一个名为BundledObjectLoader的新C＃脚本，并将其附加到Loader。<br>双击BundledObjectLoader在Visual Studio中将其打开。使用下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">public class BundleObjectLoader : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public string assetName = &quot;BundledSpriteObject&quot;;</span><br><span class="line">    public string bundleName = &quot;testbundle&quot;;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundle localAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, bundleName));</span><br><span class="line">        if (localAssetBundle == null)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(&quot;Failed to load AssetBundle!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GameObject asset = localAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br><span class="line">        Instantiate(asset);</span><br><span class="line">        localAssetBundle.Unload(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行当前场景，会看到之前生成的Bundle文件被实例化到场景中。<br><img src="https://longshilin.com/images/20200412010533.png" alt=""></p><p>退出播放模式。<br>从Loader中删除BundledObjectLoader组件。</p><p>用于加载AssetBundle的命令AssetBundle.LoadFromFile是同步的。<br>这意味着直到命令完成其任务（AssetBundle已完全加载）后，它才会返回。<br>对于像我们的示例这样的小捆绑包来说，这很好，但对于更大的东西（如我们在汽车或建筑预可视化程序或AAA视频游戏中可能看到的），<br>这可能会导致帧速率或响应速度下降到不可接受的程度。<br>更好的选择是LoadFromFileAsync，它可以作为协程运行，以使项目在加载AssetBundle时继续运行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.IO;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class BundleLoaderAsync : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public string bundleName = &quot;testbundle&quot;;</span><br><span class="line">    public string assetName = &quot;BundledSpriteObject&quot;;</span><br><span class="line"></span><br><span class="line">    IEnumerator Start()</span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundleCreateRequest asyncBundleRequest = AssetBundle.LoadFromFileAsync(Path.Combine(Application.streamingAssetsPath, bundleName));</span><br><span class="line">        yield return asyncBundleRequest;</span><br><span class="line">        AssetBundle localAssetBundle = asyncBundleRequest.assetBundle;</span><br><span class="line">        if (localAssetBundle == null)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(&quot;Failed to load AssetBundle!&quot;);</span><br><span class="line">            yield break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AssetBundleRequest assetRequest = localAssetBundle.LoadAssetAsync&lt;GameObject&gt;(assetName);</span><br><span class="line">        yield return assetRequest;</span><br><span class="line">        GameObject prefab = assetRequest.asset as GameObject;</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">        localAssetBundle.Unload(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BundleLoaderAsync已完成。<br>保存更改并返回到Unity Editor。<br>按播放。<br>和以前一样，捆绑对象应加载。<br>退出播放模式，并从Loader中删除BundleLoaderAsync。</p><p>从网络下载AssetBundle与从本地存储加载资产非常相似。<br>出于我们的目的，该文件托管在本地Web服务器上的根目录中。<br>创建一个名为BundleWebLoader的C＃脚本，并将其附加到Loader。<br>双击BundleWebLoader在Visual Studio中打开。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class BundleWebLoader : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public string bundleUrl = &quot;http://127.0.0.1:8887/testbundle&quot;;</span><br><span class="line">    public string assetName = &quot;BundledSpriteObject&quot;;</span><br><span class="line"></span><br><span class="line">    IEnumerator Start()</span><br><span class="line">    &#123;</span><br><span class="line">        using (WWW web = new WWW(bundleUrl))</span><br><span class="line">        &#123;</span><br><span class="line">            yield return web;</span><br><span class="line">            AssetBundle remoteAssetBundle = web.assetBundle;</span><br><span class="line">            if (remoteAssetBundle == null)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;Failed to download AssetBundle!&quot;);</span><br><span class="line">                yield break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Instantiate(remoteAssetBundle.LoadAsset(assetName));</span><br><span class="line">            remoteAssetBundle.Unload(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个简单的Chrome扩展名<a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb/related?hl=en" target="_blank" rel="noopener">&quot;200 OK&quot;</a>。<br>它在本地主机上运行Web服务器。</p><p>BundleWebLoader完成。<br>保存更改并返回到Unity Editor。<br>按播放。<br>除非出现任何Web连接问题，否则您应该看到与前两个示例相同的结果。<br>退出播放模式。</p><h1>结尾</h1><p>AssetBundles为开发人员，用户和玩家提供了无数种可能性。<br>您一定会想出新的方法来使它们为您工作，并且掌握它们将使您能够为用户提供更有效，多功能和个性化的体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AssetBundle是与主游戏或应用程序分开存储并在运行时加载（或下载的，对于移动和在线应用程序而言）的内容。&lt;br&gt;
通过允许客户仅下载和安装所需的部件，这有助于最大程度地减少对网络和系统资源的影响。&lt;br&gt;
例如，一家汽车制造商拥有一个VR应用程序，该应用程序允许客户“试驾”车辆，而不希望将所有车辆都包含在应用程序中，&lt;br&gt;
这会导致下载和安装的体积过大。&lt;br&gt;
资产捆绑包允许客户仅下载他想测试驾驶的车辆，并且其平台可以处理的质量级别。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="UnityDoc" scheme="https://longshilin.com/blog/categories/Unity/UnityDoc/"/>
    
    
      <category term="UnityDoc" scheme="https://longshilin.com/blog/tags/UnityDoc/"/>
    
  </entry>
  
  <entry>
    <title>Unity Asset可视化工具</title>
    <link href="https://longshilin.com/blog/423a6a45.html"/>
    <id>https://longshilin.com/blog/423a6a45.html</id>
    <published>2020-04-10T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html#assetgraph-user-manual" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html#assetgraph-user-manual</a></p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html#assetgraph-user-manual&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html#assetgraph-user-manual&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Asset Bundle" scheme="https://longshilin.com/blog/categories/Unity/Asset-Bundle/"/>
    
    
      <category term="Unity Asset" scheme="https://longshilin.com/blog/tags/Unity-Asset/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains中添加模板代码块</title>
    <link href="https://longshilin.com/blog/c13f7a8.html"/>
    <id>https://longshilin.com/blog/c13f7a8.html</id>
    <published>2020-01-01T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中直接添加模板能节省每次新建文件时需要进行的重复工作，并且在任何时候想输入模板内容可以直接输入。</p><a id="more"></a><p>一张图搞定！<br><img src="https://longshilin.com/images/20200412132022.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中直接添加模板能节省每次新建文件时需要进行的重复工作，并且在任何时候想输入模板内容可以直接输入。&lt;/p&gt;
    
    </summary>
    
      <category term="IDE" scheme="https://longshilin.com/blog/categories/IDE/"/>
    
      <category term="JetBrains" scheme="https://longshilin.com/blog/categories/IDE/JetBrains/"/>
    
    
      <category term="JetBrains" scheme="https://longshilin.com/blog/tags/JetBrains/"/>
    
  </entry>
  
  <entry>
    <title>日子很长，但几十年很短</title>
    <link href="https://longshilin.com/blog/f56fc823.html"/>
    <id>https://longshilin.com/blog/f56fc823.html</id>
    <published>2019-10-11T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载至:<a href="https://blog.samaltman.com/the-days-are-long-but-the-decades-are-short" target="_blank" rel="noopener">https://blog.samaltman.com/the-days-are-long-but-the-decades-are-short</a></p></blockquote><p>上周我30岁，一个朋友问我在过去十年中是否想出任何值得延续的生活建议。我有点犹豫，因为我认为这些列表通常看起来很空洞，但这是我的答案的清理版本：</p><a id="more"></a><p>1）切勿将您的家人，朋友或其他重要事项放在优先事项清单上。宁愿几个真正的好朋友而不是一百个熟人。不要失去与老朋友的联系。偶尔熬夜直到太阳升起与人们交谈。开派对。</p><p>2）生活不是彩排，这可能就是事实。让它计数。时间极为有限，而且很快。做些让您快乐和充实的事情-无论如何，很少有人在死后的数百年里被人们铭记。不要做不会让您感到高兴的事情（这种情况通常在其他人希望您做某事时发生）。不要花时间尝试与您不喜欢的人保持关系，并把消极的人排除在您的生活之外。负面影响真的很糟糕。不要让自己为没有做自己想做的事情找借口。</p><p>3）如何成功：选择正确的事情（这很关键，通常被忽略），专注于自己，相信自己（尤其是当别人告诉你这将不起作用时），与可以帮助您的人建立个人联系，学习寻找人才，并努力工作。很难确定要做什么，因为原始想法很难。</p><p>4）在工作中：在您不关心的工作上很难做好。如果您不喜欢自己的工作，就很难完全幸福/充实。非常努力地工作-您选择努力工作的人数量会令人发怒-但不会那么努力，以致您的余生都会过去。无论您做什么专业，都力争成为世界上最好的。即使您错过了，您也可能会留在一个不错的地方。弄清楚自己的生产力系统-不要浪费时间杂乱无章，工作时间不理想等。不要害怕冒某些职业风险，尤其是在早期。大多数人都相当随机地选择自己的职业-认真思考自己喜欢什么，哪些领域将取得成功，并尝试与这些领域的人交谈。</p><p>5）关于金钱：金钱是否可以买到幸福，它可以买到自由，这很重要。另外，缺钱也很压力。几乎在所有方面，拥有足够的钱以使您不必担心付房租，比拥有足够的钱购买自己的喷气机更能改变您的生活。赚钱通常比花钱更有趣，尽管我个人从不后悔自己花在朋友上的钱，新经历，节省时间，旅行和我坚信的事业。</p><p>6）多与人交谈。阅读更多长篇文章，减少推文。少看电视。在互联网上花费更少的时间。</p><p>7）不要浪费时间。大多数人会浪费大部分时间，尤其是在业务上。</p><p>8）不要让自己陷入困境。就像保罗·格雷厄姆（Paul Graham）对我说的那样：“人们会变得可怕，但很难预测谁。” （自信和自大之间有很大的区别。显然，前者的目标是。）</p><p>9）每天，每年和每十年为自己制定明确的目标。</p><p>10）但是，与计划一样有价值，如果有机会，那么就应该抓住机会。不要害怕做一些鲁re的事情。努力工作的好处之一是，机会会随之而来，但是，当他们抓住机会时，仍然要取决于您。</p><p>11）尽力与聪明，有趣，有抱负的人交往。为他们工作并雇用他们（实际上，最令人满意的工作之一就是与真正的好人建立深厚的关系）。尝试与那些在自己的工作上名列世界前茅或极有希望但完全未知的人共处时光。的确，您成为了花费最多时间的人的平均水平。</p><p>12）将注意力分散在无关紧要的事物上，以最大程度地减少自己的认知负担。很难高估这是多么重要，以及大多数人对此有多糟糕。摆脱生活中的干扰。开发非常有力的方法来避免让您不喜欢堆砌而浪费您的精神周期，尤其是在您的工作生活中。</p><p>13）保持低个人燃烧率。仅此一项就可以为您提供很多生活机会。</p><p>14）夏天是最好的。</p><p>15）不要太担心。生活中的事情很少像看起来那样危险。大多数人都过于规避风险，因此大多数建议都偏向保守的道路。</p><p>16）问你想要什么。</p><p>17）如果您认为后悔不做某事，则应该这样做。遗憾是最糟糕的，大多数人后悔没有做的事情比做过的事情更多。如有疑问，请亲吻男孩/女孩。</p><p>18）运动。吃好。睡觉。有规律地进入大自然。</p><p>19）尽力帮助人们。生活中很少有事情能令人满意。对陌生人好。即使没关系，也要保持友善。</p><p>20）青年是一件非常伟大的事情。不要浪费它。实际上，在您20多岁的时候，我认为采取“给我财务纪律，但不仅限于此”的态度还可以。世界上所有的钱永远都不会找回过去的时间。</p><p>21）告诉你的父母你更爱他们。尽可能经常回家。</p><p>22）这也将过去。</p><p>23）学习狂热。</p><p>24）经常做新事物。这似乎非常重要。做新事物不仅会减慢时间感，增加幸福感，并使生活变得有趣，而且还会阻止人们以自己的思维方式进行镇定。力求在您的个人和职业生涯中，每年做一件大事，新颖事和冒险事。</p><p>25）还记得您十几岁的时候曾经多么热爱过您的男朋友吗？现在就强烈地爱他/她。还记得小时候得到的东西多么兴奋和快乐吗？现在就变得兴奋和快乐。</p><p>26）不要拧人，不要烧桥梁。仔细挑选您的战斗。</p><p>27）原谅别人。</p><p>28）不要追逐身份。没有实质的地位不会长期有效，而且无法实现。</p><p>29）大多数事情都可以适度进行。几乎没有什么可以做到的。</p><p>30）存在性焦虑是生活的一部分。在重大人生事件或重大职业里程碑之后尤其明显。它似乎特别影响聪明，有抱负的人。我认为某些人如此努力工作的原因之一是，他们不必花太多时间对此进行思考。你没有这种感觉是错的。你不是一个人。</p><p>31）感恩并保持问题直觉。不要抱怨太多 不要讨厌别人的成功（但要记住，有些人会讨厌你的成功，而你必须学会​​忽略它）。</p><p>32）做一个行动者，而不是一个说话者。</p><p>33）只要有足够的时间，就可以调整几乎任何东西，无论好坏。人类在这方面是了不起的。</p><p>34）在行动前先思考几秒钟。如果生气，请花几分钟的时间。</p><p>35）不要太快地判断别人。您永远不会知道他们的整个故事，以及他们为什么做或不做某事。善解人意。</p><p>36）日子很长，但几十年很短。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载至:&lt;a href=&quot;https://blog.samaltman.com/the-days-are-long-but-the-decades-are-short&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.samaltman.com/the-days-are-long-but-the-decades-are-short&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上周我30岁，一个朋友问我在过去十年中是否想出任何值得延续的生活建议。我有点犹豫，因为我认为这些列表通常看起来很空洞，但这是我的答案的清理版本：&lt;/p&gt;
    
    </summary>
    
      <category term="好文章" scheme="https://longshilin.com/blog/categories/%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="人生" scheme="https://longshilin.com/blog/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>GameFramework框架学习流程</title>
    <link href="https://longshilin.com/blog/b42dd2c7.html"/>
    <id>https://longshilin.com/blog/b42dd2c7.html</id>
    <published>2019-09-21T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客主要解析EventSystem源码，通过调试先实际查看这个类干了什么，然后再来分析其作用。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190921173112.png" alt="ET框架中的DLL程序集合类型"></p><p>通过上面这张图我们不难看出，ET框架中的DLL程序集合总共被分为三种类型：Model | Hotfix | Editor。当你打开ET项目时，解决方案目录也是分为这几个模块（第三方库除外），如下图。</p><p><img src="https://longshilin.com/images/20190921173250.png" alt="ET源码的解决方案目录"></p><p>下面截图中展示的是EventSystem的Add()方法，由项目入口的Init()方法所调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Game.EventSystem.Add(DLLType.Model, typeof(Init).Assembly);</span><br></pre></td></tr></table></figure><p>在这个Add方法中，大概的内容是遍历Model.DLL这个程序集中的所有类，然后从中筛选出以<code>BaseAttribute</code>为基类的类引用，并将其加入到types字典中。其中需要注意的是<code>GetCustomAttributes(Type, Boolean)</code>方法，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/System.Reflection.MemberInfo.GetCustomAttributes?view=netframework-4.7.2" target="_blank" rel="noopener">详见说明</a></p><p><img src="https://longshilin.com/images/20190921172631.png" alt="EventSystem的Add()方法"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客主要解析EventSystem源码，通过调试先实际查看这个类干了什么，然后再来分析其作用。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://longshilin.com/blog/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ET" scheme="https://longshilin.com/blog/categories/%E6%A1%86%E6%9E%B6/ET/"/>
    
    
      <category term="ET" scheme="https://longshilin.com/blog/tags/ET/"/>
    
      <category term="EventSystem" scheme="https://longshilin.com/blog/tags/EventSystem/"/>
    
  </entry>
  
  <entry>
    <title>2019-09-16 -- 09-20 工作日周记</title>
    <link href="https://longshilin.com/blog/2fc7a0ec.html"/>
    <id>https://longshilin.com/blog/2fc7a0ec.html</id>
    <published>2019-09-20T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周工作方面继续进行项目开发，其中比较重要的是释放技能时的需求更改和bug修复</p><p>在学习方面前面三天学习Unity Documentation，后面两天学习ET框架相关知识。</p><a id="more"></a><p>后面还是要保持学习官方文档，每天学习一点 持续渐进，冲鸭！！！</p><p><img src="https://longshilin.com/images/20190921085328.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周工作方面继续进行项目开发，其中比较重要的是释放技能时的需求更改和bug修复&lt;/p&gt;
&lt;p&gt;在学习方面前面三天学习Unity Documentation，后面两天学习ET框架相关知识。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>继续保持</title>
    <link href="https://longshilin.com/blog/73cf67d1.html"/>
    <id>https://longshilin.com/blog/73cf67d1.html</id>
    <published>2019-09-16T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是中秋节过后的第一天上班，虽然中秋节这几天都在忙自己的东西，但是总感觉效率不高，可能是因为没看到什么成果吧。</p><a id="more"></a><p>今天将我需要看的文档用滴答清单罗列了，并且今天看了一部分，明天接着继续，我相信每天看一点，每天进一步点，最终我们会把这个Document啃下来的，因为它实在是太重要了。。。</p><p>:-）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是中秋节过后的第一天上班，虽然中秋节这几天都在忙自己的东西，但是总感觉效率不高，可能是因为没看到什么成果吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>刚刚上路</title>
    <link href="https://longshilin.com/blog/6e1546d4.html"/>
    <id>https://longshilin.com/blog/6e1546d4.html</id>
    <published>2019-09-15T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天上路还在找资料，不过确实收获了几个优质网站，有专门记录开源游戏的，以及学习网站等等。</p><a id="more"></a><p>等到中午睡一觉起来，开始真的看官方文档了，喜欢这个英文 <strong>Unity Documentation</strong></p><p>并且使用chrome插件diigo来记录笔记📒，日后用滴答清单布置任务和打卡。</p><p><img src="https://longshilin.com/images/20190916012317.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天上路还在找资料，不过确实收获了几个优质网站，有专门记录开源游戏的，以及学习网站等等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>折腾一天有一天，什么时候真正开始</title>
    <link href="https://longshilin.com/blog/4e801c8b.html"/>
    <id>https://longshilin.com/blog/4e801c8b.html</id>
    <published>2019-09-14T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天又折腾了一天文档，只学习了一点皮毛。。。</p><a id="more"></a><p>昨天看到一个Unity的官方wiki，然后今天想从头开始着手研究，可是研究到晚上，看完一部分教程后发现这是太基础的教程，而且太久了。。。我看的页面最后更新时间还是2012年，难以置信。</p><p>我现在算是明白了，官方文档才是重中之重，也是我现在需要学习的。熟悉官方文档中的方方面面，足矣！！！</p><p>好了，每一天都在踩坑，踩坑完又入坑。。。我太难了</p><p><img src="https://longshilin.com/images/20190914204641.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又折腾了一天文档，只学习了一点皮毛。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>提问的智慧</title>
    <link href="https://longshilin.com/blog/fb3832f5.html"/>
    <id>https://longshilin.com/blog/fb3832f5.html</id>
    <published>2019-09-14T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><a id="more"></a><p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin" target="_blank" rel="noopener">Gasolin</a> 所翻译版本的最新翻译；</p><p>协助指出翻译问题，<strong>请<a href="https://github.com/ryanhanwu/smartquestions/issues/new" target="_blank" rel="noopener">发 Issue</a>，或直接<a href="https://github.com/ryanhanwu/smartquestions/compare/" target="_blank" rel="noopener">发 Pull Request</a> 给我。</strong></p><p>本文另有<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md" target="_blank" rel="noopener">繁體中文版</a>。</p><h2 id="原文版本历史"><a href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md" target="_blank" rel="noopener">原文版本历史</a></h2><h2 id="目录">目录</h2><ul><li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul><li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#%E7%BD%91%E7%AB%99%E5%92%8C-irc-%E8%AE%BA%E5%9D%9B">网站和 IRC 论坛</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li><li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li><li><a href="#%E7%94%A8%E6%B8%85%E6%99%B0%E6%AD%A3%E7%A1%AE%E7%B2%BE%E5%87%86%E5%B9%B6%E5%90%88%E6%B3%95%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">用清晰、正确、精准并合法语法的语句</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确地描述问题并言之有物</a></li><li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li><li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0-bug">别动辄声称找到 Bug</a></li><li><a href="#%E5%8F%AF%E4%BB%A5%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%BD%86%E8%BF%98%E6%98%AF%E8%A6%81%E5%85%88%E5%81%9A%E5%8A%9F%E8%AF%BE">可以低声下气，但还是要先做功课</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E7%8C%9C%E6%B5%8B">描述问题症状而非猜测</a></li><li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li><li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li><li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确的表达你的问题以及需求</a></li><li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li><li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li><li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li><li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写紧急</a></li><li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul><li><a href="#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li><li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li><li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li><li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li></ul><h2 id="声明">声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介">简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html" target="_blank" rel="noopener">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，&quot;好问题！&quot;是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt" target="_blank" rel="noopener">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前">在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href="http://groups.google.com/" target="_blank" rel="noopener">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时">当你提问时</h2><h3 id="慎选提问的论坛">慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次&quot;扫射&quot;所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="stack-overflow">Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites" target="_blank" rel="noopener">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-irc-论坛">网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步-使用项目邮件列表">第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有&quot;使用者&quot; 也有&quot;开发者&quot;（或&quot;黑客&quot;）邮件列表或论坛，而你又不会动到那些源代码，那么就向&quot;使用者&quot;列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在&quot;使用者&quot; 列表或论坛中几天都没有回复，可以试试前往&quot;开发者&quot;列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题-span-id-bespecific">使用有意义且描述明确的标题<span id="bespecific"></span></h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：<a href="http://X.org" target="_blank" rel="noopener">X.org</a> 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：<a href="http://X.org" target="_blank" rel="noopener">X.org</a> 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 <a href="http://X.org" target="_blank" rel="noopener">X.org</a> 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复">使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html" target="_blank" rel="noopener">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰-正确-精准并语法正确的语句">用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it's</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox" target="_blank" rel="noopener">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD" target="_blank" rel="noopener">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87" target="_blank" rel="noopener">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html" target="_blank" rel="noopener">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物-span-id-beprecise">精确地描述问题并言之有物<span id="beprecise"></span></h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/" target="_blank" rel="noopener">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html" target="_blank" rel="noopener">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精">话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-bug">别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课">低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测">描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状">按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程">描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复">别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求-span-id-explicit">清楚明确的表达你的问题以及需求<span id="explicit"></span></h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时-span-id-code">询问有关代码的问题时<span id="code"></span></h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来">别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句">去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html" target="_blank" rel="noopener">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急">即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪-而且有时还很有帮助-span-id-courtesy">礼多人不怪，而且有时还很有帮助<span id="courtesy"></span></h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后-加个简短的补充说明-span-id-followup">问题解决后，加个简短的补充说明<span id="followup"></span></h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案">如何解读答案</h2><p><a id="RTFM"></a></p><h3 id="rtfm-和-stfw：如何知道你已完全搞砸了">RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href="http://lmgtfy.com/" target="_blank" rel="noopener">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂">如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应">处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html" target="_blank" rel="noopener">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者">如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题">不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com" target="_blank" rel="noopener">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html" target="_blank" rel="noopener">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题">好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答">如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题">如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源">相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/" target="_blank" rel="noopener">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html" target="_blank" rel="noopener">软件发布实践</a>操作。</p><h2 id="鸣谢">鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;提问的智慧&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square&quot; alt=&quot;PRs Welcome&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How To Ask Questions The Smart Way&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen&lt;/p&gt;
&lt;p&gt;本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。&lt;/p&gt;
&lt;p&gt;原文网址：&lt;a href=&quot;http://www.catb.org/~esr/faqs/smart-questions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.catb.org/~esr/faqs/smart-questions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu&lt;/p&gt;
    
    </summary>
    
      <category term="好文章" scheme="https://longshilin.com/blog/categories/%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="提问的智慧" scheme="https://longshilin.com/blog/tags/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
  <entry>
    <title>Unity完全新手指南</title>
    <link href="https://longshilin.com/blog/74df0377.html"/>
    <id>https://longshilin.com/blog/74df0377.html</id>
    <published>2019-09-14T00:00:00.000Z</published>
    <updated>2020-07-19T16:45:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>您好，欢迎来到Unity3D 😃</p><p>如果你被某人指示，那是因为有人认为你：</p><p>在提出问题之前没有完成你的作业，或者<br>正在寻找错误地方的答案，或<br>在你走路之前试图跑步 - 也就是说，提出高级问题但缺乏基本知识才能从任何答案中获益。<br>当然，这个人可能是错的。但是你必须问自己：为什么他们认为你会从阅读中获益？我希望通过阅读本文的其余部分，然后再次阅读您的问题，您将获得答案。如果没有，你应该随便问为什么。</p><p>深呼吸，喝一杯咖啡，做好准备可能需要一段时间，然后才能回答问题。但是，我可以向您保证，如果您查看此处提供的所有信息，您将需要提出更少的问题 - 当您不得不问一个问题时，它会得到比带您到这里的更好的答案！</p><p>轻松？咖啡准备好了吗？优秀的！开始了：</p><a id="more"></a><h1>绝对新手的Unity指南</h1><p>如果你还不太了解，不要感到羞耻。这里的每个人开始时都不太了解。</p><p>现在，在你可以进入几乎完全初学者之前，这实际上是最重要的事情：在你做之前有人遇到过这个问题。事实上，相当多的人，你的问题已经得到了回答！不是半坏啊？</p><p>要找到难以捉摸的答案，这里列出了您在发布之前应该做的事情：<a href="https://longshilin.com/blog/fb3832f5.html">阅读本文！</a></p><p>阅读列表下方的文字！如果你想问一个问题（正确的方式，那就是），它拥有宝贵的信息。</p><p><a href="http://www.google.com/cse/home?cx=001712401338047450041%3Acsfhqk-trfa" target="_blank" rel="noopener">这是一个搜索的好地方</a>  可以直接搜索和Unity相关的任何东西，而且关联性极强，值得一试。</p><p>毕竟这一次还没什么？</p><p>这肯定很糟糕，但你仍然不应该发一个问题。你必须确保你不能…</p><p>帮助自己<br>许多新开发者来到这里，认为他们可以在几周内制作出精彩的游戏。让我从一开始就告诉你：如果你的游戏可以在两周内完成，那么它本来就已经完成了。要制作新游戏，您必须使用不属于教程的脚本 - 或者更确切地说，您必须具备对这些脚本进行简单更改的技能。你绝对必须具备编程的基本知识。如果你不这样做，你的问题将反映出你的无能，你将很难得到你的问题的答案。</p><p>如果您觉得自己不知道如何编码，这些链接将帮助您：</p><p><a href="http://msdn.microsoft.com/en-us/library/aa288436(VS.71).aspx" target="_blank" rel="noopener">微软的初学者话题</a></p><p><a href="http://www.homeandlearn.co.uk/csharp/csharp.html" target="_blank" rel="noopener">彻底的课程</a></p><p>现在你已经掌握了编程的基本知识（？），你仍然需要Unity3D的基本知识 - 代码运行的环境：</p><p><a href="http://unity3d.com/support/documentation/ScriptReference/index.html" target="_blank" rel="noopener">脚本参考</a>仔细阅读每一小节。</p><p>这里有一些其他<a href="http://wiki.unity3d.com/index.php?title=Programming" target="_blank" rel="noopener">编程好东西</a>，我认为值得<a href="http://wiki.unity3d.com/index.php?title=CSharp_Unity_Tutorial" target="_blank" rel="noopener">特别提及。</a> 在左侧的所有链接上看一眼。我敢打赌，至少有一小部分对你有用！</p><p>这是<a href="http://forum.unity3d.com/threads/19302-Scripting-Section-FAQ" target="_blank" rel="noopener">您发布的论坛</a>的<a href="http://forum.unity3d.com/threads/19302-Scripting-Section-FAQ" target="_blank" rel="noopener">常见问题解答。</a>你应该阅读所有的链接和两个帖子 - 它甚至可能有你的具体问题的答案！</p><p><a href="http://unity3d.com/support/resources/tutorials/" target="_blank" rel="noopener">Unity团队的教程</a>我强烈推荐3D平台游戏教程。</p><p><a href="http://www.burgzergarcade.com/hack-slash-rpg-unity3d-game-engine-tutorial" target="_blank" rel="noopener">BurgZerg视频教程</a></p><p><a href="http://www.youtube.com/playlist?list=PL11F87EB39F84E292&amp;feature=plcp" target="_blank" rel="noopener">TornadoTwins视频教程</a></p><p><a href="http://walkerboystudio.com/html/unity_training___free__.html#unity3javaScript" target="_blank" rel="noopener">Walker Boys视频教程</a></p><p>现在，如果您查看了所有这些教程，但仍然没有答案，那么是时候学习…</p><h3 id="如何寻求帮助">如何寻求帮助</h3><p>这里的大多数人都忙于自己的项目，当他们决定花几分钟回答问题时，他们有很多问题可供选择。如果您希望这些忙碌的人选择您的问题，您必须付出一些努力。始终牢记：<em>问题的质量越好，答案的质量就越好。</em></p><p>以下是一些问题从未得到答案的主要原因列表：</p><ul><li><strong>您的问题之前已经多次回答：</strong><br>如果你已经为你的问题提出了一个好的标题（见下文），那么对它进行搜索可能会给你很多好结果。</li></ul><ul><li><strong>您的代码很难阅读：</strong><br>在代码周围使用[code] [/ code]（删除空格），然后使用’Preview Post’按钮确保它漂亮漂亮。这非常重要。</li></ul><ul><li><strong>你的问题不明白：</strong><br>注意用尽可能最好的英语来表达你的问题，检查你的拼写，不要使用你在报纸上找不到的单词。请听下面链接的建议。</li></ul><p>在最简单的形式中，一个好的问题描述了它<strong><em>应该</em></strong>如何工作，然后描述它<strong><em>是</em></strong>如何工作的（发生了意想不到的事情？）。</p><p>如果你能做到这一点，我会说你在家是免费的。问和你会收到！</p><p>如果你认为那有点模糊，你就是对的。这里有一些精选的主题可以帮助你提出很好的问题！</p><p><a href="https://longshilin.com/blog/fb3832f5.html#explicit">我为什么要在乎？</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#bespecific">一个好头衔</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#beprecise">一个很好的描述</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#code">询问代码</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#courtesy">要有礼貌</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#followup">跟进！</a></p><p>最后一个链接的一个非常重要的引用：</p><p><em>“最后，并非最不重要的是，这种跟进有助于所有协助人员对问题感到满意的感觉。如果你自己不是技术人员或黑客，请相信我们这种感觉对于你挖掘的专家和专家来说非常重要寻求帮助。问题叙述可以追溯到未解决的虚无事件;令人沮丧的事情就是令人沮丧;黑客痒痒地看到它们已经解决了。抓住那些痒痒的善意会让你在下次需要提出问题时非常非常有帮助。“</em></p><p>您可能已经注意到这些链接都来自同一个网页。我已经列出了你的基本要素，但你可以通过阅读它来帮助自己。</p><h3 id="结算笔记">结算笔记</h3><p>在离开之前，我应该警告你，大多数经常访问这个论坛的人都可以告诉你是否已经关注这些链接（并阅读它们！）。</p><p>从好的方面来说，他们可以判断你是否遵循这些链接（并阅读它们！）</p><p>如果你已经完成了自己的<strong>学习</strong>，<strong>寻找</strong>并提出一个<strong>好</strong>问题，我保证你会认识到这一点并找时间回答你的问题。</p><p>我祝你在努力中一切顺利，并希望这篇文章能让你走上有朝一日回答问题的道路。😃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您好，欢迎来到Unity3D 😃&lt;/p&gt;
&lt;p&gt;如果你被某人指示，那是因为有人认为你：&lt;/p&gt;
&lt;p&gt;在提出问题之前没有完成你的作业，或者&lt;br&gt;
正在寻找错误地方的答案，或&lt;br&gt;
在你走路之前试图跑步 - 也就是说，提出高级问题但缺乏基本知识才能从任何答案中获益。&lt;br&gt;
当然，这个人可能是错的。但是你必须问自己：为什么他们认为你会从阅读中获益？我希望通过阅读本文的其余部分，然后再次阅读您的问题，您将获得答案。如果没有，你应该随便问为什么。&lt;/p&gt;
&lt;p&gt;深呼吸，喝一杯咖啡，做好准备可能需要一段时间，然后才能回答问题。但是，我可以向您保证，如果您查看此处提供的所有信息，您将需要提出更少的问题 - 当您不得不问一个问题时，它会得到比带您到这里的更好的答案！&lt;/p&gt;
&lt;p&gt;轻松？咖啡准备好了吗？优秀的！开始了：&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Unity Wiki" scheme="https://longshilin.com/blog/categories/Unity/Unity-Wiki/"/>
    
    
      <category term="Unity Beginner Guide" scheme="https://longshilin.com/blog/tags/Unity-Beginner-Guide/"/>
    
  </entry>
  
</feed>
