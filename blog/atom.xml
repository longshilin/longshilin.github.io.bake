<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gamedev</title>
  
  <subtitle>AWS, DevOps, IT Infrastructure, and Other Puzzles</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://longshilin.com/blog/"/>
  <updated>2019-10-06T12:48:12.000Z</updated>
  <id>https://longshilin.com/blog/</id>
  
  <author>
    <name>longshilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-09-16 -- 09-20 工作日周记</title>
    <link href="https://longshilin.com/blog/2fc7a0ec.html"/>
    <id>https://longshilin.com/blog/2fc7a0ec.html</id>
    <published>2019-09-20T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周工作方面继续进行项目开发，其中比较重要的是释放技能时的需求更改和bug修复</p><p>在学习方面前面三天学习Unity Documentation，后面两天学习ET框架相关知识。</p><a id="more"></a><p>后面还是要保持学习官方文档，每天学习一点 持续渐进，冲鸭！！！</p><p><img src="https://longshilin.com/images/20190921085328.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周工作方面继续进行项目开发，其中比较重要的是释放技能时的需求更改和bug修复&lt;/p&gt;
&lt;p&gt;在学习方面前面三天学习Unity Documentation，后面两天学习ET框架相关知识。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Rider构建和集成简单的DLL示例</title>
    <link href="https://longshilin.com/blog/1dbc6beb.html"/>
    <id>https://longshilin.com/blog/1dbc6beb.html</id>
    <published>2019-09-18T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Reference: <a href="https://docs.unity3d.com/Manual/UsingDLL.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/UsingDLL.html</a></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reference: &lt;a href=&quot;https://docs.unity3d.com/Manual/UsingDLL.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.unity3d.com/Manual/UsingDLL.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
    
      <category term="Unity DLL" scheme="https://longshilin.com/blog/tags/Unity-DLL/"/>
    
  </entry>
  
  <entry>
    <title>继续保持</title>
    <link href="https://longshilin.com/blog/73cf67d1.html"/>
    <id>https://longshilin.com/blog/73cf67d1.html</id>
    <published>2019-09-16T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是中秋节过后的第一天上班，虽然中秋节这几天都在忙自己的东西，但是总感觉效率不高，可能是因为没看到什么成果吧。</p><a id="more"></a><p>今天将我需要看的文档用滴答清单罗列了，并且今天看了一部分，明天接着继续，我相信每天看一点，每天进一步点，最终我们会把这个Document啃下来的，因为它实在是太重要了。。。</p><p>:-）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是中秋节过后的第一天上班，虽然中秋节这几天都在忙自己的东西，但是总感觉效率不高，可能是因为没看到什么成果吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>刚刚上路</title>
    <link href="https://longshilin.com/blog/6e1546d4.html"/>
    <id>https://longshilin.com/blog/6e1546d4.html</id>
    <published>2019-09-15T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天上路还在找资料，不过确实收获了几个优质网站，有专门记录开源游戏的，以及学习网站等等。</p><a id="more"></a><p>等到中午睡一觉起来，开始真的看官方文档了，喜欢这个英文 <strong>Unity Documentation</strong></p><p>并且使用chrome插件diigo来记录笔记📒，日后用滴答清单布置任务和打卡。</p><p><img src="https://longshilin.com/images/20190916012317.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天上路还在找资料，不过确实收获了几个优质网站，有专门记录开源游戏的，以及学习网站等等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unity完全新手指南</title>
    <link href="https://longshilin.com/blog/74df0377.html"/>
    <id>https://longshilin.com/blog/74df0377.html</id>
    <published>2019-09-14T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>您好，欢迎来到Unity3D 😃</p><p>如果你被某人指示，那是因为有人认为你：</p><p>在提出问题之前没有完成你的作业，或者<br>正在寻找错误地方的答案，或<br>在你走路之前试图跑步 - 也就是说，提出高级问题但缺乏基本知识才能从任何答案中获益。<br>当然，这个人可能是错的。但是你必须问自己：为什么他们认为你会从阅读中获益？我希望通过阅读本文的其余部分，然后再次阅读您的问题，您将获得答案。如果没有，你应该随便问为什么。</p><p>深呼吸，喝一杯咖啡，做好准备可能需要一段时间，然后才能回答问题。但是，我可以向您保证，如果您查看此处提供的所有信息，您将需要提出更少的问题 - 当您不得不问一个问题时，它会得到比带您到这里的更好的答案！</p><p>轻松？咖啡准备好了吗？优秀的！开始了：</p><a id="more"></a><h1>绝对新手的Unity指南</h1><p>如果你还不太了解，不要感到羞耻。这里的每个人开始时都不太了解。</p><p>现在，在你可以进入几乎完全初学者之前，这实际上是最重要的事情：在你做之前有人遇到过这个问题。事实上，相当多的人，你的问题已经得到了回答！不是半坏啊？</p><p>要找到难以捉摸的答案，这里列出了您在发布之前应该做的事情：<a href="https://longshilin.com/blog/fb3832f5.html">阅读本文！</a></p><p>阅读列表下方的文字！如果你想问一个问题（正确的方式，那就是），它拥有宝贵的信息。</p><p><a href="http://www.google.com/cse/home?cx=001712401338047450041%3Acsfhqk-trfa" target="_blank" rel="noopener">这是一个搜索的好地方</a>  可以直接搜索和Unity相关的任何东西，而且关联性极强，值得一试。</p><p>毕竟这一次还没什么？</p><p>这肯定很糟糕，但你仍然不应该发一个问题。你必须确保你不能…</p><p>帮助自己<br>许多新开发者来到这里，认为他们可以在几周内制作出精彩的游戏。让我从一开始就告诉你：如果你的游戏可以在两周内完成，那么它本来就已经完成了。要制作新游戏，您必须使用不属于教程的脚本 - 或者更确切地说，您必须具备对这些脚本进行简单更改的技能。你绝对必须具备编程的基本知识。如果你不这样做，你的问题将反映出你的无能，你将很难得到你的问题的答案。</p><p>如果您觉得自己不知道如何编码，这些链接将帮助您：</p><p><a href="http://msdn.microsoft.com/en-us/library/aa288436(VS.71).aspx" target="_blank" rel="noopener">微软的初学者话题</a></p><p><a href="http://www.homeandlearn.co.uk/csharp/csharp.html" target="_blank" rel="noopener">彻底的课程</a></p><p>现在你已经掌握了编程的基本知识（？），你仍然需要Unity3D的基本知识 - 代码运行的环境：</p><p><a href="http://unity3d.com/support/documentation/ScriptReference/index.html" target="_blank" rel="noopener">脚本参考</a>仔细阅读每一小节。</p><p>这里有一些其他<a href="http://wiki.unity3d.com/index.php?title=Programming" target="_blank" rel="noopener">编程好东西</a>，我认为值得<a href="http://wiki.unity3d.com/index.php?title=CSharp_Unity_Tutorial" target="_blank" rel="noopener">特别提及。</a> 在左侧的所有链接上看一眼。我敢打赌，至少有一小部分对你有用！</p><p>这是<a href="http://forum.unity3d.com/threads/19302-Scripting-Section-FAQ" target="_blank" rel="noopener">您发布的论坛</a>的<a href="http://forum.unity3d.com/threads/19302-Scripting-Section-FAQ" target="_blank" rel="noopener">常见问题解答。</a>你应该阅读所有的链接和两个帖子 - 它甚至可能有你的具体问题的答案！</p><p><a href="http://unity3d.com/support/resources/tutorials/" target="_blank" rel="noopener">Unity团队的教程</a>我强烈推荐3D平台游戏教程。</p><p><a href="http://www.burgzergarcade.com/hack-slash-rpg-unity3d-game-engine-tutorial" target="_blank" rel="noopener">BurgZerg视频教程</a></p><p><a href="http://www.youtube.com/playlist?list=PL11F87EB39F84E292&amp;feature=plcp" target="_blank" rel="noopener">TornadoTwins视频教程</a></p><p><a href="http://walkerboystudio.com/html/unity_training___free__.html#unity3javaScript" target="_blank" rel="noopener">Walker Boys视频教程</a></p><p>现在，如果您查看了所有这些教程，但仍然没有答案，那么是时候学习…</p><h3 id="如何寻求帮助">如何寻求帮助</h3><p>这里的大多数人都忙于自己的项目，当他们决定花几分钟回答问题时，他们有很多问题可供选择。如果您希望这些忙碌的人选择您的问题，您必须付出一些努力。始终牢记：<em>问题的质量越好，答案的质量就越好。</em></p><p>以下是一些问题从未得到答案的主要原因列表：</p><ul><li><strong>您的问题之前已经多次回答：</strong><br>如果你已经为你的问题提出了一个好的标题（见下文），那么对它进行搜索可能会给你很多好结果。</li></ul><ul><li><strong>您的代码很难阅读：</strong><br>在代码周围使用[code] [/ code]（删除空格），然后使用’Preview Post’按钮确保它漂亮漂亮。这非常重要。</li></ul><ul><li><strong>你的问题不明白：</strong><br>注意用尽可能最好的英语来表达你的问题，检查你的拼写，不要使用你在报纸上找不到的单词。请听下面链接的建议。</li></ul><p>在最简单的形式中，一个好的问题描述了它<strong><em>应该</em></strong>如何工作，然后描述它<strong><em>是</em></strong>如何工作的（发生了意想不到的事情？）。</p><p>如果你能做到这一点，我会说你在家是免费的。问和你会收到！</p><p>如果你认为那有点模糊，你就是对的。这里有一些精选的主题可以帮助你提出很好的问题！</p><p><a href="https://longshilin.com/blog/fb3832f5.html#explicit">我为什么要在乎？</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#bespecific">一个好头衔</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#beprecise">一个很好的描述</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#code">询问代码</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#courtesy">要有礼貌</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#followup">跟进！</a></p><p>最后一个链接的一个非常重要的引用：</p><p><em>“最后，并非最不重要的是，这种跟进有助于所有协助人员对问题感到满意的感觉。如果你自己不是技术人员或黑客，请相信我们这种感觉对于你挖掘的专家和专家来说非常重要寻求帮助。问题叙述可以追溯到未解决的虚无事件;令人沮丧的事情就是令人沮丧;黑客痒痒地看到它们已经解决了。抓住那些痒痒的善意会让你在下次需要提出问题时非常非常有帮助。“</em></p><p>您可能已经注意到这些链接都来自同一个网页。我已经列出了你的基本要素，但你可以通过阅读它来帮助自己。</p><h3 id="结算笔记">结算笔记</h3><p>在离开之前，我应该警告你，大多数经常访问这个论坛的人都可以告诉你是否已经关注这些链接（并阅读它们！）。</p><p>从好的方面来说，他们可以判断你是否遵循这些链接（并阅读它们！）</p><p>如果你已经完成了自己的<strong>学习</strong>，<strong>寻找</strong>并提出一个<strong>好</strong>问题，我保证你会认识到这一点并找时间回答你的问题。</p><p>我祝你在努力中一切顺利，并希望这篇文章能让你走上有朝一日回答问题的道路。😃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您好，欢迎来到Unity3D 😃&lt;/p&gt;
&lt;p&gt;如果你被某人指示，那是因为有人认为你：&lt;/p&gt;
&lt;p&gt;在提出问题之前没有完成你的作业，或者&lt;br&gt;
正在寻找错误地方的答案，或&lt;br&gt;
在你走路之前试图跑步 - 也就是说，提出高级问题但缺乏基本知识才能从任何答案中获益。&lt;br&gt;
当然，这个人可能是错的。但是你必须问自己：为什么他们认为你会从阅读中获益？我希望通过阅读本文的其余部分，然后再次阅读您的问题，您将获得答案。如果没有，你应该随便问为什么。&lt;/p&gt;
&lt;p&gt;深呼吸，喝一杯咖啡，做好准备可能需要一段时间，然后才能回答问题。但是，我可以向您保证，如果您查看此处提供的所有信息，您将需要提出更少的问题 - 当您不得不问一个问题时，它会得到比带您到这里的更好的答案！&lt;/p&gt;
&lt;p&gt;轻松？咖啡准备好了吗？优秀的！开始了：&lt;/p&gt;
    
    </summary>
    
      <category term="Guide to Unity" scheme="https://longshilin.com/blog/categories/Guide-to-Unity/"/>
    
    
      <category term="Unity Beginner Guide" scheme="https://longshilin.com/blog/tags/Unity-Beginner-Guide/"/>
    
  </entry>
  
  <entry>
    <title>提问的智慧</title>
    <link href="https://longshilin.com/blog/fb3832f5.html"/>
    <id>https://longshilin.com/blog/fb3832f5.html</id>
    <published>2019-09-14T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><a id="more"></a><p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin" target="_blank" rel="noopener">Gasolin</a> 所翻译版本的最新翻译；</p><p>协助指出翻译问题，<strong>请<a href="https://github.com/ryanhanwu/smartquestions/issues/new" target="_blank" rel="noopener">发 Issue</a>，或直接<a href="https://github.com/ryanhanwu/smartquestions/compare/" target="_blank" rel="noopener">发 Pull Request</a> 给我。</strong></p><p>本文另有<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md" target="_blank" rel="noopener">繁體中文版</a>。</p><h2 id="原文版本历史"><a href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md" target="_blank" rel="noopener">原文版本历史</a></h2><h2 id="目录">目录</h2><ul><li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul><li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#%E7%BD%91%E7%AB%99%E5%92%8C-irc-%E8%AE%BA%E5%9D%9B">网站和 IRC 论坛</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li><li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li><li><a href="#%E7%94%A8%E6%B8%85%E6%99%B0%E6%AD%A3%E7%A1%AE%E7%B2%BE%E5%87%86%E5%B9%B6%E5%90%88%E6%B3%95%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">用清晰、正确、精准并合法语法的语句</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确地描述问题并言之有物</a></li><li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li><li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0-bug">别动辄声称找到 Bug</a></li><li><a href="#%E5%8F%AF%E4%BB%A5%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%BD%86%E8%BF%98%E6%98%AF%E8%A6%81%E5%85%88%E5%81%9A%E5%8A%9F%E8%AF%BE">可以低声下气，但还是要先做功课</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E7%8C%9C%E6%B5%8B">描述问题症状而非猜测</a></li><li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li><li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li><li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确的表达你的问题以及需求</a></li><li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li><li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li><li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li><li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写紧急</a></li><li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul><li><a href="#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li><li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li><li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li><li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li></ul><h2 id="声明">声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介">简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html" target="_blank" rel="noopener">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，&quot;好问题！&quot;是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt" target="_blank" rel="noopener">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前">在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href="http://groups.google.com/" target="_blank" rel="noopener">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时">当你提问时</h2><h3 id="慎选提问的论坛">慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次&quot;扫射&quot;所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="stack-overflow">Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites" target="_blank" rel="noopener">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-irc-论坛">网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步-使用项目邮件列表">第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有&quot;使用者&quot; 也有&quot;开发者&quot;（或&quot;黑客&quot;）邮件列表或论坛，而你又不会动到那些源代码，那么就向&quot;使用者&quot;列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在&quot;使用者&quot; 列表或论坛中几天都没有回复，可以试试前往&quot;开发者&quot;列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题-span-id-bespecific">使用有意义且描述明确的标题<span id="bespecific"></span></h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：<a href="http://X.org" target="_blank" rel="noopener">X.org</a> 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：<a href="http://X.org" target="_blank" rel="noopener">X.org</a> 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 <a href="http://X.org" target="_blank" rel="noopener">X.org</a> 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复">使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html" target="_blank" rel="noopener">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰-正确-精准并语法正确的语句">用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it's</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox" target="_blank" rel="noopener">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD" target="_blank" rel="noopener">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87" target="_blank" rel="noopener">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html" target="_blank" rel="noopener">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物-span-id-beprecise">精确地描述问题并言之有物<span id="beprecise"></span></h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/" target="_blank" rel="noopener">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html" target="_blank" rel="noopener">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精">话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-bug">别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课">低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测">描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状">按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程">描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复">别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求-span-id-explicit">清楚明确的表达你的问题以及需求<span id="explicit"></span></h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时-span-id-code">询问有关代码的问题时<span id="code"></span></h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来">别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句">去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html" target="_blank" rel="noopener">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急">即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪-而且有时还很有帮助-span-id-courtesy">礼多人不怪，而且有时还很有帮助<span id="courtesy"></span></h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后-加个简短的补充说明-span-id-followup">问题解决后，加个简短的补充说明<span id="followup"></span></h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案">如何解读答案</h2><p><a id="RTFM"></a></p><h3 id="rtfm-和-stfw：如何知道你已完全搞砸了">RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href="http://lmgtfy.com/" target="_blank" rel="noopener">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂">如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应">处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html" target="_blank" rel="noopener">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者">如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题">不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com" target="_blank" rel="noopener">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html" target="_blank" rel="noopener">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题">好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答">如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题">如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源">相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/" target="_blank" rel="noopener">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html" target="_blank" rel="noopener">软件发布实践</a>操作。</p><h2 id="鸣谢">鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;提问的智慧&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square&quot; alt=&quot;PRs Welcome&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How To Ask Questions The Smart Way&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen&lt;/p&gt;
&lt;p&gt;本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。&lt;/p&gt;
&lt;p&gt;原文网址：&lt;a href=&quot;http://www.catb.org/~esr/faqs/smart-questions.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.catb.org/~esr/faqs/smart-questions.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu&lt;/p&gt;
    
    </summary>
    
      <category term="好文章" scheme="https://longshilin.com/blog/categories/%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="提问的智慧" scheme="https://longshilin.com/blog/tags/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
  <entry>
    <title>折腾一天有一天，什么时候真正开始</title>
    <link href="https://longshilin.com/blog/4e801c8b.html"/>
    <id>https://longshilin.com/blog/4e801c8b.html</id>
    <published>2019-09-14T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天又折腾了一天文档，只学习了一点皮毛。。。</p><a id="more"></a><p>昨天看到一个Unity的官方wiki，然后今天想从头开始着手研究，可是研究到晚上，看完一部分教程后发现这是太基础的教程，而且太久了。。。我看的页面最后更新时间还是2012年，难以置信。</p><p>我现在算是明白了，官方文档才是重中之重，也是我现在需要学习的。熟悉官方文档中的方方面面，足矣！！！</p><p>好了，每一天都在踩坑，踩坑完又入坑。。。我太难了</p><p><img src="https://longshilin.com/images/20190914204641.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又折腾了一天文档，只学习了一点皮毛。。。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>该想想奋斗的方向啦</title>
    <link href="https://longshilin.com/blog/493fd4d4.html"/>
    <id>https://longshilin.com/blog/493fd4d4.html</id>
    <published>2019-09-13T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2019年中秋节，就在昨晚我在网上搜寻了一些关于游戏开发的资料，发现能学习到的和应该要学习的东西还有好多好多，但是我现在最需要做的事情是熟悉整个Unity的基础开发流程。</p><p>这其中就包括游戏动画，游戏特效，shader，材质等等。有关于unity本身开发的知识面，需要尽快扩展和熟悉。</p><p>在这之后才是框架层面的东西和服务器相关的东西。</p><p>加油吧骚年！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是2019年中秋节，就在昨晚我在网上搜寻了一些关于游戏开发的资料，发现能学习到的和应该要学习的东西还有好多好多，但是我现在最需要做的事情是熟悉整个Unity的基础开发流程。&lt;/p&gt;
&lt;p&gt;这其中就包括游戏动画，游戏特效，shader，材质等等。有关于unity本身开发的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>比较unity中Update、LateUpdate和FixedUpdate三者的区别</title>
    <link href="https://longshilin.com/blog/f299411.html"/>
    <id>https://longshilin.com/blog/f299411.html</id>
    <published>2019-09-02T22:34:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在进行unity开发游戏时，经常会遇见Update、LateUpdate和FixedUpdate这三者。下面我依照官方文档说明，总结一下三者的区别。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在进行unity开发游戏时，经常会遇见Update、LateUpdate和FixedUpdate这三者。下面我依照官方文档说明，总结一下三者的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="Unity基础入门学习笔记" scheme="https://longshilin.com/blog/categories/Unity/Unity%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Unity" scheme="https://longshilin.com/blog/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>世界</title>
    <link href="https://longshilin.com/blog/c01e72eb.html"/>
    <id>https://longshilin.com/blog/c01e72eb.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>A <code>World</code>拥有<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html" target="_blank" rel="noopener">EntityManager</a>和一组<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_system.html" target="_blank" rel="noopener">ComponentSystems</a>。您可以根据需要创建任意数量的<code>World</code>对象。通常，您将创建模拟<code>World</code>和渲染或演示<code>World</code>。</p><a id="more"></a><p>默认情况下，我们<code>World</code>在进入“ **播放模式”**时创建单个，并使用<code>ComponentSystem</code>项目中的所有可用对象填充它，但您可以禁用默认<code>World</code>创建并通过全局定义将其替换为您自己的代码。</p><ul><li><strong>默认世界创建代码</strong>（参见文件：<em>Packages / com.unity.entities / Unity.Entities.Hybrid / Injection / DefaultWorldInitialization.cs</em>）</li><li><strong>自动引导入口点</strong>（参见文件： <em>Packages / com.unity.entities / Unity.Entities.Hybrid / Injection / AutomaticWorldBootstrap.cs</em>）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A &lt;code&gt;World&lt;/code&gt;拥有&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EntityManager&lt;/a&gt;和一组&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_system.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ComponentSystems&lt;/a&gt;。您可以根据需要创建任意数量的&lt;code&gt;World&lt;/code&gt;对象。通常，您将创建模拟&lt;code&gt;World&lt;/code&gt;和渲染或演示&lt;code&gt;World&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/categories/Unity/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/tags/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>解读GitHub EntityComponentSystemSamples</title>
    <link href="https://longshilin.com/blog/c763759a.html"/>
    <id>https://longshilin.com/blog/c763759a.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>出自Unity官方的ECS项目示例，该项目的第一次Commit是在2018年3月20号，距离现在一年半的时间，这期间ECS本身的生态在快速发展，稳定性也是逐步提升，期待在2020年的Unity版本中作为正式组件发布。好了，下面进入正题~ 对该项目的README做简单翻译和总结。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190811214015.png" alt=""></p><h3 id="欢迎">欢迎</h3><p>欢迎来到DOTS样品资源！</p><p>在这里，您可以找到今天开始使用这些新系统构建所需的资源。</p><p>我们还提供了一个论坛，您可以在其中找到更多信息并与这些新系统分享您的经验。</p><p><a href="https://unity3d.com/performance-by-default" target="_blank" rel="noopener">点击此处访问论坛</a></p><h4 id="什么是面向unity数据的技术堆栈？">什么是面向Unity数据的技术堆栈？</h4><p>我们一直在研究一种新的<strong>高性能多线程系统</strong>，这将使<strong>游戏能够充分利用当今可用的多核处理器而不会出现繁重的编程问题</strong>。面向数据的技术栈包括以下主要系统：</p><ul><li>该<strong>实体组件系统</strong>提供了一种默认编写高性能的代码。</li><li>在<strong>C＃作业系统</strong>提供了一种方法来运行多个CPU内核并行游戏代码</li><li>该<strong>突发编译</strong>一个新的数学感知，后台编译器调整的产生高度优化的机器代码。</li></ul><p>通过这些系统，Unity可以为您正在编译的平台的特定功能生成高度优化的代码。</p><h4 id="entity-component-system">Entity Component System</h4><p>实体组件系统提供了一种更好的游戏设计方法，使您可以专注于您正在解决的实际问题：组成游戏的数据和行为。它利用C＃Job System和Burst Compiler使您能够充分利用当今的多核处理器。从面向对象的设计转向面向数据的设计使您可以更轻松地重用代码，并使其他人更容易理解和处理代码。</p><p>实体组件系统作为实验包提供，目前支持Unity 2018.3及更高版本。重要的是要强调实体组件系统不是生产就绪的。<em>（译者注：ECS目前是预览版发布，其稳定性还不能应用于生产环境~）</em></p><h4 id="c-job-system">C# Job System</h4><p>新的C＃作业系统以安全简便的方式利用多个核心。简单，因为它旨在将此方法打开到用户脚本，并允许您编写安全，快速，有效的代码，同时提供保护，以防止多线程的一些陷阱，如竞争条件。</p><p>C＃作业系统是Unity 2018.1+中包含的内置模块。</p><p><a href="https://github.com/stella3d/job-system-cookbook" target="_blank" rel="noopener">可以在此处找到有关C＃作业系统的更多示例项目</a></p><h4 id="burst">Burst</h4><p>Burst是一种新的基于LLVM的数学感知后端编译器。它将C＃作业编译为高度优化的机器代码，利用您正在编译的平台的特定功能。</p><p>Burst是一个实验包，目前支持Unity 2018.3及更高版本。重要的是要强调Burst没有准备好生产。</p><p><a href="https://youtu.be/tGmnZdY5Y-E" target="_blank" rel="noopener">观看Joachim Ante在Unite Austin展示这些新系统</a></p><h4 id="样例">样例</h4><p>为了帮助您入门，我们提供了此示例存储库，用于学习如何大规模编写系统。</p><h5 id="hellocube">HelloCube</h5><p>这是一组展示Unity ECS架构绝对基础的项目：</p><ul><li><strong>ForEach</strong> - 创建一对旋转立方体。此示例演示了使用System和Components分离数据和行为。</li><li><strong>IJobForEach</strong> - 使用基于作业的系统构建在ForEach示例上。基于IJobForEach的系统是推荐的方法，可以利用可用的CPU内核。</li><li><strong>IJobChunk</strong> - 演示如何使用IJobChunk编写系统。IJobChunk是处理组件的推荐方法，用于比简单IJobForEach可以描述的更复杂的情况。</li><li><strong>SubScene</strong> - 演示如何在Unity编辑器中使用SubScenes创建和修改实体。</li><li><strong>SpawnFromMonoBehaviour</strong> - 演示如何基于Prefab GameObject从MonoBehaviour函数中生成多个实体。</li><li><strong>SpawnFromEntity</strong> - 演示如何使用系统中的生成作业在运行时生成多个实体。</li><li><strong>FluentQuery</strong> - 演示如何使用流畅查询来选择要更新的正确实体集。</li><li><strong>SpawnAndRemove</strong> - 演示产生和从世界中删除实体。</li></ul><h5 id="boids">Boids</h5><p>Boids示例提供了包含数千个实体的更复杂场景。Boids模拟水下场景，鲨鱼和学校包含数千条鱼。（它使用经典的Boids植绒算法来教育鱼类行为。）</p><h4 id="空白ecs项目安装指南">空白ECS项目安装指南</h4><ol><li>打开Unity编辑器（<code>2019.1.0f1</code>或更高版本）</li><li>创建一个新项目。</li><li>打开包管理器（菜单：<strong>Window</strong> &gt; <strong>Package Manager</strong>）。</li><li>单击窗口顶部的“ **高级”**按钮，然后启用“ **显示预览包”**选项。</li><li>将以下包添加到项目中：</li></ol><ul><li>Entities</li><li>Hybrid.Renderer</li></ul><p>将实体包添加到项目中还会添加以下包：</p><ul><li>Burst</li><li>Collections</li><li>Jobs</li><li>Mathematics</li></ul><p>**注意：**您可以使用<a href="https://unity3d.com/get-unity/download" target="_blank" rel="noopener">Unity Hub</a>在同一台计算机上安装多个版本的Unity。</p><h4 id="文档">文档</h4><p>寻找有关如何入门或具体问题的信息？访问我们的ECS和工作系统文档。</p><p><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/ECSSamples/Documentation/index.md" target="_blank" rel="noopener">转到ECS Samples文档</a></p><p><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/UnityPhysicsSamples/Documentation/samples.md" target="_blank" rel="noopener">转到Unity Physics Samples文档</a></p><p>（原文链接：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/README.md" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/README.md</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出自Unity官方的ECS项目示例，该项目的第一次Commit是在2018年3月20号，距离现在一年半的时间，这期间ECS本身的生态在快速发展，稳定性也是逐步提升，期待在2020年的Unity版本中作为正式组件发布。好了，下面进入正题~ 对该项目的README做简单翻译和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>什么是ECS？</title>
    <link href="https://longshilin.com/blog/1bcc4240.html"/>
    <id>https://longshilin.com/blog/1bcc4240.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><img src="https://longshilin.com/images/20190811211342.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;https://longshilin.com/images/20190811211342.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>实体</title>
    <link href="https://longshilin.com/blog/f345f685.html"/>
    <id>https://longshilin.com/blog/f345f685.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>实体是实体组件系统体系结构的三个主要元素之一。它们代表游戏或程序中的个人“事物”。一个实体既没有行为也没有数据; 相反，它识别哪些数据属于一起。<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">系统</a>提供行为，<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a>存储数据。</p><a id="more"></a><p>实体本质上是一个ID。您可以将其视为一个超级轻量级<a href="https://docs.unity3d.com/Manual/class-GameObject.html" target="_blank" rel="noopener">GameObject</a>，默认情况下甚至没有名称。实体ID是稳定的。它们是存储对另一个组件或实体的引用的唯一稳定方式。</p><p>一个<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html" target="_blank" rel="noopener">EntityManager</a>管理一个<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.World.html" target="_blank" rel="noopener">世界</a>中的所有实体。EntityManager维护实体列表并组织与实体关联的数据以获得最佳性能。</p><p>虽然实体没有类型，但实体组可以根据与它们相关联的数据组件的类型进行分类。在创建实体并向其添加组件时，EntityManager会跟踪现有实体上组件的唯一组合。这种独特的组合称为<em>原型</em>。在向实体添加组件时，EntityManager会创建<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityArchetype.html" target="_blank" rel="noopener">EntityArchetype</a>结构。您可以使用现有的EntityArchetypes来创建符合该原型的新实体。您还可以提前创建EntityArchetype并使用它来创建实体。</p><h4 id="创建实体">创建实体</h4><p>创建实体的最简单方法是使用Unity编辑器。您可以设置放置在场景中的游戏对象和要在运行时转换为实体的预制件。对于游戏或程序的更多动态部分，您可以创建在作业中创建多个实体的衍生系统。最后，您可以使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">EntityManager.CreateEntity</a>函数之一一次创建一个实体。</p><h5 id="使用entitymanager创建实体">使用EntityManager创建实体</h5><p>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">EntityManager.CreateEntity</a>函数之一来创建实体。实体在与EntityManager相同的World中创建。</p><p>您可以通过以下方式逐个创建实体：</p><ul><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.ComponentType.html" target="_blank" rel="noopener">ComponentType</a>对象数组创建包含组件的实体。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityArchetype.html" target="_blank" rel="noopener">EntityArchetype</a>创建包含组件的实体。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_" target="_blank" rel="noopener">Instantiate</a>复制现有实体（包括其当前数据）</li><li>创建一个没有组件的实体，然后向其中添加组件。（您可以立即添加组件，也可以添加其他组件。）</li></ul><p>您也可以一次创建多个实体：</p><ul><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">CreateEntity</a>使用具有相同原型的新实体填充NativeArray 。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_" target="_blank" rel="noopener">Instantiate</a>向NativeArray填充现有实体的副本，包括其当前数据。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateChunk_" target="_blank" rel="noopener">CreateChunk</a>显式创建使用给定原型填充指定数量的实体的块。</li></ul><h4 id="添加和删除组件">添加和删除组件</h4><p>创建实体后，可以添加或删除组件执行此操作时，受影响实体的原型会发生变化，EntityManager必须将更改的数据移动到新的内存块，并在原始块中压缩组件数组。</p><p>导致结构更改的实体的更改（即添加或删除更改SharedComponentData的值的组件以及销毁实体）无法在Job内部完成，因为这些操作可能会使Job正在处理的数据无效。而是添加命令以对<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityCommandBuffer.html" target="_blank" rel="noopener">EntityCommandBuffer</a>进行这些类型的更改，并在Job完成后执行此命令缓冲区。</p><p>EntityManager提供了从单个实体以及NativeArray中的所有实体中删除组件的功能。有关更多信息，请参阅<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a></p><h4 id="迭代实体">迭代实体</h4><p>迭代具有匹配组件集的所有实体，是ECS体系结构的核心。请参阅<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html" target="_blank" rel="noopener">访问实体数据</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实体是实体组件系统体系结构的三个主要元素之一。它们代表游戏或程序中的个人“事物”。一个实体既没有行为也没有数据; 相反，它识别哪些数据属于一起。&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;系统&lt;/a&gt;提供行为，&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;组件&lt;/a&gt;存储数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/categories/Unity/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/tags/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>HelloCube</title>
    <link href="https://longshilin.com/blog/8282d3d8.html"/>
    <id>https://longshilin.com/blog/8282d3d8.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>此示例演示了一个简单的ECS系统，它可以旋转一对立方体。</p><a id="more"></a><h4 id="它显示了什么？">它显示了什么？</h4><p>此示例演示了ECS中数据和功能的分离。<br>数据存储在组件中，如下RadiansPerSecond属性存储在RotationSpeed_ForEach组件中， 该结构体数据组件有[Serializable]修饰符，表示实例化属性。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line"> [<span class="meta">Serializable</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">struct</span> RotationSpeed_ForEach : IComponentData</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">float</span> RadiansPerSecond;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而功能则写入系统，如下<strong>RotationSpeedSystem_ForEach</strong> 使用存储在 <strong>RotationSpeed_ForEach</strong> 组件中的<em>data</em>更新对象的旋转。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This system updates all entities in the scene with both a RotationSpeed_ForEach and Rotation component.</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedSystem_ForEach</span> : <span class="title">ComponentSystem</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>     &#123;</span><br><span class="line">         <span class="comment">// Entities.ForEach processes each set of ComponentData on the main thread. This is not the recommended</span></span><br><span class="line">         <span class="comment">// method for best performance. However, we start with it here to demonstrate the clearer separation</span></span><br><span class="line">         <span class="comment">// between ComponentSystem Update (logic) and ComponentData (data).</span></span><br><span class="line">         <span class="comment">// There is no update logic on the individual ComponentData.</span></span><br><span class="line">         Entities.ForEach((<span class="keyword">ref</span> RotationSpeed_ForEach rotationSpeed, <span class="keyword">ref</span> Rotation rotation) =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">var</span> deltaTime = Time.deltaTime;</span><br><span class="line">             rotation.Value = math.mul(math.normalize(rotation.Value),</span><br><span class="line">                 quaternion.AxisAngle(math.up(), rotationSpeed.RadiansPerSecond * deltaTime));</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="componentsystems和entities-foreach">ComponentSystems和Entities.ForEach</h4><p>RotationSpeedSystem_ForEach是一个ComponentSystem，它使用Entities.ForEach委托来遍历实体。<br>此示例仅创建单个实体，但如果向场景添加了更多实体，则RotationSpeedSystem_ForEach会更新所有实体 - 只要它们具有RotationSpeed_ForEach组件（并且在将GameObject的Transform转换为ECS组件时添加了旋转组件）。<br>请注意，使用Entities.ForEach的ComponentSystems在主线程上运行。<br>要利用多个内核，可以使用JobComponentSystem（如下一个HelloCube示例所示）。</p><h4 id="从gameobject转换为entity">从GameObject转换为Entity</h4><p><strong>ConvertToEntity</strong> MonoBehaviour在Awake时将GameObject及其子节点转换为实体和ECS组件。<br>目前，ConvertToEntity可以转换的内置Unity MonoBehaviours集包括Transform和MeshRenderer。<br>您可以使用<strong>实体调试器</strong>（菜单：<strong>窗口</strong>&gt; <strong>分析</strong>&gt; <strong>实体调试器</strong>）来检查转换创建的ECS实体和组件。<br>您可以在自己的MonoBehaviours上实现IConvertGameObjectEntity接口，以提供ConvertToEntity用于将存储在MonoBehavi中的数据转换为ECS组件的转换函数。<br>在此示例中， <strong>RotationSpeedAuthoring_ForEach</strong> MonoBehaviour使用IConvertGameObjectEntity在转换时将RotationSpeed_ForEach组件添加到实体。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"> <span class="keyword">using</span> Unity.Entities;</span><br><span class="line"> <span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"> <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"> [<span class="meta">RequiresEntityConversion</span>]</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedAuthoring_ForEach</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">float</span> DegreesPerSecond;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// The MonoBehaviour data is converted to ComponentData on the entity.</span></span><br><span class="line">​     <span class="comment">// We are specifically transforming from a good editor representation of the data (Represented in degrees)</span></span><br><span class="line">​     <span class="comment">// To a good runtime representation (Represented in radians)</span></span><br><span class="line">​     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function">​</span>     &#123;</span><br><span class="line">​         <span class="keyword">var</span> data = <span class="keyword">new</span> RotationSpeed_ForEach &#123; RadiansPerSecond = math.radians(DegreesPerSecond) &#125;;</span><br><span class="line">​         dstManager.AddComponentData(entity, data);</span><br><span class="line">​     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="hellocube-1b-foreachwithentitychanges">HelloCube_1b_ForEachWithEntityChanges</h3><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要更新的正确实体集。然后它在ForEach lambda函数内部修改这些实体。</p><p>该示例定义了两个标记组件，名为MovingCube_ForEachWithEntityChanges和MoveUp_ForEachWithEntityChanges。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> MoveUp_ForEachWithEntityChanges : IComponentData</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MoveUp is a "tag" component and contains no data. Tag components can be used to mark entities that a system should process.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Serializable attribute is for editor support.</span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> MovingCube_ForEachWithEntityChanges : IComponentData</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// MovingCube_ForEachWithEntityChanges is a "tag" component and contains no data.</span></span><br><span class="line">        <span class="comment">// Tag components can be used to mark entities that a system should process.</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>系统中的一个查询选择同时具有MoveUp_ForEachWithEntityChanges组件和Translation组件的所有实体。与此查询关联的ForEach lambda函数向上移动每个选定的实体，直到达到某个高度时，该函数将删除MoveUp_ForEachWithEntityChanges组件，以便下次系统更新时，将不会选择该实体，因此它不会向上移动任何更远的位置。</p><p>第二个查询选择具有Translation组件但没有MoveUp_ForEachWithEntityChanges组件的所有实体。与第二个查询关联的ForEach函数将实体向下移动到其起始位置，并添加新的MoveUp_ForEachWithEntityChanges组件。由于实体再次具有MoveUp_ForEachWithEntityChanges组件，因此下次系统更新时，实体将被第一个ForEach函数向上移动并被第二个查询跳过。</p><p>MovingCube_ForEachWithEntityChanges是一个标记组件，用于确保系统仅适用于为此示例标记的组件。示例中的两个查询都需要MovingCube_ForEachWithEntityChanges组件。</p><h4 id="它显示了什么？-v2">它显示了什么？</h4><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要向上移动的一组实体。当它们达到一定高度时，系统会删除一个组件并使用另一个查询在较低的高度重新生成它们。它还演示了使用“标签”组件来提供选择具有待处理标记组件的特定entite组的方法。最后，此示例演示了如何在ForEach lambda函数内修改实体。</p><h4 id="组件系统和实体-foreach">组件系统和实体.ForEach</h4><p>MovementSystem_ForEachWithEntityChanges是一个ComponentSystem，它使用Entities.ForEach lambda函数迭代实体。此示例使用WithAll和WithNone约束来选择要处理的特定实体集。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">using</span> Unity.Entities;</span><br><span class="line"> <span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"> <span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"> <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Samples.HelloCube_1b</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">// This system updates all entities in the scene with Translation components.</span></span><br><span class="line">     <span class="comment">// It treats entities differently depending on whether or not they also have a MoveUp component.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MovementSystem_ForEachWithEntityChanges</span> : <span class="title">ComponentSystem</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>         &#123;</span><br><span class="line">             <span class="comment">// If a MoveUp component is present, then the system updates the Translation component to move the entity upwards.</span></span><br><span class="line">             <span class="comment">// Once the entity reaches a predetermined height, the function removes the MoveUp component.</span></span><br><span class="line">             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges, MoveUp_ForEachWithEntityChanges&gt;().ForEach(</span><br><span class="line">                 (Entity id, <span class="keyword">ref</span> Translation translation) =&gt;</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">var</span> deltaTime = Time.deltaTime;</span><br><span class="line">                     translation = <span class="keyword">new</span> Translation()</span><br><span class="line">                     &#123;</span><br><span class="line">                         Value = <span class="keyword">new</span> float3(translation.Value.x, translation.Value.y + deltaTime, translation.Value.z)</span><br><span class="line">                     &#125;;</span><br><span class="line"></span><br><span class="line">​                    <span class="keyword">if</span> (translation.Value.y &gt; <span class="number">10.0f</span>)</span><br><span class="line">​                         EntityManager.RemoveComponent&lt;MoveUp_ForEachWithEntityChanges&gt;(id);</span><br><span class="line">​                 &#125;</span><br><span class="line">​             );</span><br><span class="line"></span><br><span class="line">​            <span class="comment">// If an entity does not have a MoveUp component (but does have a Translation component),</span></span><br><span class="line">​             <span class="comment">// then the system moves the entity down to its starting point and adds a MoveUp component.</span></span><br><span class="line">​             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges&gt;().WithNone&lt;MoveUp_ForEachWithEntityChanges&gt;().ForEach(</span><br><span class="line">​                 (Entity id, <span class="keyword">ref</span> Translation translation) =&gt;</span><br><span class="line">​                 &#123;</span><br><span class="line">​                     translation = <span class="keyword">new</span> Translation()</span><br><span class="line">​                     &#123;</span><br><span class="line">​                         Value = <span class="keyword">new</span> float3(translation.Value.x, <span class="number">-10.0f</span>, translation.Value.z)</span><br><span class="line">​                     &#125;;</span><br><span class="line"></span><br><span class="line">​                    EntityManager.AddComponentData(id, <span class="keyword">new</span> MoveUp_ForEachWithEntityChanges());</span><br><span class="line">​                 &#125;</span><br><span class="line">​             );</span><br><span class="line">​         &#125;</span><br><span class="line">​     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意：使用Entities.ForEach的组件系统在主线程上运行。要利用多个内核，可以使用JobComponentSystem（如其他HelloCube示例所示）。这也允许更改ForEach lambda函数内的实体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此示例演示了一个简单的ECS系统，它可以旋转一对立方体。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/tags/ECS-Samples/"/>
    
  </entry>
  
  <entry>
    <title>组件</title>
    <link href="https://longshilin.com/blog/34778b46.html"/>
    <id>https://longshilin.com/blog/34778b46.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>组件是实体组件系统体系结构的三个主要元素之一。它们代表您的游戏或程序的数据。实体本质上是标识符，用于索引组件集合。系统提供行为。</p><a id="more"></a><p>具体地说，ECS中的组件是具有以下“标记接口”之一的结构：</p><p>IComponentData<br>ISharedComponentData<br>ISystemStateComponentData<br>ISharedSystemStateComponentData<br>EntityManager将实体上出现的组件的唯一组合组织到Archetypes中。它将具有相同原型的所有实体的组件一起存储在名为Chunks的内存块中。给定Chunk中的实体都具有相同的组件原型。</p><p>共享组件是一种特殊的数据组件，您可以使用它来根据共享组件中的特定值（除了它们的原型之外）细分实体。将共享组件添加到实体时，EntityManager将具有相同共享数据值的所有实体放入同一块中。共享组件允许您的系统一起处理类似的实体。例如，共享组件Rendering.RenderMesh是Hybrid.rendering包的一部分，它定义了几个字段，包括mesh，material，receiveShadows等。渲染时，最有效的是处理所有具有相同值的3D对象。由于这些属性是在共享组件中指定的，因此EntityManager将匹配的实体放在内存中，以便呈现系统可以有效地迭代它们。</p><p>注意：过度使用共享组件会导致较差的块利用率，因为它涉及基于原型和每个共享组件字段的每个唯一值组合扩展所需的内存块数。避免向共享组件添加不必要的字段，使用Entity Debugger查看当前的Chunk利用率。</p><p>如果从实体添加或删除组件，或更改SharedComponent的值，EntityManager会将实体移动到其他Chunk，必要时创建新Chunk。</p><p>系统状态组件的行为类似于普通组件或共享组件，但在销毁实体时，EntityManager不会删除任何系统状态组件，也不会在删除实体ID之前回收它们。这种行为差异允许系统在销毁实体时清理其内部状态或释放资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件是实体组件系统体系结构的三个主要元素之一。它们代表您的游戏或程序的数据。实体本质上是标识符，用于索引组件集合。系统提供行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/categories/Unity/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/tags/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>实体组件系统</title>
    <link href="https://longshilin.com/blog/68fc35ba.html"/>
    <id>https://longshilin.com/blog/68fc35ba.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>栏目概述</strong></p><a id="more"></a><ul><li>Core ECS<ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_entities.html" target="_blank" rel="noopener">Entities</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/world.html" target="_blank" rel="noopener">Worlds</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">Components</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_data.html" target="_blank" rel="noopener">General Purpose Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/shared_component_data.html" target="_blank" rel="noopener">Shared Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/system_state_components.html" target="_blank" rel="noopener">System State Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/dynamic_buffers.html" target="_blank" rel="noopener">Dynamic Buffer Components</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">System</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_system.html" target="_blank" rel="noopener">Component Systems</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/job_component_system.html" target="_blank" rel="noopener">Job Component Systems</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_command_buffer.html" target="_blank" rel="noopener">Entity Command Buffers</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/system_update_order.html" target="_blank" rel="noopener">System Update Order</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html" target="_blank" rel="noopener">Accessing Entity Data</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_iteration_job.html" target="_blank" rel="noopener">Using IJobForEach</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration_job.html" target="_blank" rel="noopener">Using IJobChunk</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_iteration_foreach.html" target="_blank" rel="noopener">Using ComponentSystem and ForEach</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/manual_iteration.html" target="_blank" rel="noopener">Manual iteration</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_group.html" target="_blank" rel="noopener">Component Groups</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_write_groups.html" target="_blank" rel="noopener">Component WriteGroups</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/version_numbers.html" target="_blank" rel="noopener">Versions and Generations</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_job_overview.html" target="_blank" rel="noopener">Jobs in ECS</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_job_extensions.html" target="_blank" rel="noopener">ECS Job System extensions</a></li></ul></li></ul></li><li>Creating Gameplay<ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/transform_system.html" target="_blank" rel="noopener">Transforms</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/gp_rendering.html" target="_blank" rel="noopener">Rendering</a></li></ul></li></ul><p>实体组件系统（ECS）是Unity数据导向技术堆栈的核心。顾名思义，ECS有三个主要部分：</p><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_entities.html" target="_blank" rel="noopener">实体</a> - 填充您的游戏或程序的实体或事物</li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a> - 与您的实体关联的数据，但由数据本身而不是按实体组织。（这种组织差异是面向对象和面向数据的设计之间的关键差异之一。）</li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">系统</a> - 将组件数据从其当前状态转换到其下一状态的逻辑 - 例如，系统可以通过其速度乘以自前一帧以来的时间间隔来更新所有移动实体的位置。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;栏目概述&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/categories/Unity/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
    
      <category term="ECS手册和脚本参考" scheme="https://longshilin.com/blog/tags/ECS%E6%89%8B%E5%86%8C%E5%92%8C%E8%84%9A%E6%9C%AC%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>C＃作业系统中的安全系统</title>
    <link href="https://longshilin.com/blog/70ae4a2e.html"/>
    <id>https://longshilin.com/blog/70ae4a2e.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="比赛条件">比赛条件</h4><p>编写<a href="https://docs.unity3d.com/Manual/JobSystemMultithreading.html" target="_blank" rel="noopener">多线程代码时</a>，总是存在<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞争条件</a>的风险。当一个操作的输出取决于其控制之外的另一个过程的定时时，发生竞争条件。</p><p>竞争条件并不总是一个错误，但它是不确定行为的来源。当竞争条件确实导致错误时，可能很难找到问题的根源，因为它取决于时间，因此您只能在极少数情况下重新创建问题。调试它可能会导致问题消失，因为断点和日志记录可以改变单个线程的时间。竞争条件是编写多线程代码时最重大的挑战。</p><a id="more"></a><h4 id="安全系统">安全系统</h4><p>为了更容易编写多线程代码，Unity C＃作业系统可以检测所有潜在的竞争条件，并保护您免受可能导致的错误的影响。</p><p>例如：如果C＃作业系统将主线程中代码中的数据<a href="https://docs.microsoft.com/en-us/cpp/cpp/references-cpp" target="_blank" rel="noopener">引用</a>发送到作业，则无法验证主线程是否在作业写入数据的同时读取数据。此方案会创建竞争条件。</p><p>C＃作业系统通过向每个作业发送它需要操作的数据的副本来解决这个问题，而不是对主线程中的数据的引用。此副本隔离数据，从而消除竞争条件。</p><p>C＃作业系统复制数据的方式意味着作业只能访问<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable数据类型</a>。在<a href="https://en.wikipedia.org/wiki/Managed_code" target="_blank" rel="noopener">托管</a>代码和本机代码之间传递时，这些类型不需要转换。</p><p>C＃Job System可以使用<a href="http://www.cplusplus.com/reference/cstring/memcpy/" target="_blank" rel="noopener">memcpy</a>复制blittable类型，并在Unity的托管和本机部分之间传输数据。它用于<code>memcpy</code>在调度作业时将数据放入本机内存，并在执行作业时为受管方提供对该副本的访问权限。有关更多信息，请参阅<a href="https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html" target="_blank" rel="noopener">计划作业</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;比赛条件&quot;&gt;比赛条件&lt;/h4&gt;
&lt;p&gt;编写&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemMultithreading.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多线程代码时&lt;/a&gt;，总是存在&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;竞争条件&lt;/a&gt;的风险。当一个操作的输出取决于其控制之外的另一个过程的定时时，发生竞争条件。&lt;/p&gt;
&lt;p&gt;竞争条件并不总是一个错误，但它是不确定行为的来源。当竞争条件确实导致错误时，可能很难找到问题的根源，因为它取决于时间，因此您只能在极少数情况下重新创建问题。调试它可能会导致问题消失，因为断点和日志记录可以改变单个线程的时间。竞争条件是编写多线程代码时最重大的挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>C＃作业系统提示和故障排除</title>
    <link href="https://longshilin.com/blog/feab267f.html"/>
    <id>https://longshilin.com/blog/feab267f.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Unity C＃作业系统时，请确保遵守以下内容：</p><h4 id="不要从作业访问静态数据">不要从作业访问静态数据</h4><p>从作业访问静态数据会绕过所有安全系统。如果您访问错误的数据，您可能会以意想不到的方式崩溃Unity。例如，访问<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank" rel="noopener">MonoBehaviour</a>可能会导致域重新加载崩溃。</p><p><strong>注意</strong>：由于存在这种风险，Unity的未来版本将阻止使用<a href="https://www.youtube.com/watch?v=VxeC7WFfg3Q" target="_blank" rel="noopener">静态分析</a>从作业进行全局变量访问。如果您确实访问作业中的静态数据，则应该期望您的代码在Unity的未来版本中中断。</p><a id="more"></a><h4 id="刷新预定批次">刷新预定批次</h4><p>如果希望作业开始执行，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html" target="_blank" rel="noopener">JobHandle.ScheduleBatchedJobs</a>刷新计划批处理。请注意，调用此方法会对性能产生负面影响。不刷新批处理会延迟调度，直到主线程等待结果。在所有其他情况下，使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.Complete.html" target="_blank" rel="noopener">JobHandle.Complete</a>来启动执行过程。</p><p><strong>注意</strong>：在<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">实体组件系统</a>（ECS）中，将为您隐式刷新批处理，因此<code>JobHandle.ScheduleBatchedJobs</code>不需要调用。</p><h4 id="不要尝试更新nativecontainer内容">不要尝试更新NativeContainer内容</h4><p>由于缺少<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns" target="_blank" rel="noopener">ref返回</a>，因此无法直接更改<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>的内容。例如，<code>nativeArray[0]++;</code>与<code>var temp = nativeArray[0]; temp++;</code>不更新值的<code>nativeArray</code>写入相同。</p><p>相反，您必须将索引中的数据复制到本地临时副本，修改该副本并将其保存回来，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyStruct temp = myNativeArray[i];</span><br><span class="line">temp.memberVariable = 0;</span><br><span class="line">myNativeArray[i] = temp;</span><br></pre></td></tr></table></figure><h4 id="致电jobhandle-complete以重新获得所有权">致电JobHandle.Complete以重新获得所有权</h4><p>跟踪数据所有权需要在主线程再次使用它们之前完成依赖项。检查<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.IsCompleted.html" target="_blank" rel="noopener">JobHandle.IsCompleted</a>是不够的。您必须调用该方法<code>JobHandle.Complete</code>以重新获得<code>NativeContainer</code>主线程的类型的所有权。调用<code>Complete</code>还可以清除安全系统中的状态。不这样做会引入内存泄漏。如果您在每个帧中安排新作业，并且依赖于前一帧的作业，则此过程也适用。</p><h4 id="在主线程中使用schedule和complete">在主线程中使用Schedule和Complete</h4><p>你只能调用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>和<code>Complete</code>主线程。如果一个作业依赖于另一个作业，则使用<code>JobHandle</code>管理依赖关系而不是尝试在作业内安排作业。</p><h4 id="在合适的时间使用计划和完成">在合适的时间使用计划和完成</h4><p><code>Schedule</code>只要您拥有所需的数据就立即打电话给工作，并且<code>Complete</code>在您需要结果之前不要打电话给它。优秀的做法是安排一个您不需要等待的工作，而不是与正在运行的任何其他工作竞争。例如，如果在一帧结束和下一帧的开始之间没有作业正在运行，并且可以接受一帧延迟，则可以将作业调度到帧的末尾并使用其结果在以下框架中。或者，如果您的游戏与其他工作的转换期间相比，并且框架中的其他位置存在大量未充分利用的时间段，则更有效地安排您的工作。</p><h4 id="将nativecontainer类型标记为只读">将NativeContainer类型标记为只读</h4><p>请记住，作业<code>NativeContainer</code>默认情况下对类型具有读写访问权限。<code>[ReadOnly]</code>适当时使用该属性可提高性能。</p><h4 id="检查数据依赖性">检查数据依赖性</h4><p>在Unity Profiler 窗口，主线程上的标记“WaitForJobGroup”表示Unity正在等待工作线程上的作业完成。此标记可能意味着您已在某处应引入数据依赖关系。寻找<code>JobHandle.Complete</code>跟踪数据依赖关系的位置，这些数据依赖关系迫使主线程等待。</p><h4 id="调试作业">调试作业</h4><p>作业具有一个<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Run.html" target="_blank" rel="noopener">Run</a>函数，您可以使用它来代替<code>Schedule</code>在主线程上立即执行作业。您可以将其用于调试目的。</p><h4 id="不要在作业中分配托管内存">不要在作业中分配托管内存</h4><p>在作业中分配托管内存非常慢，并且该作业无法使用Unity <a href="https://www.youtube.com/watch?v=NF6kcNS6U80&amp;t=2s" target="_blank" rel="noopener">Burst编译器</a>来提高性能。Burst是一种新的基于<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM</a>的后端编译器技术，可以让您更轻松。它需要C＃作业并利用您平台的特定功能生成高度优化的机器代码。</p><h4 id="更多的信息">更多的信息</h4><ul><li>观看<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">Unity GDC 2018：</a>剪辑的<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">C＃作业系统</a>播放列表。</li><li>有关C＃作业系统如何与ECS相关的更多高级信息，请参阅<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">GitHub上</a>的<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">ECS包文档</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Unity C＃作业系统时，请确保遵守以下内容：&lt;/p&gt;
&lt;h4 id=&quot;不要从作业访问静态数据&quot;&gt;不要从作业访问静态数据&lt;/h4&gt;
&lt;p&gt;从作业访问静态数据会绕过所有安全系统。如果您访问错误的数据，您可能会以意想不到的方式崩溃Unity。例如，访问&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MonoBehaviour.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MonoBehaviour&lt;/a&gt;可能会导致域重新加载崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于存在这种风险，Unity的未来版本将阻止使用&lt;a href=&quot;https://www.youtube.com/watch?v=VxeC7WFfg3Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;静态分析&lt;/a&gt;从作业进行全局变量访问。如果您确实访问作业中的静态数据，则应该期望您的代码在Unity的未来版本中中断。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>JobHandle和依赖项</title>
    <link href="https://longshilin.com/blog/9bdee974.html"/>
    <id>https://longshilin.com/blog/9bdee974.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="要当您调用作业的schedule方法时-它将返回jobhandle-您可以在代码中使用一个jobhandle作为其他作业的依赖项-如果作业取决于另一个作业的结果-您可以将第一个作业jobhandle作为参数传递给第二个作业的schedule方法-如下所示：">要当您调用作业的<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>方法时，它将返回<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html" target="_blank" rel="noopener">JobHandle</a>。您可以在代码中使用一个<code>JobHandle</code>作为其他作业的依赖项。如果作业取决于另一个作业的结果，您可以将第一个作业<code>JobHandle</code>作为参数传递给第二个作业的<code>Schedule</code>方法，如下所示：</h4><a id="more"></a><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">JobHandle firstJobHandle = firstJob.Schedule();</span><br><span class="line">secondJob.Schedule(firstJobHandle);</span><br></pre></td></tr></table></figure><h4 id="结合依赖关系">结合依赖关系</h4><p>如果作业具有许多依赖项，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.CombineDependencies.html" target="_blank" rel="noopener">JobHandle.CombineDependencies</a>方法合并它们。<code>CombineDependencies</code>允许您将它们传递给<code>Schedule</code>方法。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;JobHandle&gt; handles = <span class="keyword">new</span> NativeArray&lt;JobHandle&gt;(numJobs, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Populate `handles` with `JobHandles` from multiple scheduled jobs...</span></span><br><span class="line"></span><br><span class="line">JobHandle jh = JobHandle.CombineDependencies(handles);</span><br></pre></td></tr></table></figure><h4 id="在主线程中等待工作">在主线程中等待工作</h4><p>使用<code>JobHandle</code>强迫你的代码在主线程等待您的工作执行完毕。要做到这一点，调用<code>JobHandle的Complete方法</code>。此时，您知道主线程可以安全地访问作业正在使用的<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>。</p><p><strong>注意</strong>：在计划作业时，作业不会开始执行。如果您正在等待主线程中的作业，并且您需要访问作业正在使用的NativeContainer数据，则可以调用该方法<code>JobHandle.Complete</code>。此方法从内存高速缓存中刷新作业并启动执行过程。在`JobHandle<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">否则，如果您不需要访问数据，则需要明确刷新批处理。为此，请调用静态方法[JobHandle.ScheduleBatchedJobs](https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html)。请注意，调用此方法会对性能产生负面影响。</span><br><span class="line"></span><br><span class="line">#### 多个作业和依赖项的示例</span><br><span class="line"></span><br><span class="line">**工作代码**：</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line">// Job adding two floating point values together</span><br><span class="line">public struct MyJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public float a;</span><br><span class="line">    public float b;</span><br><span class="line">    public NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Job adding one to a value</span><br><span class="line">public struct AddOneJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        result[0] = result[0] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>主线程代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a native array of a single float to store the result in. This example waits for the job to complete</span></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the data for job #1</span></span><br><span class="line">MyJob jobData = <span class="keyword">new</span> MyJob();</span><br><span class="line">jobData.a = <span class="number">10</span>;</span><br><span class="line">jobData.b = <span class="number">10</span>;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule job #1</span></span><br><span class="line">JobHandle firstHandle = jobData.Schedule();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup the data for job #2</span></span><br><span class="line">AddOneJob incJobData = <span class="keyword">new</span> AddOneJob();</span><br><span class="line">incJobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule job #2</span></span><br><span class="line">JobHandle secondHandle = incJobData.Schedule(firstHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for job #2 to complete</span></span><br><span class="line">secondHandle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// All copies of the NativeArray point to the same memory, you can access the result in "your" copy of the NativeArray</span></span><br><span class="line"><span class="keyword">float</span> aPlusB = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the memory allocated by the result array</span></span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;要当您调用作业的schedule方法时-它将返回jobhandle-您可以在代码中使用一个jobhandle作为其他作业的依赖项-如果作业取决于另一个作业的结果-您可以将第一个作业jobhandle作为参数传递给第二个作业的schedule方法-如下所示：&quot;&gt;要当您调用作业的&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Schedule&lt;/a&gt;方法时，它将返回&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JobHandle&lt;/a&gt;。您可以在代码中使用一个&lt;code&gt;JobHandle&lt;/code&gt;作为其他作业的依赖项。如果作业取决于另一个作业的结果，您可以将第一个作业&lt;code&gt;JobHandle&lt;/code&gt;作为参数传递给第二个作业的&lt;code&gt;Schedule&lt;/code&gt;方法，如下所示：&lt;/h4&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/categories/Unity/C%EF%BC%83-Job-System/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
  <entry>
    <title>ECS适合你吗？</title>
    <link href="https://longshilin.com/blog/43b8c1c3.html"/>
    <id>https://longshilin.com/blog/43b8c1c3.html</id>
    <published>2019-08-11T00:00:00.000Z</published>
    <updated>2019-10-06T12:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>实体组件系统处于预览状态。不建议用于生产。</p><p>目前有两个很好的理由使用它。</p><a id="more"></a><h5 id="你想试验">你想试验</h5><p>这是令人兴奋的新技术，并且大规模性能提升的承诺正在引诱。试试看。给我们您的反馈。我们很乐意在论坛上与您交谈。</p><h5 id="您正在尝试构建一个在没有实体组件系统的情况下无法完成的游戏">您正在尝试构建一个在没有实体组件系统的情况下无法完成的游戏</h5><p>我们很想知道您的游戏。请随时在论坛上发布您正在尝试实现的内容以及您认为实体组件系统为您提供的无法实现的内容。</p><h4 id="尝试实体组件系统">尝试实体组件系统</h4><p>您已经听说过ECS不仅可以提高性能，还可以帮助您编写更清晰，更清晰，更易于维护的代码。你想看看它在实践中是如何运作的。这是一个有趣的场景，因为您可以从头开始编写简单的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实体组件系统处于预览状态。不建议用于生产。&lt;/p&gt;
&lt;p&gt;目前有两个很好的理由使用它。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="https://longshilin.com/blog/categories/Unity/"/>
    
      <category term="ECS Samples" scheme="https://longshilin.com/blog/categories/Unity/ECS-Samples/"/>
    
    
      <category term="C＃ Job System" scheme="https://longshilin.com/blog/tags/C%EF%BC%83-Job-System/"/>
    
  </entry>
  
</feed>
