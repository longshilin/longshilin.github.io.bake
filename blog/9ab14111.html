<article id="post-Java基础总结/【Java基础总结】-接口与内部类" class="article article-type-post" itemscope="" itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      接口与内部类
    </h1>
  


  </header>

  <div class="article-meta">
    
    <div class="article-datetime">
  <a href="/blog/9ab14111.html" class="article-date"><time datetime="2017-11-30T10:40:21.000Z" itemprop="datePublished">2017-11-30</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/Java/">Java</a>
  </div>


    
      
        <a href="https://longshilin.com/blog/9ab14111.html#disqus_thread" class="article-comment-link">
          <i class="fa fa-comment"></i> 评论
        </a>
      
    
    <!-- <span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i>&nbsp;阅读次数: <span id="busuanzi_value_page_pv"></span>&nbsp;</span> -->
  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="接口"><strong>接口</strong></h3>
<p>重难点总结：<br>
1、接口中的所有方法自动地属于public，在接口声明方法时，不必提供关键字public，但是在实现接口 编写具体的接口方法时，需要加上public修饰符。</p>
<p>2、在接口中可以定义常量(默认就是用public static final修饰)。接口中绝对不能含有实例域或静态方法，也不能在接口中实现方法。</p>
<a id="more"></a>
<p>3、接口看成是没有实例域的抽象方法。</p>
<p>4、Java程序设计语言是一种强类型语言，在调用方法的时候，编译器将会检查这个方法是否存在。</p>
<p>5、不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象。</p>
<p>6、接口之间通过继承关系扩展接口。</p>
<h3 id="克隆"><strong>克隆</strong></h3>
<p>对象的克隆是指创建一个新对象，且新对象的状态与原始对象的状态相同。当对克隆的新对象进行修改时，不会影响原始对象的状态。</p>
<h3 id="接口与回调"><strong>接口与回调</strong></h3>
<p>回调可以指出某个特定事件发生时应该采取的动作，需要实现接口中的方法。</p>
<h3 id="内部类"><strong>内部类</strong></h3>
<h4 id="内部类-v2"><strong>内部类</strong></h4>
<p>顾名思义在类中再定义一个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">	int i = 100;</span><br><span class="line">	class innerClass&#123;</span><br><span class="line">		int m = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li>
<li>内部类可以对同一个包中的其他类隐藏起来</li>
<li>定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便携</li>
</ul>
<p>值得注意的是，外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类的引用参数。因此内部类的对象有一个隐式引用，它指向创建它的外部类对象。<br>
所以内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p>
<h4 id="局部内部类"><strong>局部内部类</strong></h4>
<p>一个类的方法体中定义的类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">	int i = 100;</span><br><span class="line">	public void innerClass()&#123;</span><br><span class="line">		class B&#123;</span><br><span class="line">			int m = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部类 不能用public或private访问说明符进行声明，他的作用域被限定在声明这个局部类的块中。<br>
局部类有一个优势，即对外部世界可以完全隐藏起来。</p>
<h4 id="匿名内部类"><strong>匿名内部类</strong></h4>
<p>一个类在new 创建一个对象实例时，直接实现其中的接口方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActionListener listener = new ActionListener()&#123;</span><br><span class="line">	public void actionPerformed(ActionEvent event)&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="静态内部类"><strong>静态内部类</strong></h4>
<p>使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围对象。为此，可以将内部类声明为static，以便取消产生的引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">	static int i = 100;</span><br><span class="line">	static class B&#123;</span><br><span class="line">		int m = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://longshilin.com/blog/9ab14111.html" data-id="cjrzqbxiz000h0l1fwj8352un" class="article-share-link">
        <i class="fa fa-share"></i> 分享
      </a>

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/接口与内部类/">接口与内部类</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/blog/cfff76a5.html" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">反射机制与代理机制</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/blog/f054fe4e.html" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">集合与线程实现</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>


<section id="comments">
  
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments.</a></noscript>
    </div>
  
</section>


