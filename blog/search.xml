<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>UnityTips</title>
      <link href="/blog/84a8576b.html"/>
      <url>/blog/84a8576b.html</url>
      
        <content type="html"><![CDATA[<p>本文收集一些实用的Unity Tips</p><a id="more"></a><h1>设置在非播放情况下编译脚本</h1><p>可以在Preferences-&gt;General中设置<br><img src="https://longshilin.com/images/20200530181748.png" alt=""></p><hr><h1>OnDrawGizmosSelected</h1><p>您可以使用OnDrawGizmosSelected()来对所选GameObject进行调试。<br><img src="https://longshilin.com/images/20200530182658.gif" alt=""></p><hr><h1>Debug.Log的第二个参数可以用来定位是哪个GameObject调用的该方法</h1><p><img src="https://longshilin.com/images/20200530183354.png" alt=""></p><hr><h1>Debug.Break()可以暂停编辑器</h1><p><img src="https://longshilin.com/images/20200530183659.png" alt=""></p><hr><h1>Inspector中的变量标签 Header, Tooltip and Space</h1><p><img src="https://longshilin.com/images/20200530184758.png" alt=""></p><hr><h1>对任意类扩展方法</h1><p>可以对任意类进行扩展方法</p><pre><code class="language-c#">using System.Collections;using System.Collections.Generic;using UnityEngine;public class test : MonoBehaviour{    public SpriteRenderer sr;    public Material mat;    void Start()    {        sr.transform.ResetTransform();        sr.color = sr.color.ChangeAlpha(.3f);        mat.color = mat.color.ChangeAlpha(.4f);    }}public static class Extension{    public static void ResetTransform(this Transform transform)    {        transform.localPosition = Vector3.zero;        transform.localScale = Vector3.one;        transform.localRotation = Quaternion.identity;    }    public static Color ChangeAlpha(this Color color, float alpha)    {        color.a = alpha;        return color;    }}</code></pre><hr><h1>Built-in shaders</h1><p>下载 Unity’s built-in shaders (including all CGinc files)  <a href="https://unity3d.com/get-unity/download/archive/" target="_blank" rel="noopener">Unity’s Archive download page</a></p><hr><h1>MinMax Attribute</h1><p>最小值和最大值属性，可以用来选取一段中间值<br><img src="https://longshilin.com/images/MinMax%20Attribute.gif" alt=""></p><hr><h1>OnValidate</h1><p>变量的合法性检测与修改<br><img src="https://longshilin.com/images/OnValidate.gif" alt=""></p><hr><h1>Rich Text</h1><p>You can use rich text in Unity’s console.<br>Read more about <a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/StyledText.html" target="_blank" rel="noopener">Rich Text</a>.</p><hr><h1>ContextMenu</h1><p>使用ContextMenu属性从Inspector调用方法。可以在Inspector中的组件菜单中直接调用方法。</p><h1>SerializeField &amp; HideInInspector</h1><p>通过使用属性SerializeField和HideInInspector选择要显示和序列化的变量。</p><h1>FormerlySerializedAs</h1><p>在修改一个Inspector面板上的变量名时，使用FormerlySerializedAs标签定义之前的名称，可以防止修改时的赋值丢失问题。<br>Read more about <a href="https://docs.unity3d.com/ScriptReference/Serialization.FormerlySerializedAsAttribute.html" target="_blank" rel="noopener">FormerlySerializedAs attribute</a>.</p><h1>AddComponentMenu</h1><p>使用AddComponentMenu属性在检查器的“ AddComponent”菜单中组织脚本。<br>Read more about <a href="">AddComponent</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UnityTips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnityTips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好代码的示例和不好的示例比较</title>
      <link href="/blog/7cddb564.html"/>
      <url>/blog/7cddb564.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="名副其实">名副其实</h3><pre><code class="language-c#">public List&lt;int[]&gt; getThem() {　List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;();　for (int[] x : theList) 　　 if (x[0] == 4) 　　　 list1.add(x);　return list1;}</code></pre><p>改良过后的</p><pre><code class="language-c#">public List&lt;int[]&gt; getFlaggedCells()　{　List&lt;int[]&gt; flaggedCells = new ArrayList&lt;int[]&gt;();　for (int[] cell : gameBoard)　　if (cell[STATUS_VALUE] == FLAGGED)　　　flaggedCells.add(cell);　return flaggedCells;}</code></pre><p>知道自己在写什么很重要，命名·要有意义</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> 代码整洁之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Coding </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Rider构建和集成简单的DLL示例</title>
      <link href="/blog/1dbc6beb.html"/>
      <url>/blog/1dbc6beb.html</url>
      
        <content type="html"><![CDATA[<p>Reference: <a href="https://docs.unity3d.com/Manual/UsingDLL.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/UsingDLL.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Toolset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity DLL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>支持自定义菜单项和编辑器功能</title>
      <link href="/blog/146377c6.html"/>
      <url>/blog/146377c6.html</url>
      
        <content type="html"><![CDATA[<p>在编辑器脚本中，使用<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/ObjectFactory.html">ObjectFactory</a>类创建新的GameObject，组件和资产。创建这些项目时，<code>ObjectFactory</code>该类会自动使用默认预设。您的脚本不必搜索并应用默认的<a href="https://longshilin.com/UnityDoc2019.3/Manual/Presets.html">Presets</a>，因为<code>ObjectFactory</code>它可以为您处理。</p><a id="more"></a><h1>支持新类型</h1><p>要默认支持和启用预设，您的类必须继承以下内容之一：</p><ul><li><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/MonoBehaviour.html">UnityEngine.Monobehaviour</a></li><li><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/ScriptableObject.html">UnityEngine.ScriptableObject</a></li><li><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/Experimental.AssetImporters.ScriptedImporter.html">UnityEngine.ScriptedImporter</a></li></ul><p>预设检查器会创建您的类的临时实例，以便用户可以修改其值，因此请确保您的类不影响或依赖于其他对象，例如静态值，Project Assets或Scene实例。</p><p><strong>提示</strong>：使用<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/CustomEditor.html">CustomEditor</a>属性是可选的。</p><h1>用例示例：自定义“编辑器”窗口中的预设设置</h1><p>使用可以使用“预设”的设置设置自定义<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/EditorWindow.html">EditorWindow</a>类时：</p><ul><li>使用<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/ScriptableObject.html">ScriptableObject</a>存储设置的副本。它也可以具有<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/CustomEditor.html">CustomEditor</a>属性。预设系统处理此对象。</li><li>始终使用此临时<code>ScriptableObject</code>检查器在UI中显示“预设”设置。这样，您的用户<code>EditorWindow</code>和您在编辑已保存的预设时可以拥有相同的UI 。</li><li>当在“ **选择预设”<strong>窗口中</strong>选择“预设”**时，公开一个“预设”按钮，并使用自己的<a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/Presets.PresetSelectorReceiver.html">PresetSelectorReceiver</a>实现使<code>EditorWindow</code>设置保持最新。</li></ul><p>以下脚本示例演示了如何将Preset设置添加到简单的<code>EditorWindow</code>。</p><p>此脚本示例演示了一个ScriptableObject，该脚本可保留并显示自定义窗口中的设置（保存到名为<em>Editor / MyWindowSettings.cs</em>的文件中）：</p><pre><code>using UnityEngine;// Temporary ScriptableObject used by the Preset systempublic class MyWindowSettings : ScriptableObject{  [SerializeField]  string m_SomeSettings;    public void Init(MyEditorWindow window)  {      m_SomeSettings = window.someSettings;  }    public void ApplySettings(MyEditorWindow window)  {      window.someSettings = m_SomeSettings;      window.Repaint();  }}</code></pre><p>脚本示例，<code>PresetSelectorReceiver</code>用于更新<code>ScriptableObject</code>自定义窗口中使用的脚本（保存到名为<em>Editor / MySettingsReceiver.cs</em>的文件中*）*：</p><pre><code>using UnityEditor.Presets;// PresetSelector receiver to update the EditorWindow with the selected values.public class MySettingsReceiver : PresetSelectorReceiver{  Preset initialValues;  MyWindowSettings currentSettings;  MyEditorWindow currentWindow;    public void Init(MyWindowSettings settings, MyEditorWindow window)  {      currentWindow = window;      currentSettings = settings;      initialValues = new Preset(currentSettings);  }    public override void OnSelectionChanged(Preset selection)  {      if (selection != null)      {          // Apply the selection to the temporary settings          selection.ApplyTo(currentSettings);      }      else      {          // None have been selected. Apply the Initial values back to the temporary selection.          initialValues.ApplyTo(currentSettings);      }            // Apply the new temporary settings to our manager instance      currentSettings.ApplySettings(currentWindow);  }    public override void OnSelectionClosed(Preset selection)  {      // Call selection change one last time to make sure you have the last selection values.      OnSelectionChanged(selection);      // Destroy the receiver here, so you don't need to keep a reference to it.      DestroyImmediate(this);  }}</code></pre><p><a href="https://longshilin.com/UnityDoc2019.3/ScriptReference/EditorWindow.html">EditorWindow的</a>脚本示例，该脚本使用临时的ScriptableObject Inspector及其“预设”按钮（保存到名为<em>Editor / MyEditorWindow.cs</em>的文件*）*显示自定义设置：</p><pre><code>using UnityEngine;using UnityEditor;using UnityEditor.Presets;public class MyEditorWindow : EditorWindow{  // get the Preset icon and a style to display it  private static class Styles  {      public static GUIContent presetIcon = EditorGUIUtility.IconContent(&quot;Preset.Context&quot;);      public static GUIStyle iconButton = new GUIStyle(&quot;IconButton&quot;);  }  Editor m_SettingsEditor;  MyWindowSettings m_SerializedSettings;    public string someSettings  {      get { return EditorPrefs.GetString(&quot;MyEditorWindow_SomeSettings&quot;); }      set { EditorPrefs.SetString(&quot;MyEditorWindow_SomeSettings&quot;, value); }  }   // Method to open the window  [MenuItem(&quot;Window/MyEditorWindow&quot;)]  static void OpenWindow()  {      GetWindow&lt;MyEditorWindow&gt;();  }  void OnEnable()  {      // Create your settings now and its associated Inspector      // that allows to create only one custom Inspector for the settings in the window and the Preset.      m_SerializedSettings = ScriptableObject.CreateInstance&lt;MyWindowSettings&gt;();      m_SerializedSettings.Init(this);      m_SettingsEditor = Editor.CreateEditor(m_SerializedSettings);  }  void OnDisable()  {      Object.DestroyImmediate(m_SerializedSettings);      Object.DestroyImmediate(m_SettingsEditor);  }  void OnGUI()  {      EditorGUILayout.BeginHorizontal();      EditorGUILayout.LabelField(&quot;My custom settings&quot;, EditorStyles.boldLabel);      GUILayout.FlexibleSpace();      // create the Preset button at the end of the &quot;MyManager Settings&quot; line.      var buttonPosition = EditorGUILayout.GetControlRect(false, EditorGUIUtility.singleLineHeight, Styles.iconButton);      if (EditorGUI.DropdownButton(buttonPosition, Styles.presetIcon, FocusType.Passive, Styles.iconButton))      {          // Create a receiver instance. This destroys itself when the window appears, so you don't need to keep a reference to it.          var presetReceiver = ScriptableObject.CreateInstance&lt;MySettingsReceiver&gt;();          presetReceiver.Init(m_SerializedSettings, this);          // Show the PresetSelector modal window. The presetReceiver updates your data.          PresetSelector.ShowSelector(m_SerializedSettings, null, true, presetReceiver);      }      EditorGUILayout.EndHorizontal();            // Draw the settings default Inspector and catch any change made to it.      EditorGUI.BeginChangeCheck();      m_SettingsEditor.OnInspectorGUI();      if (EditorGUI.EndChangeCheck())      {          // Apply changes made in the settings editor to our instance.          m_SerializedSettings.ApplySettings(this);      }  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Editor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义菜单项 </tag>
            
            <tag> 编辑器功能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>减小构建的文件大小</title>
      <link href="/blog/ea658644.html"/>
      <url>/blog/ea658644.html</url>
      
        <content type="html"><![CDATA[<p>将构建的应用程序的文件大小保持为最小很重要，对于移动设备或施加大小限制的应用程序商店尤其如此。</p><a id="more"></a><h1>查看包体中哪些文件占比最大</h1><p>减小规模的第一步是确定哪些资产对其贡献最大，因为这些资产是最有可能进行优化的候选对象。完成构建后，此信息可在编辑器日志中找到。转到控制台窗口（菜单：窗口 &gt; 常规 &gt; 控制台），单击右上角的小下拉面板，然后选择打开编辑器日志。</p><p><img src="https://longshilin.com/images/20200419101416.png" alt="执行构建后打开的 Editor 日志或者项目目录下的Build.log文件"></p><p>Editor 日志提供按类型细分的资源摘要，然后按大小比例顺序列出所有各个资源。通常，纹理 (Textures)、声音 (Sounds) 和动画 (Animations) 等内容占用的空间最多，而脚本 (Scripts)、关卡 (Levels) 和着色器 (Shaders) 一般影响最小。列表中显示的__文件标头 (File headers)__ 不是资源，实际上是添加到“原始”资源文件的额外数据，用于存储引用和设置。这些标头通常与资源大小差别很小，但如果在 Resources 文件夹中有许多大型资源，则该值可能会很大。</p><p>Editor 日志有助于识别可能要删除或优化的资源，但在开始之前应考虑以下事项：</p><p>Unity 将导入的资源重新编码为其自己的内部格式，因此源资源类型的选择不是相关因素。例如，如果项目中有一个多层 Photoshop 纹理，在构建之前将其展平并压缩。将纹理导出为 .png 文件对构建大小没有任何影响，因此应该坚持使用在开发过程中最方便的格式。</p><p>Unity 在构建期间会剥离大多数未使用的资源，因此无法通过从项目中手动删除资源来获得任何优化效果。唯一不会删除的资源是脚本（但无论如何，这些脚本通常都非常小）和 Resources 文件夹中的资源（因为 Unity 无法确定哪些是需要的，而哪些不是）。考虑到这一点，应确保 Resources 文件夹中的所有资源都是游戏所必需的资源。也许可以使用 AssetBundle 替换 Resources 文件夹中的资源；这样一来，Unity 就会动态加载资源，从而减小播放器大小。</p><h1>关于减小构建大小的建议</h1><h2 id="纹理">纹理</h2><p>纹理通常在构建中占据最多空间。第一个解决方案是使用压缩的纹理格式。请参阅有关特定于平台的纹理压缩的文档以了解更多信息。</p><p>如果这样做不足以减小文件大小，请尝试减小纹理图像的物理大小（以像素为单位）。若要在不修改实际源内容的情况下执行此操作，请在 Project 视图中选择该纹理，然后在 Inspector 窗口中减小 Max Size。要查看纹理在游戏中的外观，请放大使用该纹理的游戏对象，然后调整 <strong>Max Size</strong>，直至该纹理在 Scene 视图中的外观开始变差。更改最大纹理大小不会影响纹理资源，只会影响纹理在游戏中的分辨率。</p><p><img src="https://longshilin.com/images/20200419155312.png" alt=""></p><p>默认情况下，Unity 在导入时会压缩所有纹理。要在 Editor 中加快工作流程，请选择 Unity &lt; Preferences 并取消选中 Compress Assets on Import 的复选框。无论此设置如何，所有纹理都会在构建中进行压缩。</p><h2 id="网格和动画">网格和动画</h2><p>可以压缩<a href="https://longshilin.com/UnityDoc2019.3/Manual/class-Mesh.html">网格</a>和导入的动画剪辑，使它们在游戏文件中占用较少的空间。要启用网格压缩，请选择网格，然后在 Inspector 窗口中将 <strong>Mesh Compression</strong> 设置为 <strong>Low</strong>、<strong>Medium</strong> 或 <strong>High</strong>。网格和动画压缩使用量化技术，这意味着占用更少的空间，但压缩可能会带来一定程度的不准确性。请针对具体模型尝试找到可接受的压缩程度。</p><p>请注意，网格压缩只是生成较小的数据文件，在运行时不会减少使用的内存。减少动画关键帧会生成较小的数据文件，并会在运行时减少使用的内存；通常应始终启用该功能。请参阅有关<a href="https://longshilin.com/UnityDoc2019.3/Manual/class-AnimationClip.html">动画剪辑</a>的文档以了解与此相关的更多信息。</p><h2 id="减少-net库的大小">减少.NET库的大小</h2><p><a href="http://xn--Unity-qm1hmbz593aqde.NET" target="_blank" rel="noopener">Unity支持两个.NET</a> API兼容性级别：.NET <a href="http://4.xn--x-se9a.NET" target="_blank" rel="noopener">4.x和.NET</a> Standard 2.0。.NET Standard <a href="http://2.xn--0-cr6a90kc9mpyf0o4g.NET" target="_blank" rel="noopener">2.0将您限制为.NET</a> API的较小子集，这有助于减小尺寸。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Smart Merge</title>
      <link href="/blog/f8ae384d.html"/>
      <url>/blog/f8ae384d.html</url>
      
        <content type="html"><![CDATA[<p>Unity 包含一个名为 <strong>UnityYAMLMerge</strong> 的工具，能够以语义正确的方式合并场景和预制件文件。可从命令行中访问该工具，也可将其用于第三方版本控制软件。</p><a id="more"></a><h2 id="在-unity-中设置智能合并">在 Unity 中设置智能合并</h2><p>In the <a href="https://longshilin.com/UnityDoc2019.3/Manual/class-EditorManager.html">Editor</a> window (menu: <strong>Edit &gt; Project Settings</strong>, then select the <strong>Editor</strong> category), you have the option to select a third party version control tool (Perforce or PlasticSCM, for example). When one of these tools is enabled, you will see a <em>Smart Merge</em> menu under the <em>Version Control</em> heading. The menu has four options:</p><ul><li><strong>Off</strong>：仅使用偏好设置中设定的默认合并工具而不进行智能合并。</li><li><strong>Premerge</strong>：启用智能合并，接受纯净的合并。不纯净的合并将创建文件的预先合并基础版本、他们的版本和我的版本。然后，对这些版本使用默认合并工具。</li><li><strong>Ask</strong>：启用智能合并，但发生冲突时显示一个对话框让用户解决冲突（这是默认设置）。</li></ul><h2 id="设置-unityyamlmerge-与第三方工具结合使用">设置 UnityYAMLMerge 与第三方工具结合使用</h2><p>UnityYAMLMerge 工具随附于 Unity Editor；假设 Unity 安装在标准位置，则 UnityYAMLMerge 的路径将是：</p><pre><code>C:\Program Files\Unity\Editor\Data\Tools\UnityYAMLMerge.exeorC:\Program Files (x86)\Unity\Editor\Data\Tools\UnityYAMLMerge.exe</code></pre><ul><li>在 Windows 上；</li></ul><pre><code>/Applications/Unity/Unity.app/Contents/Tools/UnityYAMLMerge</code></pre><ul><li>在 Mac OSX 上（使用 Finder 中的 <em>Show Package Contents</em> 命令访问此文件夹）。</li></ul><p>UnityYAMLMerge 附带了一个默认的回退文件（称为 mergespecfile.txt，也在 Tools 文件夹中），用于指定如何处理未解决的冲突或未知文件。此外，还可将其用作不会根据文件扩展名自动选择合并工具的版本控制系统（例如 git）的主要合并工具。默认情况下，mergespecfile.txt 中已列出最常用的工具，但可以编辑此文件以添加新工具或更改选项。</p><p>可从命令行中将 UnityYAMLMerge 作为独立工具运行（若要查看该工具的完整使用说明，可在运行时不带任何参数）。下面给出了常见版本控制系统的设置说明。</p><h3 id="p4v">P4V</h3><ul><li>选择 Preferences &gt; Merge。</li><li>选择 <em>Other application</em>。</li><li>单击 <em>Add</em> 按钮。</li><li>在 Extension 字段中，输入 <code>.unity</code>。</li><li>在 Application 字段中，输入 UnityYAMLMerge 工具的路径（见下文）。</li><li>在 Arguments 字段中，输入 <code>merge -p %b %1 %2 %r</code></li><li>单击 Save。</li></ul><p>然后，按照相同的步骤添加 <code>.prefab</code> 扩展名。</p><h3 id="git">Git</h3><p>将以下文本添加到 <code>.git</code> 或 <code>.gitconfig</code> 文件中：</p><pre><code>    [merge]        tool = unityyamlmerge        [mergetool &quot;unityyamlmerge&quot;]        trustExitCode = false        cmd = '&lt;path to UnityYAMLMerge&gt;' merge -p &quot;$BASE&quot; &quot;$REMOTE&quot; &quot;$LOCAL&quot; &quot;$MERGED&quot;</code></pre><h3 id="mercurial">Mercurial</h3><p>将以下文本添加到 <code>.hgrc</code> 文件中：</p><pre><code>    [merge-patterns]        **.unity = unityyamlmerge        **.prefab = unityyamlmerge        [merge-tools]        unityyamlmerge.executable = &lt;path to UnityYAMLMerge&gt;        unityyamlmerge.args = merge -p --force $base $other $local $output        unityyamlmerge.checkprompt = True        unityyamlmerge.premerge = False        unityyamlmerge.binary = False</code></pre><h3 id="svn">SVN</h3><p>将以下文本添加到 <code>~/.subversion/config</code> 文件中：</p><pre><code>    [helpers]        merge-tool-cmd = &lt;path to UnityYAMLMerge&gt;</code></pre><h3 id="tortoisegit">TortoiseGit</h3><ul><li>选择 Preferences &gt; Diff Viewer &gt; Merge Tool，然后单击 <em>Advanced</em> 按钮。</li><li>在弹出框的 Extension 字段中，输入 <code>.unity</code>。</li><li>在 External Program 字段中，输入：</li></ul><pre><code>    &lt;path to UnityYAMLMerge&gt; merge -p %base %theirs %mine %merged</code></pre><p>然后，按照相同的步骤添加 <code>.prefab</code> 扩展名。</p><h3 id="plasticscm">PlasticSCM</h3><ul><li>选择 Preferences &gt; Merge Tools，然后单击 <em>Add</em> 按钮。</li><li>选择 <em>External</em> 合并工具。</li><li>选择 <em>Use with files that match the following pattern</em>。</li><li>添加 <code>.unity</code> 扩展名。</li><li>输入以下命令：</li></ul><pre><code>    &lt;path to UnityYAMLMerge&gt; merge -p &quot;@basefile&quot; &quot;@sourcefile&quot;  &quot;@destinationfile&quot; &quot;@output&quot;</code></pre><p>然后，按照相同的步骤添加 <code>.prefab</code> 扩展名。</p><h3 id="sourcetree">SourceTree</h3><ul><li>选择 Tools &gt; Options &gt; Diff。</li><li>在 Merge Tool 下拉选单中选择 <em>Custom</em>。</li><li>在 <em>Merge Command</em> 文本字段中，输入 UnityYAMLMerge 的路径。</li><li>在 <em>Arguments</em> 文本字段中，输入 <code>merge -p $BASE $REMOTE $LOCAL $MERGED</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 工具集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Smart Merge </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>添加随机游戏元素</title>
      <link href="/blog/98217773.html"/>
      <url>/blog/98217773.html</url>
      
        <content type="html"><![CDATA[<p>随机选择的项或值在许多游戏中都很重要。本部分将介绍如何使用 Unity 的内置随机函数来实现一些常见的游戏机制。</p><a id="more"></a><h2 id="从数组中选择一个随机项">从数组中选择一个随机项</h2><p>随机选取一个数组元素归结为选择零和数组最大索引值（等于数组的长度减去 1）之间的一个随机整数。使用内置的 Random.Range 函数可以轻松实现：</p><pre><code class="language-c#"> var element = myArray[Random.Range(0, myArray.Length)];</code></pre><p>请注意，Random.Range 从包含第一个参数但不包含第二个参数的范围内返回一个值，因此在此处使用 myArray.Length 会得到正确的结果。</p><h2 id="选择具有不同概率的项">选择具有不同概率的项</h2><p>有时需要随机选择项，但有些项比其他项被选中的几率更高。例如，NPC 在遇到玩家时可能会以几种不同的方式做出反应：</p><ul><li>友好问候的几率为 50%</li><li>逃跑的几率为 25%</li><li>立即攻击的几率为 20%</li><li>提供金钱作为礼物的几率为 5%</li></ul><p>可将这些不同的结果可视化为一张纸条，该纸条分成几个部分，每个部分占据纸条总长度的一个比例。占据的比例等于选择结果的概率。选择行为相当于沿着纸条的长度选择一个随机点（例如通过投掷飞镖），然后查看该点处于哪个部分。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/ProbStrip.png" alt="img"></p><p>在脚本中，纸条实际上是一个浮点数组，其中的浮点数按顺序包含项的不同概率。随机点是通过将 Random.value 乘以数组中所有浮点数的总和得到的（这些数值不需要加起来等于 1；重点是不同值的相对大小）。要找到该点“位于”哪个数组元素，首先要检查它是否小于第一个元素中的值。如果是，则第一个元素便是选中的元素。否则，从该点值中减去第一个元素的值，然后将其与第二个元素进行比较，依此类推，直到找到正确的元素。在代码中表示为以下所示的内容：</p><pre><code class="language-c#">    float Choose (float[] probs) {        float total = 0;        foreach (float elem in probs) {            total += elem;        }        float randomPoint = Random.value * total;        for (int i= 0; i &lt; probs.Length; i++) {            if (randomPoint &lt; probs[i]) {                return i;            }            else {                randomPoint -= probs[i];            }        }        return probs.Length - 1;    }</code></pre><p>请注意，最后的 return 语句是必要的，因为 Random.value 可以返回 1 的结果。在这种情况下，搜索将无法在任何地方找到随机点。将以下行</p><pre><code class="language-c#"> if (randomPoint &lt; probs[i])</code></pre><p>…更改为“小于或等于”测试将避免额外的 return 语句，但也会允许偶尔选择某个项，即使其概率为零也是如此。</p><h2 id="加权连续随机值">加权连续随机值</h2><p>如果结果是不连续的，那么浮点数组方法会很有效，但在某些情况下希望产生更连续的结果；比如说，希望随机化一个宝箱中发现的金块数量，并希望能够出现 1 到 100 之间的任何数字，但让更小数字的概率更高。使用浮点数组方法来执行此算法将需要设置一个包含 100 个浮点数（即纸条上的部分）的数组，这是很不实用的方法；如果不局限于整数而是想要在该范围内的任何数字，则不可能使用这种方法。</p><p>一种适用于连续结果的更好方法是使用 AnimationCurve 将“原始”随机值转换为“加权”值；通过绘制不同的曲线形状，可产生不同的权重。代码编写起来也更简单：</p><pre><code class="language-c#">float CurveWeightedRandom(AnimationCurve curve) {    return curve.Evaluate(Random.value);}</code></pre><p>此算法从 <code>Random.value</code> 读取值来选择 0 到 1 之间的“原始”随机值。然后，该值传递给 <code>curve.Evaluate()</code>，在此处将其视为水平坐标，并返回曲线在该水平位置处的相应垂直坐标。曲线较平缓的部分被选取的几率较高，而较陡峭的部分被选取的几率较低。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/WeightedRandomCurve-linear.png" alt="线性曲线根本不对值进行加权；曲线上每个点的水平坐标等于垂直坐标。">线性曲线根本不对值进行加权；曲线上每个点的水平坐标等于垂直坐标。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/WeightedRandomCurve-bias-low.png" alt="这条曲线在开始时较平缓，然后在结束时变得越来越陡峭，因此较低值的几率较高，而较高值的几率较低。此处可以看到 x=0.5 时曲线的高度约为 0.25，这意味着有 50% 的几率得到 0 到 0.25 之间的值。">这条曲线在开始时较平缓，然后在结束时变得越来越陡峭，因此较低值的几率较高，而较高值的几率较低。此处可以看到 x=0.5 时曲线的高度约为 0.25，这意味着有 50% 的几率得到 0 到 0.25 之间的值。</p><p><img src="https://longshilin.com/UnityDoc2019.3/uploads/Main/WeightedRandomCurve-bias-lowhigh.png" alt="这条曲线在开始和结束时都很平缓，因此这些值接近极值的几率较高，而中间的陡峭部分表示得到这些值的几率较低。另外请注意，使用此曲线时，高度值已向上移动：曲线底部为 1，曲线顶部为 10，这意味着曲线产生的值将在 1-10 范围内，而不是像以前的曲线那样在 0-1 范围内。">这条曲线在开始和结束时都很平缓，因此这些值接近极值的几率较高，而中间的陡峭部分表示得到这些值的几率较低。另外请注意，使用此曲线时，高度值已向上移动：曲线底部为 1，曲线顶部为 10，这意味着曲线产生的值将在 1–10 范围内，而不是像以前的曲线那样在 0–1 范围内。</p><p>请注意，这些曲线并非概率论指南中可能介绍的概率分布曲线，而更像是反向累积概率曲线。</p><p>通过在一个脚本上定义 AnimationCurve 公共变量，可使用 Inspector 窗口直观查看和编辑曲线，而无需计算值。</p><p>这种方法会产生浮点数。如果要计算整数结果（例如，需要 82 个金块，而不是 82.1214 个金块），可将计算值传递给 Mathf.RoundToInt() 之类的函数。</p><h2 id="列表洗牌">列表洗牌</h2><p>一种常见的游戏机制是从一组已知的项中进行选择，但让这些项以随机顺序到达。例如，一副纸牌通常需要洗牌，因此不会以可预测的顺序绘制。为了对数组中的项进行随机洗牌，可访问每个元素，然后将其与数组中位于随机索引处的另一个元素进行交换：</p><pre><code class="language-c#">    void Shuffle (int[] deck) {        for (int i = 0; i &lt; deck.Length; i++) {            int temp = deck[i];            int randomIndex = Random.Range(0, deck.Length);            deck[i] = deck[randomIndex];            deck[randomIndex] = temp;        }    }</code></pre><h2 id="从一组无重复的项中选择">从一组无重复的项中选择</h2><p>一种常见的任务是从一组中随机选取一些项，但不可多次选取同一项。例如，可能希望在一些随机生成点生成多个 NPC，但要确保每个点只生成一个 NPC。为实现此目的，可按顺序遍历这些项，随机决定是否将每一项添加到所选集合中。当访问每一项时，该项被选取的概率等于仍然需要的项数除以仍然可供选择的项数。</p><p>例如，假设有 10 个可用的生成点，但只能选择其中 5 个。选择第一项的概率为 5/10，即 0.5。如果选择了该项，那么第二项的概率将是 4/9，即 0.44（即仍然需要 4 项，还剩下 9 项可供选择）。但是，如果未选择第一项，那么第二项的概率将是 5/9，即 0.56（即仍然需要 5 项，还剩下 9 项可供选择）。这一直持续到该集合包含所需的 5 项为止。可使用如下所示的代码实现此算法：</p><pre><code class="language-c#">    Transform[] spawnPoints;    Transform[] ChooseSet (int numRequired) {        Transform[] result = new Transform[numRequired];        int numToChoose = numRequired;        for (int numLeft = spawnPoints.Length; numLeft &gt; 0; numLeft--) {            float prob = (float)numToChoose/(float)numLeft;            if (Random.value &lt;= prob) {                numToChoose--;                result[numToChoose] = spawnPoints[numLeft - 1];                if (numToChoose == 0) {                    break;                }            }        }        return result;    }</code></pre><p>请注意，虽然选择是随机的，但所选集合中的项与原始数组中的项具有相同的顺序。如果要按顺序一次使用一项，那么这种排序可能使它们在一定程度上可预测，因此在使用之前可能需要对数组进行洗牌。</p><h2 id="空间中的随机点">空间中的随机点</h2><p>通过将 Vector3 的每个分量设置为 Random.value 返回的值可以选择立方体中的随机点：</p><pre><code class="language-c#"> var randVec = Vector3(Random.value, Random.value, Random.value);</code></pre><p>这种算法可在边长为一个单位的立方体内部给出一个点。只需将矢量的 X、Y 和 Z 分量乘以期望的边长即可缩放该立方体。如果其中一个轴设置为零，则该点将始终位于单个平面内。例如，在“地面”上选取随机点通常需要随机设置 X 和 Z 分量并将 Y 分量设置为零。</p><p>当体积为球体时（即，希望从原点开始的给定半径内选取随机点时），可使用 Random.insideUnitSphere 乘以所需的半径：</p><pre><code class="language-c#"> var randWithinRadius = Random.insideUnitSphere * radius;</code></pre><p>请注意，如果将结果矢量的某个分量设置为零，则<em>不能</em>在圆内获得正确的随机点。尽管该点确实是随机点并且位于正确的半径内，但是概率严重偏向于圆的边缘，因此点分布将非常不均匀。对于此任务，应改用 Random.insideUnitCircle：</p><pre><code class="language-c#"> var randWithinCircle = Random.insideUnitCircle * radius;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 游戏内工具集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机游戏元素 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity Asset DataBase Editor</title>
      <link href="/blog/8ee7eed0.html"/>
      <url>/blog/8ee7eed0.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章纪录和Asset DataBase相关，可以通过脚本方式控制。</p><a id="more"></a><h1>Importing an Asset</h1><pre><code class="language-c#">using UnityEngine;using UnityEditor;public class ImportAsset {    [MenuItem (&quot;AssetDatabase/ImportExample&quot;)]    static void ImportExample ()    {        AssetDatabase.ImportAsset(&quot;Assets/Textures/texture.jpg&quot;, ImportAssetOptions.Default);    }}</code></pre><p><strong>ImportAssetOptions选项：</strong><br>Default默认导入选项。<br>ForceUpdate由用户发起的资源导入。<br>ForceSynchronousImport同步导入所有资源。<br>ImportRecursive导入文件夹时，也要导入其中的所有内容。<br>DontDownloadFromCacheServer强制完全重新导入，但不从缓存服务器下载资源。<br>ForceUncompressedImport强制资源以版本工具的未压缩形式导入。</p><h1>Loading an Asset</h1><pre><code class="language-c#">using UnityEngine;using UnityEditor;public class ImportAsset {    [MenuItem (&quot;AssetDatabase/LoadAssetExample&quot;)]    static void ImportExample ()    {        Texture2D t = AssetDatabase.LoadAssetAtPath(&quot;Assets/Textures/texture.jpg&quot;, typeof(Texture2D)) as Texture2D;    }}</code></pre><h1>有关AssetDataBase的文件操作</h1><pre><code class="language-c#">public class AssetDatabaseIOExample {    [MenuItem (&quot;AssetDatabase/FileOperationsExample&quot;)]    static void Example ()    {        string ret;                // 创建        Material material = new Material (Shader.Find(&quot;Specular&quot;));        AssetDatabase.CreateAsset(material, &quot;Assets/MyMaterial.mat&quot;);        if(AssetDatabase.Contains(material))            Debug.Log(&quot;Material asset created&quot;);                // 重命名        ret = AssetDatabase.RenameAsset(&quot;Assets/MyMaterial.mat&quot;, &quot;MyMaterialNew&quot;);        if(ret == &quot;&quot;)            Debug.Log(&quot;Material asset renamed to MyMaterialNew&quot;);        else            Debug.Log(ret);                // 创建文件夹        ret = AssetDatabase.CreateFolder(&quot;Assets&quot;, &quot;NewFolder&quot;);        if(AssetDatabase.GUIDToAssetPath(ret) != &quot;&quot;)            Debug.Log(&quot;Folder asset created&quot;);        else            Debug.Log(&quot;Couldn't find the GUID for the path&quot;);                // 移动        ret = AssetDatabase.MoveAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/NewFolder/MyMaterialNew.mat&quot;);        if(ret == &quot;&quot;)            Debug.Log(&quot;Material asset moved to NewFolder/MyMaterialNew.mat&quot;);        else            Debug.Log(ret);                // 复制        if(AssetDatabase.CopyAsset(AssetDatabase.GetAssetPath(material), &quot;Assets/MyMaterialNew.mat&quot;))            Debug.Log(&quot;Material asset copied as Assets/MyMaterialNew.mat&quot;);        else            Debug.Log(&quot;Couldn't copy the material&quot;);        // 手动刷新数据库以通知更改        AssetDatabase.Refresh();        Material MaterialCopy = AssetDatabase.LoadAssetAtPath(&quot;Assets/MyMaterialNew.mat&quot;, typeof(Material)) as Material;                // 移到垃圾箱        if(AssetDatabase.MoveAssetToTrash(AssetDatabase.GetAssetPath(MaterialCopy)))            Debug.Log(&quot;MaterialCopy asset moved to trash&quot;);                // 删除        if(AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(material)))            Debug.Log(&quot;Material asset deleted&quot;);        if(AssetDatabase.DeleteAsset(&quot;Assets/NewFolder&quot;))            Debug.Log(&quot;NewFolder deleted&quot;);                // 进行所有更改后刷新 AssetDatabase        AssetDatabase.Refresh();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Editor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asset DataBase </tag>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity Asset Bundle Browser tool(中文翻译版)</title>
      <link href="/blog/4063a140.html"/>
      <url>/blog/4063a140.html</url>
      
        <content type="html"><![CDATA[<p>该工具使用户可以查看和编辑其Unity项目的资产捆绑包的配置。它将阻止将创建无效捆绑软件的编辑，并通知您现有捆绑软件的任何问题。它还提供了基本的构建功能。</p><p>使用此工具作为选择资产和在检查器中手动设置其资产束的替代方法。可以将其放入任何5.6或更高版本的Unity项目中。它将在<strong>Window</strong> &gt; <strong>AssetBundle Browser中</strong>创建一个新的菜单项。捆绑软件配置，构建功能和构建捆绑软件检查在新窗口中分为三个选项卡。</p><a id="more"></a><p><img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/browser_header.png" alt="浏览器标题"></p><h3 id="需要unity-5-6">需要Unity 5.6+</h3><h1>用法-配置</h1><p>该窗口提供了类似于资源管理器的界面，用于管理和修改项目中的资产捆绑包。首次打开时，该工具将在后台解析所有包数据，并慢慢标记它检测到的警告或错误。它会尽其所能与项目保持同步，但不能总是意识到工具外部的活动。要在错误检测时强制快速通过，或使用外部所做的更改来更新工具，请点击左上方的“刷新”按钮。</p><p>该窗口分为四个部分：捆绑包列表，捆绑包详细信息，资产列表和资产详细信息。 <img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/browser_configure2.png" alt="BroserConfigure"></p><h3 id="捆绑清单">捆绑清单</h3><p>左窗格显示项目中所有捆绑包的列表。可用功能：</p><ul><li>选择一个捆绑包或捆绑包集，以在“资产列表”窗格中查看捆绑包中的资产列表。</li><li>带有变体的软件包为深灰色，可以展开以显示变体列表。</li><li>右键单击或缓慢双击以重命名包或包文件夹。</li><li>如果捆绑包有任何错误，警告或信息消息，则图标将出现在右侧。将鼠标悬停在图标上以获取更多信息。</li><li>如果一个捆绑包中至少有一个场景（使其成为一个场景捆绑包）并且显式包括了非场景资产，它将被标记为有错误。除非修复，否则此捆绑包不会生成。</li><li>资产重复的捆绑商品将带有警告标记（有关以下资产清单部分中重复的更多信息）</li><li>空的捆绑包将标记一条信息消息。由于多种原因，空束不是很稳定，有时会从此列表中消失。</li><li>捆绑软件的文件夹将被标记为包含的捆绑软件中的最高消息。</li><li>要修复捆绑资产中重复的资产包含，您可以：<ul><li>右键单击单个捆绑软件，将所有确定为重复的资产移动到新捆绑软件中。</li><li>右键单击多个捆绑，以将资产从所有重复的选定捆绑中移动到新捆绑中，或仅将选择中共享的资产移动到新捆绑中。</li><li>您也可以将重复的资产从“资产列表”窗格中拖出到捆绑包列表中，以将其明确包含在捆绑包中。下面的“资产列表”功能集中提供了更多有关此信息。</li></ul></li><li>右键单击或单击DEL删除捆绑包。</li><li>左右拖动捆绑包以将其移入或移出文件夹，或合并它们。</li><li>将资产从Project Explorer拖到Bundel中以添加它们。</li><li>将资产拖到空白处以创建新的捆绑包。</li><li>右键单击以创建新的捆绑软件或捆绑软件文件夹。</li><li>右键单击以“转换为变体”<ul><li>这会将变体（最初称为“ newvariant”）添加到选定的包中。</li><li>当前选定捆绑销售商品中的所有资产都将移至新变体中</li><li>ComingSoon：变体之间的不匹配检测。</li></ul></li></ul><p>图标指示捆绑包是标准捆绑包还是场景捆绑包。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/ABundleBrowserIconY1756Basic.png" alt="标准捆绑包的图标"></p><p><img src="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/images/ABundleBrowserIconY1756Scene.png" alt="场景包的图标"></p><h3 id="捆绑包详细信息">捆绑包详细信息</h3><p>左下方的窗格显示在“捆绑包列表”窗格中选择的捆绑包的详细信息。如果可用，此窗格将显示以下信息：</p><ul><li>捆绑包总大小。这是所有资产的磁盘大小的总和。</li><li>当前捆绑包所依赖的捆绑包</li><li>与当前包关联的任何消息（错误/警告/信息）。</li></ul><h3 id="资产清单">资产清单</h3><p>右上方的窗格提供了在捆绑包列表中选择的捆绑包中包含的资产列表。此列表上方的搜索字段将与任何捆绑包中的资产匹配。资产列表将仅显示匹配的资产，捆绑包列表将仅显示包含匹配资产的捆绑包。可用功能：</p><ul><li>查看预计将包含在捆绑中的所有资产。按任何列标题对资产列表进行排序。</li><li>查看捆绑中明确包含的资产。这些是已明确分配捆绑的资产。检查员将反映捆绑包的包含情况，在此视图中，他们将在资产名称旁边说出捆绑包名称。</li><li>查看包含在捆绑中的资产。这些资产在资产名称旁边将<em>自动</em>说成是捆绑商品的名称。如果在检查器中查看这些资产，它们将说“ *无”*作为分配的捆绑包。<ul><li>由于对其他包含资产的依赖性，这些资产已添加到选定的捆绑包中。只有未明确分配给捆绑包的资产才会隐式包含在任何捆绑包中。</li><li>请注意，此隐式包含列表可能不完整。某些已知的材质和纹理问题并不总是能够正确显示。</li><li>由于多个资产可以共享依赖关系，因此通常将给定资产隐式包含在多个束中。如果工具检测到这种情况，它将使用警告图标标记捆绑商品和有问题的资产。</li><li>要解决包含重复的警告，您可以手动将资产移动到新的捆绑软件中，或右键单击捆绑软件并选择“移动重复”选项之一。</li></ul></li><li>将资产从“项目资源管理器”拖动到该视图中，以将其添加到选定的包中。仅在仅选择一个捆绑包且资产类型兼容（场景捆绑包上的场景等）时才有效。</li><li>将资产（显式或隐式）从资产列表拖到捆绑包列表中（以将其添加到其他捆绑包或新创建的捆绑包中）。</li><li>右键单击或单击DEL从捆绑中删除资产（不会从项目中删除资产）。</li><li>选择或双击资产以在Project Explorer中显示它们。</li></ul><p>关于将文件夹包括在捆绑包中的说明。可以将资产文件夹（从Project Explorer）分配到捆绑包。在浏览器中查看该文件夹时，该文件夹本身将被列出为显式，而其内容则为隐式。这反映了用于将资产分配到捆绑包的优先级系统。例如，假设您的游戏在Assets / Prefabs中有五个预制件，并且您将文件夹“ Prefabs”标记为一个捆，而将一个实际的预制件（“ PrefabA”）标记为另一个。建成后，“ PrefabA”将放在一个捆绑包中，而其他四个预制件将放在另一个捆绑包中。</p><h3 id="资产明细">资产明细</h3><p>右下方的窗格显示了在“资产列表”窗格中选择的资产的详细信息。该窗格不能与之交互，但如果可用，将显示以下信息：</p><ul><li>资产全路径</li><li>包含在包中的隐式原因（如果是隐式的）。</li><li>警告的原因（如果有）。</li><li>错误原因（如果有）。</li></ul><h3 id="故障排除">故障排除</h3><ul><li>*无法重命名或删除特定的捆绑软件。*有时是在首次将此工具添加到现有项目中时引起的。请通过Unity菜单系统强制重新导入资产以刷新数据。</li></ul><h3 id="外部工具整合">外部工具整合</h3><p>生成资产捆绑包数据的其他工具可以选择与浏览器集成。当前主要的例子是<a href="https://bitbucket.org/Unity-Technologies/assetbundlegraphtool" target="_blank" rel="noopener">资产捆绑图工具</a>。如果检测到集成，则选择栏将出现在浏览器顶部附近。它将允许您选择默认数据源（Unity的AssetDatabase）或集成工具。如果未检测到选择器，则不存在选择器，尽管您可以通过右键单击选项卡标题并选择“自定义来源”来添加选择器。</p><h1>用法-构建</h1><p>“构建”选项卡提供了基本的构建功能，可帮助您开始使用资产捆绑包。在大多数专业场景中，用户最终将需要更高级的构建设置。欢迎所有人使用此工具中的构建代码作为不再满足其需求的自己编写代码的起点。在大多数情况下，此处的选项直接与引擎在<a href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.html" target="_blank" rel="noopener">BuildAssetBundleOptions中</a>期望的选项联系在一起。接口：</p><ul><li><em>构建目标</em> -捆绑包的<em>构建</em>平台</li><li><em>输出路径</em> -保存已构建捆绑包的路径。默认情况下，这是AssetBundles /。您可以手动编辑路径，也可以选择“浏览”。要返回默认的命名约定，请单击“重置”。</li><li><em>清除文件夹</em> -这将在构建之前从构建路径文件夹中删除所有数据。</li><li>*复制到StreamingAssets-*构建完成后，这会将结果复制到Assets / StreamingAssets。这对于测试很有用，但不会在生产中使用。</li><li><em>高级设置</em><ul><li><em>压缩</em> -在无压缩，标准LZMA或基于块的LZ4压缩之间选择。</li><li><em>排除类型信息</em> -不要在资产捆绑包中包含类型信息</li><li><em>强制重建</em> -重建需要构建的捆绑包。这与“清除文件夹”不同，因为此选项不会删除不再存在的捆绑软件。</li><li><em>忽略类型树更改</em> -进行增量构建检查时忽略类型树更改。</li><li><em>附加哈希</em> -将哈希附加到资产包名称。</li><li><em>严格模式</em> -如果在构建过程中报告任何错误，则不允许构建成功。</li><li><em>空运行构建</em> -执行空运行构建。</li></ul></li><li><em>构建</em> -执行构建。</li></ul><h1>用法-检查</h1><p>该选项卡使您可以检查已构建的捆绑软件的内容。</p><h3 id="用法">用法</h3><ul><li>如果使用浏览器进行构建，则将在此处自动添加构建的路径。</li><li>单击“添加文件”或“添加文件夹”以添加要检查的捆绑软件。</li><li>单击每行旁边的“-”以删除该文件或文件夹。注意，您不能删除通过添加文件夹添加的单个文件。</li><li>选择列出的任何捆绑包以查看详细信息：<ul><li>名称</li><li>磁盘大小</li><li>源资产路径-显式添加到此捆绑包中的资产。请注意，对于场景包，此列表不完整。</li><li>高级数据-包括有关预载表，容器（显式资产）和依赖项的信息。</li></ul></li></ul><blockquote><p>参考：<a href="https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/index.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.assetbundlebrowser@1.7/manual/index.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset Bundle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnityDoc </tag>
            
            <tag> Unity Asset Bundle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Asset Bundle介绍</title>
      <link href="/blog/e909ed70.html"/>
      <url>/blog/e909ed70.html</url>
      
        <content type="html"><![CDATA[<p>AssetBundle是与主游戏或应用程序分开存储并在运行时加载（或下载的，对于移动和在线应用程序而言）的内容。<br>通过允许客户仅下载和安装所需的部件，这有助于最大程度地减少对网络和系统资源的影响。<br>例如，一家汽车制造商拥有一个VR应用程序，该应用程序允许客户“试驾”车辆，而不希望将所有车辆都包含在应用程序中，<br>这会导致下载和安装的体积过大。<br>资产捆绑包允许客户仅下载他想测试驾驶的车辆，并且其平台可以处理的质量级别。</p><a id="more"></a><h1>AssetBundles的优点</h1><p>AssetBundles也可以用于在发布后更新或添加到内容。<br>这可能包括可下载的内容，限时促销活动或主题内容，例如与假期相关的模型。<br>AssetBundles还允许自动更新，并且可以在项目之间重复使用内容。<br>例如，对于已连接的应用程序，您可以将品牌（例如徽标或介绍性视频）存储为在线AssetBundle。<br>品牌变更时，您只需要更新服务器上的相关AssetBundle。<br>通过远程AssetBundle加载这些资产的应用程序会自动显示更新的内容，而不需要更新。<br>可以对下载这些图形的应用进行预编程，以检查在线AssetBundle中的更改并根据需要更新本地存储的包。</p><h1>变体</h1><p>AssetBundle可以进一步分为多个变体。变体是与其一起存储的AssetBundle的选项或子类。<br>如果您有一个名为Vehicles的AssetBundle，则可能有一个针对汽车的变体，另一个针对卡车的变体。<br>如果将捆绑资产分配给变量，则必须将该捆绑中的所有资产分配给变量。<br>您不能在bundlename.variant中拥有资产，而在bundlename（没有变体）中拥有另一资产，其中bundlename两者相同。</p><p>为了说明使用变体来协助AssetBundle组织的一种用法，假设我们正在为多控制台视频游戏创建教程级别。<br>下表列出了一些说明中可能使用的图形，以向播放器显示要按下的按钮。<br>Controller布局是现代控制台所共有的，但是操作按钮上的标签随平台而异。<br>在此示例中，尽管标签不同，但顶部动作按钮在两个版本的游戏上都执行相同的动作。<br>在我们的代码中，我们将为定向图形加载通用变体，但在运行时将加载包含特定系统按钮或键盘图形的变体。</p><p>资产捆绑包ControlImage的内容<br><img src="https://longshilin.com/images/c033e07b-8bb3-4c9c-b668-cf8968323791_Introduction_to_Asset_Bundles___Figure_01A___Click_here_to_assign.png" alt=""></p><p>或者，假设我们捆绑了按键图片，以用于在跨平台桌面应用程序上训练用户。<br>ConsoleA和ConsoleB可以分别成为Windows和macOS，而TopActionButton可能类似于Ctrl和Cmd。</p><h1>创建一个AssetBundle</h1><p>当前，构建AssetBundles的唯一方法是通过脚本编写。<br>以下脚本将此功能添加到Unity Editor。<br>BuildAssetBundles有三个参数：应在其中创建AssetBundles的目录，<br>非标准构建模式的BuildAssetBundleOption（可选）和AssetBundle的构建目标。<br>在Assets文件夹内创建一个名为<strong>Editor</strong>的文件夹。<br>在编辑器中，创建一个名为CreateAssetBundles的新C＃脚本。<br>双击CreateAssetBundles在Visual Studio中将其打开，然后删除所有内容。<br>输入以下内容：</p><pre><code class="language-c#">using UnityEditor;using System.IO;using UnityEngine;public class CreateAssetBundles{    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]    static void BuildAllAssetBundles()    {        string assetBundleDirectory = &quot;Assets/StreamingAssets&quot;;        if (!Directory.Exists(Application.streamingAssetsPath))        {            Directory.CreateDirectory(assetBundleDirectory);        }        BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, EditorUserBuildSettings.activeBuildTarget);    }}</code></pre><p>CreateAssetBundles已完成。<br>保存更改并关闭Visual Studio。<br>在Unity编辑器中，您可以在Asset下拉列表的底部找到一个新选项：Build AssetBundles。</p><h1>CreateAssetBundles 参数</h1><p>在构建AssetBundle之前，必须存在指定的AssetBundle目录。<br>BuildAssetBundleOptions参数是可选的，如果未指定任何内容，则默认为None。<br>一些关键选项是：<br><img src="https://longshilin.com/images/37d2fe36-0fd5-41d8-a33e-c43b9dd44b0e_Introduction_to_Asset_Bundles___Figure_01B___Click_here_to_assign.png" alt=""></p><h1>目标平台选项</h1><p>由于AssetBundles所需的格式和处理方式因平台而异，因此必须使用以下选项之一指定目标平台：<br><img src="https://longshilin.com/images/20200412002438.png" alt=""></p><h1>创建一个简单的AssetBundle</h1><p>为了测试加载AssetBundle，我们将使用单个GameObject创建一个AssetBundle。<br>此工作流程假定您已完成前面的CreateAssetBundles脚本。<br>在项目的文件夹结构中镜像您的AssetBundle组织，可以更轻松地根据需要查找和更新捆绑的资产。</p><ul><li>将一个Sprite拖到您的Assets文件夹中。</li><li>在一个新场景中，创建一个名为BundledSpriteObject的GameObject。</li><li>附加一个Sprite Renderer组件，并从步骤1开始分配您的Sprite。*在Assets中创建一个名为BundledAssets的文件夹。<br>在BundledAssets内，创建一个名为testbundle的文件夹。</li><li>将BundledSpriteObject拖入testbundle并将其从层次结构中删除。</li><li>在“项目”视图中单击BundledSpriteObject以打开其检查器。<br>请特别注意检查器的底部。</li><li>单击AssetBundle旁边的None将BundledSpriteObject分配给AssetBundle。<br><img src="https://longshilin.com/images/20200412010248.png" alt=""></li></ul><h1>加载本地存储的AssetBundle</h1><p>假设没有发生错误，我们准备从本地存储加载AssetBundle。<br>为了方便演示，我们正在Start中加载软件包。<br>在生产中，仅在必要时才加载AssetBundle。<br>在X和Y中将主摄像机的变换位置设置为0。*创建一个名为Loader的新GameObject。<br>创建一个名为BundledObjectLoader的新C＃脚本，并将其附加到Loader。<br>双击BundledObjectLoader在Visual Studio中将其打开。使用下面的代码：</p><pre><code class="language-c#">using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using System.IO;public class BundleObjectLoader : MonoBehaviour{    public string assetName = &quot;BundledSpriteObject&quot;;    public string bundleName = &quot;testbundle&quot;;    private void Start()    {        AssetBundle localAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, bundleName));        if (localAssetBundle == null)        {            Debug.LogError(&quot;Failed to load AssetBundle!&quot;);            return;        }        GameObject asset = localAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);        Instantiate(asset);        localAssetBundle.Unload(false);    }}</code></pre><p>运行当前场景，会看到之前生成的Bundle文件被实例化到场景中。<br><img src="https://longshilin.com/images/20200412010533.png" alt=""></p><p>退出播放模式。<br>从Loader中删除BundledObjectLoader组件。</p><p>用于加载AssetBundle的命令AssetBundle.LoadFromFile是同步的。<br>这意味着直到命令完成其任务（AssetBundle已完全加载）后，它才会返回。<br>对于像我们的示例这样的小捆绑包来说，这很好，但对于更大的东西（如我们在汽车或建筑预可视化程序或AAA视频游戏中可能看到的），<br>这可能会导致帧速率或响应速度下降到不可接受的程度。<br>更好的选择是LoadFromFileAsync，它可以作为协程运行，以使项目在加载AssetBundle时继续运行。</p><pre><code class="language-c#">using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;public class BundleLoaderAsync : MonoBehaviour{    public string bundleName = &quot;testbundle&quot;;    public string assetName = &quot;BundledSpriteObject&quot;;    IEnumerator Start()    {        AssetBundleCreateRequest asyncBundleRequest = AssetBundle.LoadFromFileAsync(Path.Combine(Application.streamingAssetsPath, bundleName));        yield return asyncBundleRequest;        AssetBundle localAssetBundle = asyncBundleRequest.assetBundle;        if (localAssetBundle == null)        {            Debug.LogError(&quot;Failed to load AssetBundle!&quot;);            yield break;        }        AssetBundleRequest assetRequest = localAssetBundle.LoadAssetAsync&lt;GameObject&gt;(assetName);        yield return assetRequest;        GameObject prefab = assetRequest.asset as GameObject;        Instantiate(prefab);        localAssetBundle.Unload(false);    }}</code></pre><p>BundleLoaderAsync已完成。<br>保存更改并返回到Unity Editor。<br>按播放。<br>和以前一样，捆绑对象应加载。<br>退出播放模式，并从Loader中删除BundleLoaderAsync。</p><p>从网络下载AssetBundle与从本地存储加载资产非常相似。<br>出于我们的目的，该文件托管在本地Web服务器上的根目录中。<br>创建一个名为BundleWebLoader的C＃脚本，并将其附加到Loader。<br>双击BundleWebLoader在Visual Studio中打开。</p><pre><code class="language-c#">using System.Collections;using System.Collections.Generic;using UnityEngine;public class BundleWebLoader : MonoBehaviour{    public string bundleUrl = &quot;http://127.0.0.1:8887/testbundle&quot;;    public string assetName = &quot;BundledSpriteObject&quot;;    IEnumerator Start()    {        using (WWW web = new WWW(bundleUrl))        {            yield return web;            AssetBundle remoteAssetBundle = web.assetBundle;            if (remoteAssetBundle == null)            {                Debug.LogError(&quot;Failed to download AssetBundle!&quot;);                yield break;            }            Instantiate(remoteAssetBundle.LoadAsset(assetName));            remoteAssetBundle.Unload(false);        }    }}</code></pre><p>有一个简单的Chrome扩展名<a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb/related?hl=en" target="_blank" rel="noopener">&quot;200 OK&quot;</a>。<br>它在本地主机上运行Web服务器。</p><p>BundleWebLoader完成。<br>保存更改并返回到Unity Editor。<br>按播放。<br>除非出现任何Web连接问题，否则您应该看到与前两个示例相同的结果。<br>退出播放模式。</p><h1>结尾</h1><p>AssetBundles为开发人员，用户和玩家提供了无数种可能性。<br>您一定会想出新的方法来使它们为您工作，并且掌握它们将使您能够为用户提供更有效，多功能和个性化的体验。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UnityDoc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnityDoc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity Asset可视化工具</title>
      <link href="/blog/423a6a45.html"/>
      <url>/blog/423a6a45.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html#assetgraph-user-manual" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html#assetgraph-user-manual</a></p></blockquote><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Asset Bundle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity Asset </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JetBrains中添加模板代码块</title>
      <link href="/blog/c13f7a8.html"/>
      <url>/blog/c13f7a8.html</url>
      
        <content type="html"><![CDATA[<p>在项目中直接添加模板能节省每次新建文件时需要进行的重复工作，并且在任何时候想输入模板内容可以直接输入。</p><a id="more"></a><p>一张图搞定！<br><img src="https://longshilin.com/images/20200412132022.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
          <category> JetBrains </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日子很长，但几十年很短</title>
      <link href="/blog/f56fc823.html"/>
      <url>/blog/f56fc823.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载至:<a href="https://blog.samaltman.com/the-days-are-long-but-the-decades-are-short" target="_blank" rel="noopener">https://blog.samaltman.com/the-days-are-long-but-the-decades-are-short</a></p></blockquote><p>上周我30岁，一个朋友问我在过去十年中是否想出任何值得延续的生活建议。我有点犹豫，因为我认为这些列表通常看起来很空洞，但这是我的答案的清理版本：</p><a id="more"></a><p>1）切勿将您的家人，朋友或其他重要事项放在优先事项清单上。宁愿几个真正的好朋友而不是一百个熟人。不要失去与老朋友的联系。偶尔熬夜直到太阳升起与人们交谈。开派对。</p><p>2）生活不是彩排，这可能就是事实。让它计数。时间极为有限，而且很快。做些让您快乐和充实的事情-无论如何，很少有人在死后的数百年里被人们铭记。不要做不会让您感到高兴的事情（这种情况通常在其他人希望您做某事时发生）。不要花时间尝试与您不喜欢的人保持关系，并把消极的人排除在您的生活之外。负面影响真的很糟糕。不要让自己为没有做自己想做的事情找借口。</p><p>3）如何成功：选择正确的事情（这很关键，通常被忽略），专注于自己，相信自己（尤其是当别人告诉你这将不起作用时），与可以帮助您的人建立个人联系，学习寻找人才，并努力工作。很难确定要做什么，因为原始想法很难。</p><p>4）在工作中：在您不关心的工作上很难做好。如果您不喜欢自己的工作，就很难完全幸福/充实。非常努力地工作-您选择努力工作的人数量会令人发怒-但不会那么努力，以致您的余生都会过去。无论您做什么专业，都力争成为世界上最好的。即使您错过了，您也可能会留在一个不错的地方。弄清楚自己的生产力系统-不要浪费时间杂乱无章，工作时间不理想等。不要害怕冒某些职业风险，尤其是在早期。大多数人都相当随机地选择自己的职业-认真思考自己喜欢什么，哪些领域将取得成功，并尝试与这些领域的人交谈。</p><p>5）关于金钱：金钱是否可以买到幸福，它可以买到自由，这很重要。另外，缺钱也很压力。几乎在所有方面，拥有足够的钱以使您不必担心付房租，比拥有足够的钱购买自己的喷气机更能改变您的生活。赚钱通常比花钱更有趣，尽管我个人从不后悔自己花在朋友上的钱，新经历，节省时间，旅行和我坚信的事业。</p><p>6）多与人交谈。阅读更多长篇文章，减少推文。少看电视。在互联网上花费更少的时间。</p><p>7）不要浪费时间。大多数人会浪费大部分时间，尤其是在业务上。</p><p>8）不要让自己陷入困境。就像保罗·格雷厄姆（Paul Graham）对我说的那样：“人们会变得可怕，但很难预测谁。” （自信和自大之间有很大的区别。显然，前者的目标是。）</p><p>9）每天，每年和每十年为自己制定明确的目标。</p><p>10）但是，与计划一样有价值，如果有机会，那么就应该抓住机会。不要害怕做一些鲁re的事情。努力工作的好处之一是，机会会随之而来，但是，当他们抓住机会时，仍然要取决于您。</p><p>11）尽力与聪明，有趣，有抱负的人交往。为他们工作并雇用他们（实际上，最令人满意的工作之一就是与真正的好人建立深厚的关系）。尝试与那些在自己的工作上名列世界前茅或极有希望但完全未知的人共处时光。的确，您成为了花费最多时间的人的平均水平。</p><p>12）将注意力分散在无关紧要的事物上，以最大程度地减少自己的认知负担。很难高估这是多么重要，以及大多数人对此有多糟糕。摆脱生活中的干扰。开发非常有力的方法来避免让您不喜欢堆砌而浪费您的精神周期，尤其是在您的工作生活中。</p><p>13）保持低个人燃烧率。仅此一项就可以为您提供很多生活机会。</p><p>14）夏天是最好的。</p><p>15）不要太担心。生活中的事情很少像看起来那样危险。大多数人都过于规避风险，因此大多数建议都偏向保守的道路。</p><p>16）问你想要什么。</p><p>17）如果您认为后悔不做某事，则应该这样做。遗憾是最糟糕的，大多数人后悔没有做的事情比做过的事情更多。如有疑问，请亲吻男孩/女孩。</p><p>18）运动。吃好。睡觉。有规律地进入大自然。</p><p>19）尽力帮助人们。生活中很少有事情能令人满意。对陌生人好。即使没关系，也要保持友善。</p><p>20）青年是一件非常伟大的事情。不要浪费它。实际上，在您20多岁的时候，我认为采取“给我财务纪律，但不仅限于此”的态度还可以。世界上所有的钱永远都不会找回过去的时间。</p><p>21）告诉你的父母你更爱他们。尽可能经常回家。</p><p>22）这也将过去。</p><p>23）学习狂热。</p><p>24）经常做新事物。这似乎非常重要。做新事物不仅会减慢时间感，增加幸福感，并使生活变得有趣，而且还会阻止人们以自己的思维方式进行镇定。力求在您的个人和职业生涯中，每年做一件大事，新颖事和冒险事。</p><p>25）还记得您十几岁的时候曾经多么热爱过您的男朋友吗？现在就强烈地爱他/她。还记得小时候得到的东西多么兴奋和快乐吗？现在就变得兴奋和快乐。</p><p>26）不要拧人，不要烧桥梁。仔细挑选您的战斗。</p><p>27）原谅别人。</p><p>28）不要追逐身份。没有实质的地位不会长期有效，而且无法实现。</p><p>29）大多数事情都可以适度进行。几乎没有什么可以做到的。</p><p>30）存在性焦虑是生活的一部分。在重大人生事件或重大职业里程碑之后尤其明显。它似乎特别影响聪明，有抱负的人。我认为某些人如此努力工作的原因之一是，他们不必花太多时间对此进行思考。你没有这种感觉是错的。你不是一个人。</p><p>31）感恩并保持问题直觉。不要抱怨太多 不要讨厌别人的成功（但要记住，有些人会讨厌你的成功，而你必须学会​​忽略它）。</p><p>32）做一个行动者，而不是一个说话者。</p><p>33）只要有足够的时间，就可以调整几乎任何东西，无论好坏。人类在这方面是了不起的。</p><p>34）在行动前先思考几秒钟。如果生气，请花几分钟的时间。</p><p>35）不要太快地判断别人。您永远不会知道他们的整个故事，以及他们为什么做或不做某事。善解人意。</p><p>36）日子很长，但几十年很短。</p>]]></content>
      
      
      <categories>
          
          <category> 好文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GameFramework框架学习流程</title>
      <link href="/blog/b42dd2c7.html"/>
      <url>/blog/b42dd2c7.html</url>
      
        <content type="html"><![CDATA[<p>这篇博客主要解析EventSystem源码，通过调试先实际查看这个类干了什么，然后再来分析其作用。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190921173112.png" alt="ET框架中的DLL程序集合类型"></p><p>通过上面这张图我们不难看出，ET框架中的DLL程序集合总共被分为三种类型：Model | Hotfix | Editor。当你打开ET项目时，解决方案目录也是分为这几个模块（第三方库除外），如下图。</p><p><img src="https://longshilin.com/images/20190921173250.png" alt="ET源码的解决方案目录"></p><p>下面截图中展示的是EventSystem的Add()方法，由项目入口的Init()方法所调用。</p><pre><code class="language-c#">Game.EventSystem.Add(DLLType.Model, typeof(Init).Assembly);</code></pre><p>在这个Add方法中，大概的内容是遍历Model.DLL这个程序集中的所有类，然后从中筛选出以<code>BaseAttribute</code>为基类的类引用，并将其加入到types字典中。其中需要注意的是<code>GetCustomAttributes(Type, Boolean)</code>方法，<a href="https://docs.microsoft.com/zh-cn/dotnet/api/System.Reflection.MemberInfo.GetCustomAttributes?view=netframework-4.7.2" target="_blank" rel="noopener">详见说明</a></p><p><img src="https://longshilin.com/images/20190921172631.png" alt="EventSystem的Add()方法"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> ET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
            <tag> EventSystem </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019-09-16 -- 09-20 工作日周记</title>
      <link href="/blog/2fc7a0ec.html"/>
      <url>/blog/2fc7a0ec.html</url>
      
        <content type="html"><![CDATA[<p>本周工作方面继续进行项目开发，其中比较重要的是释放技能时的需求更改和bug修复</p><p>在学习方面前面三天学习Unity Documentation，后面两天学习ET框架相关知识。</p><a id="more"></a><p>后面还是要保持学习官方文档，每天学习一点 持续渐进，冲鸭！！！</p><p><img src="https://longshilin.com/images/20190921085328.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>继续保持</title>
      <link href="/blog/73cf67d1.html"/>
      <url>/blog/73cf67d1.html</url>
      
        <content type="html"><![CDATA[<p>今天是中秋节过后的第一天上班，虽然中秋节这几天都在忙自己的东西，但是总感觉效率不高，可能是因为没看到什么成果吧。</p><a id="more"></a><p>今天将我需要看的文档用滴答清单罗列了，并且今天看了一部分，明天接着继续，我相信每天看一点，每天进一步点，最终我们会把这个Document啃下来的，因为它实在是太重要了。。。</p><p>:-）</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>刚刚上路</title>
      <link href="/blog/6e1546d4.html"/>
      <url>/blog/6e1546d4.html</url>
      
        <content type="html"><![CDATA[<p>今天上路还在找资料，不过确实收获了几个优质网站，有专门记录开源游戏的，以及学习网站等等。</p><a id="more"></a><p>等到中午睡一觉起来，开始真的看官方文档了，喜欢这个英文 <strong>Unity Documentation</strong></p><p>并且使用chrome插件diigo来记录笔记📒，日后用滴答清单布置任务和打卡。</p><p><img src="https://longshilin.com/images/20190916012317.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>折腾一天有一天，什么时候真正开始</title>
      <link href="/blog/4e801c8b.html"/>
      <url>/blog/4e801c8b.html</url>
      
        <content type="html"><![CDATA[<p>今天又折腾了一天文档，只学习了一点皮毛。。。</p><a id="more"></a><p>昨天看到一个Unity的官方wiki，然后今天想从头开始着手研究，可是研究到晚上，看完一部分教程后发现这是太基础的教程，而且太久了。。。我看的页面最后更新时间还是2012年，难以置信。</p><p>我现在算是明白了，官方文档才是重中之重，也是我现在需要学习的。熟悉官方文档中的方方面面，足矣！！！</p><p>好了，每一天都在踩坑，踩坑完又入坑。。。我太难了</p><p><img src="https://longshilin.com/images/20190914204641.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>提问的智慧</title>
      <link href="/blog/fb3832f5.html"/>
      <url>/blog/fb3832f5.html</url>
      
        <content type="html"><![CDATA[<h1>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><a id="more"></a><p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin" target="_blank" rel="noopener">Gasolin</a> 所翻译版本的最新翻译；</p><p>协助指出翻译问题，<strong>请<a href="https://github.com/ryanhanwu/smartquestions/issues/new" target="_blank" rel="noopener">发 Issue</a>，或直接<a href="https://github.com/ryanhanwu/smartquestions/compare/" target="_blank" rel="noopener">发 Pull Request</a> 给我。</strong></p><p>本文另有<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md" target="_blank" rel="noopener">繁體中文版</a>。</p><h2 id="原文版本历史"><a href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md" target="_blank" rel="noopener">原文版本历史</a></h2><h2 id="目录">目录</h2><ul><li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul><li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#%E7%BD%91%E7%AB%99%E5%92%8C-irc-%E8%AE%BA%E5%9D%9B">网站和 IRC 论坛</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li><li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li><li><a href="#%E7%94%A8%E6%B8%85%E6%99%B0%E6%AD%A3%E7%A1%AE%E7%B2%BE%E5%87%86%E5%B9%B6%E5%90%88%E6%B3%95%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">用清晰、正确、精准并合法语法的语句</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确地描述问题并言之有物</a></li><li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li><li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0-bug">别动辄声称找到 Bug</a></li><li><a href="#%E5%8F%AF%E4%BB%A5%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%BD%86%E8%BF%98%E6%98%AF%E8%A6%81%E5%85%88%E5%81%9A%E5%8A%9F%E8%AF%BE">可以低声下气，但还是要先做功课</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E7%8C%9C%E6%B5%8B">描述问题症状而非猜测</a></li><li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li><li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li><li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确的表达你的问题以及需求</a></li><li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li><li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li><li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li><li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写紧急</a></li><li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul><li><a href="#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li><li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li><li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li><li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li></ul><h2 id="声明">声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介">简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html" target="_blank" rel="noopener">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，&quot;好问题！&quot;是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt" target="_blank" rel="noopener">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前">在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href="http://groups.google.com/" target="_blank" rel="noopener">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时">当你提问时</h2><h3 id="慎选提问的论坛">慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次&quot;扫射&quot;所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="stack-overflow">Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites" target="_blank" rel="noopener">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-irc-论坛">网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步-使用项目邮件列表">第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有&quot;使用者&quot; 也有&quot;开发者&quot;（或&quot;黑客&quot;）邮件列表或论坛，而你又不会动到那些源代码，那么就向&quot;使用者&quot;列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在&quot;使用者&quot; 列表或论坛中几天都没有回复，可以试试前往&quot;开发者&quot;列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题-span-id-bespecific">使用有意义且描述明确的标题<span id="bespecific"></span></h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：<a href="http://X.org" target="_blank" rel="noopener">X.org</a> 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：<a href="http://X.org" target="_blank" rel="noopener">X.org</a> 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 <a href="http://X.org" target="_blank" rel="noopener">X.org</a> 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复">使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html" target="_blank" rel="noopener">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰-正确-精准并语法正确的语句">用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it's</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox" target="_blank" rel="noopener">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD" target="_blank" rel="noopener">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87" target="_blank" rel="noopener">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html" target="_blank" rel="noopener">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物-span-id-beprecise">精确地描述问题并言之有物<span id="beprecise"></span></h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/" target="_blank" rel="noopener">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html" target="_blank" rel="noopener">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精">话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-bug">别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课">低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测">描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状">按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程">描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复">别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求-span-id-explicit">清楚明确的表达你的问题以及需求<span id="explicit"></span></h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时-span-id-code">询问有关代码的问题时<span id="code"></span></h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来">别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句">去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html" target="_blank" rel="noopener">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急">即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪-而且有时还很有帮助-span-id-courtesy">礼多人不怪，而且有时还很有帮助<span id="courtesy"></span></h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后-加个简短的补充说明-span-id-followup">问题解决后，加个简短的补充说明<span id="followup"></span></h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案">如何解读答案</h2><p><a id="RTFM"></a></p><h3 id="rtfm-和-stfw：如何知道你已完全搞砸了">RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href="http://lmgtfy.com/" target="_blank" rel="noopener">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂">如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应">处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html" target="_blank" rel="noopener">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者">如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题">不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com" target="_blank" rel="noopener">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html" target="_blank" rel="noopener">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题">好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答">如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题">如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源">相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/" target="_blank" rel="noopener">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html" target="_blank" rel="noopener">软件发布实践</a>操作。</p><h2 id="鸣谢">鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
      
      
      <categories>
          
          <category> 好文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提问的智慧 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity完全新手指南</title>
      <link href="/blog/74df0377.html"/>
      <url>/blog/74df0377.html</url>
      
        <content type="html"><![CDATA[<p>您好，欢迎来到Unity3D 😃</p><p>如果你被某人指示，那是因为有人认为你：</p><p>在提出问题之前没有完成你的作业，或者<br>正在寻找错误地方的答案，或<br>在你走路之前试图跑步 - 也就是说，提出高级问题但缺乏基本知识才能从任何答案中获益。<br>当然，这个人可能是错的。但是你必须问自己：为什么他们认为你会从阅读中获益？我希望通过阅读本文的其余部分，然后再次阅读您的问题，您将获得答案。如果没有，你应该随便问为什么。</p><p>深呼吸，喝一杯咖啡，做好准备可能需要一段时间，然后才能回答问题。但是，我可以向您保证，如果您查看此处提供的所有信息，您将需要提出更少的问题 - 当您不得不问一个问题时，它会得到比带您到这里的更好的答案！</p><p>轻松？咖啡准备好了吗？优秀的！开始了：</p><a id="more"></a><h1>绝对新手的Unity指南</h1><p>如果你还不太了解，不要感到羞耻。这里的每个人开始时都不太了解。</p><p>现在，在你可以进入几乎完全初学者之前，这实际上是最重要的事情：在你做之前有人遇到过这个问题。事实上，相当多的人，你的问题已经得到了回答！不是半坏啊？</p><p>要找到难以捉摸的答案，这里列出了您在发布之前应该做的事情：<a href="https://longshilin.com/blog/fb3832f5.html">阅读本文！</a></p><p>阅读列表下方的文字！如果你想问一个问题（正确的方式，那就是），它拥有宝贵的信息。</p><p><a href="http://www.google.com/cse/home?cx=001712401338047450041%3Acsfhqk-trfa" target="_blank" rel="noopener">这是一个搜索的好地方</a>  可以直接搜索和Unity相关的任何东西，而且关联性极强，值得一试。</p><p>毕竟这一次还没什么？</p><p>这肯定很糟糕，但你仍然不应该发一个问题。你必须确保你不能…</p><p>帮助自己<br>许多新开发者来到这里，认为他们可以在几周内制作出精彩的游戏。让我从一开始就告诉你：如果你的游戏可以在两周内完成，那么它本来就已经完成了。要制作新游戏，您必须使用不属于教程的脚本 - 或者更确切地说，您必须具备对这些脚本进行简单更改的技能。你绝对必须具备编程的基本知识。如果你不这样做，你的问题将反映出你的无能，你将很难得到你的问题的答案。</p><p>如果您觉得自己不知道如何编码，这些链接将帮助您：</p><p><a href="http://msdn.microsoft.com/en-us/library/aa288436(VS.71).aspx" target="_blank" rel="noopener">微软的初学者话题</a></p><p><a href="http://www.homeandlearn.co.uk/csharp/csharp.html" target="_blank" rel="noopener">彻底的课程</a></p><p>现在你已经掌握了编程的基本知识（？），你仍然需要Unity3D的基本知识 - 代码运行的环境：</p><p><a href="http://unity3d.com/support/documentation/ScriptReference/index.html" target="_blank" rel="noopener">脚本参考</a>仔细阅读每一小节。</p><p>这里有一些其他<a href="http://wiki.unity3d.com/index.php?title=Programming" target="_blank" rel="noopener">编程好东西</a>，我认为值得<a href="http://wiki.unity3d.com/index.php?title=CSharp_Unity_Tutorial" target="_blank" rel="noopener">特别提及。</a> 在左侧的所有链接上看一眼。我敢打赌，至少有一小部分对你有用！</p><p>这是<a href="http://forum.unity3d.com/threads/19302-Scripting-Section-FAQ" target="_blank" rel="noopener">您发布的论坛</a>的<a href="http://forum.unity3d.com/threads/19302-Scripting-Section-FAQ" target="_blank" rel="noopener">常见问题解答。</a>你应该阅读所有的链接和两个帖子 - 它甚至可能有你的具体问题的答案！</p><p><a href="http://unity3d.com/support/resources/tutorials/" target="_blank" rel="noopener">Unity团队的教程</a>我强烈推荐3D平台游戏教程。</p><p><a href="http://www.burgzergarcade.com/hack-slash-rpg-unity3d-game-engine-tutorial" target="_blank" rel="noopener">BurgZerg视频教程</a></p><p><a href="http://www.youtube.com/playlist?list=PL11F87EB39F84E292&amp;feature=plcp" target="_blank" rel="noopener">TornadoTwins视频教程</a></p><p><a href="http://walkerboystudio.com/html/unity_training___free__.html#unity3javaScript" target="_blank" rel="noopener">Walker Boys视频教程</a></p><p>现在，如果您查看了所有这些教程，但仍然没有答案，那么是时候学习…</p><h3 id="如何寻求帮助">如何寻求帮助</h3><p>这里的大多数人都忙于自己的项目，当他们决定花几分钟回答问题时，他们有很多问题可供选择。如果您希望这些忙碌的人选择您的问题，您必须付出一些努力。始终牢记：<em>问题的质量越好，答案的质量就越好。</em></p><p>以下是一些问题从未得到答案的主要原因列表：</p><ul><li><strong>您的问题之前已经多次回答：</strong><br>如果你已经为你的问题提出了一个好的标题（见下文），那么对它进行搜索可能会给你很多好结果。</li></ul><ul><li><strong>您的代码很难阅读：</strong><br>在代码周围使用[code] [/ code]（删除空格），然后使用’Preview Post’按钮确保它漂亮漂亮。这非常重要。</li></ul><ul><li><strong>你的问题不明白：</strong><br>注意用尽可能最好的英语来表达你的问题，检查你的拼写，不要使用你在报纸上找不到的单词。请听下面链接的建议。</li></ul><p>在最简单的形式中，一个好的问题描述了它<strong><em>应该</em></strong>如何工作，然后描述它<strong><em>是</em></strong>如何工作的（发生了意想不到的事情？）。</p><p>如果你能做到这一点，我会说你在家是免费的。问和你会收到！</p><p>如果你认为那有点模糊，你就是对的。这里有一些精选的主题可以帮助你提出很好的问题！</p><p><a href="https://longshilin.com/blog/fb3832f5.html#explicit">我为什么要在乎？</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#bespecific">一个好头衔</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#beprecise">一个很好的描述</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#code">询问代码</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#courtesy">要有礼貌</a></p><p><a href="https://longshilin.com/blog/fb3832f5.html#followup">跟进！</a></p><p>最后一个链接的一个非常重要的引用：</p><p><em>“最后，并非最不重要的是，这种跟进有助于所有协助人员对问题感到满意的感觉。如果你自己不是技术人员或黑客，请相信我们这种感觉对于你挖掘的专家和专家来说非常重要寻求帮助。问题叙述可以追溯到未解决的虚无事件;令人沮丧的事情就是令人沮丧;黑客痒痒地看到它们已经解决了。抓住那些痒痒的善意会让你在下次需要提出问题时非常非常有帮助。“</em></p><p>您可能已经注意到这些链接都来自同一个网页。我已经列出了你的基本要素，但你可以通过阅读它来帮助自己。</p><h3 id="结算笔记">结算笔记</h3><p>在离开之前，我应该警告你，大多数经常访问这个论坛的人都可以告诉你是否已经关注这些链接（并阅读它们！）。</p><p>从好的方面来说，他们可以判断你是否遵循这些链接（并阅读它们！）</p><p>如果你已经完成了自己的<strong>学习</strong>，<strong>寻找</strong>并提出一个<strong>好</strong>问题，我保证你会认识到这一点并找时间回答你的问题。</p><p>我祝你在努力中一切顺利，并希望这篇文章能让你走上有朝一日回答问题的道路。😃</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Unity Wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity Beginner Guide </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>该想想奋斗的方向啦</title>
      <link href="/blog/493fd4d4.html"/>
      <url>/blog/493fd4d4.html</url>
      
        <content type="html"><![CDATA[<p>今天是2019年中秋节，就在昨晚我在网上搜寻了一些关于游戏开发的资料，发现能学习到的和应该要学习的东西还有好多好多，但是我现在最需要做的事情是熟悉整个Unity的基础开发流程。</p><p>这其中就包括游戏动画，游戏特效，shader，材质等等。有关于unity本身开发的知识面，需要尽快扩展和熟悉。</p><p>在这之后才是框架层面的东西和服务器相关的东西。</p><p>加油吧骚年！！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>比较unity中Update、LateUpdate和FixedUpdate三者的区别</title>
      <link href="/blog/f299411.html"/>
      <url>/blog/f299411.html</url>
      
        <content type="html"><![CDATA[<p>我们在进行unity开发游戏时，经常会遇见Update、LateUpdate和FixedUpdate这三者。下面我依照官方文档说明，总结一下三者的区别。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Unity基础入门学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C# Job System 概述</title>
      <link href="/blog/c28c374b.html"/>
      <url>/blog/c28c374b.html</url>
      
        <content type="html"><![CDATA[<h3 id="c-作业系统是如何工作">C# 作业系统是如何工作</h3><ul><li>允许用户编写与Unity其余部分良好交互的<a href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)" target="_blank" rel="noopener">多线程代码</a>，并使编写正确的代码变得更加容易。</li><li>编写多线程代码可以提供高性能的好处，其中包括<strong>帧速率的显著提高</strong>、以及将Burst编译器与C#作业一起使用<strong>可以提高代码生成质量</strong>，<strong>从而大大降低移动设备的电池消耗。</strong></li><li>一个重要方面是它与Unity内部使用的集成（Unity的本地作业系统）。用户编写的diamante和Unity共享<a href="https://docs.microsoft.com/zh-cn/cpp/parallel/multithreading-creating-worker-threads?view=vs-2019" target="_blank" rel="noopener">工作线程</a>，这种合作避免了创建比CPU核心更多的线程，从而降低对CPU资源的争用。</li></ul><a id="more"></a><p>相关资料整理：</p><ul><li>官方文档：<a href="https://docs.unity3d.com/Manual/JobSystem.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/JobSystem.html</a></li><li>官方示例：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md</a></li><li>官方视频：<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是多线程？</title>
      <link href="/blog/b293e36.html"/>
      <url>/blog/b293e36.html</url>
      
        <content type="html"><![CDATA[<p>在单线程计算系统中，一次进入一条指令，一次出现一条结果。加载和完成程序的时间取决于CPU需要完成的工作量。</p><p>多线程是一种编程，它利用CPU在多个内核上同时处理多个线程的能力。它们不是一个接一个地执行任务或指令，而是同时运行。</p><a id="more"></a><p>默认情况下，一个线程在程序的开头运行。这是“主线”。主线程创建新线程来处理任务。这些新线程彼此并行运行，并且通常在完成后将其结果与主线程同步。</p><p>如果您有一些运行很长时间的任务，这种多线程方法很有效。但是，游戏开发代码通常包含许多一次执行的小指令。如果为每个线程创建一个线程，最终可能会有许多线程，每个线程的生命周期都很短。这可以推动CPU和操作系统处理能力的极限。</p><p>通过拥有一个<a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener">线程池</a>可以缓解线程生存期的问题。但是，即使您使用线程池，也可能同时激活大量线程。线程数多于CPU核心导致线程相互竞争CPU资源，导致频繁的<a href="https://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener">上下文切换</a>。上下文切换是通过执行保存线程状态，然后处理另一个线程，然后重新构建第一个线程以继续处理它的过程。上下文切换是资源密集型的，因此您应尽可能避免使用它。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是工作制度？</title>
      <link href="/blog/2b778a74.html"/>
      <url>/blog/2b778a74.html</url>
      
        <content type="html"><![CDATA[<p>作业系统通过创建<a href="https://en.wikipedia.org/wiki/Job_(computing)" target="_blank" rel="noopener">作业</a>而不是线程来管理<a href="https://docs.unity3d.com/Manual/JobSystemMultithreading.html" target="_blank" rel="noopener">多线程代码</a>。</p><p>作业系统跨多个核心管理一组<a href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-creating-worker-threads" target="_blank" rel="noopener">工作线程</a>。它通常每个<a href="https://www.howtogeek.com/194756/cpu-basics-multiple-cpus-cores-and-hyper-threading-explained/" target="_blank" rel="noopener">逻辑CPU核心</a>有一个工作线程，以避免上下文切换（尽管它可能为操作系统或其他专用应用程序保留一些核心）。</p><a id="more"></a><p>作业系统将作业放入<a href="https://en.wikipedia.org/wiki/Job_queue" target="_blank" rel="noopener">作业队列中</a>以执行。作业系统中的工作线程从作业队列中获取项目并执行它们。作业系统管理<a href="http://tutorials.jenkov.com/ood/understanding-dependencies.html" target="_blank" rel="noopener">依赖关系</a>并确保作业以适当的顺序执行。</p><h4 id="什么是工作？">什么是工作？</h4><p>工作是完成一项特定任务的一小部分工作。作业接收参数并对数据进行操作，类似于方法调用的行为方式。作业可以是自包含的，也可以依赖其他作业在运行之前完成。</p><h4 id="什么是工作依赖？">什么是工作依赖？</h4><p>在复杂的系统中，如游戏开发所需的系统，每个作业都不可能是独立的。一项工作通常是为下一份工作准备数据。工作人员知道并支持依赖关系以使其工作。如果<code>jobA</code>具有依赖性<code>jobB</code>，则作业系统确保在完成<code>jobA</code>之前不会开始执行<code>jobB</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>创建作业</title>
      <link href="/blog/208be653.html"/>
      <url>/blog/208be653.html</url>
      
        <content type="html"><![CDATA[<p>要在Unity中创建作业，您需要实现<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.html" target="_blank" rel="noopener">IJob</a>接口。<code>IJob</code>允许您安排与正在运行的任何其他作业并行运行的单个作业。</p><p>注意：“作业”是Unity中用于实现<code>IJob</code>接口的任何结构的集合术语。</p><a id="more"></a><p>要创建工作，您需要：</p><ul><li>创建一个实现的结构<code>IJob</code>。</li><li>添加作业使用的成员变量（<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable类型</a>或<a href="https://docs.unity3d.com/Manual/JobSystemNativeContainer.html" target="_blank" rel="noopener">NativeContainer</a>类型）。</li><li>在结构中创建一个名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.Execute.html" target="_blank" rel="noopener">Execute</a>的方法，并在其中实现作业。</li></ul><p>执行作业时，该<code>Execute</code>方法在单个核心上运行一次。</p><p>注意：在设计作业时，请记住它们对数据副本进行操作，除非是<code>NativeContainer</code>。因此，从主线程中的作业访问数据的唯一方法是写入<code>NativeContainer</code>。</p><h2 id="简单作业定义的一个示例">简单作业定义的一个示例</h2><pre><code class="language-csharp">// Job adding two floating point values togetherpublic struct MyJob : IJob{    public float a;    public float b;    public NativeArray&lt;float&gt; result;    public void Execute()    {        result[0] = a + b;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安排工作</title>
      <link href="/blog/fdd0c96a.html"/>
      <url>/blog/fdd0c96a.html</url>
      
        <content type="html"><![CDATA[<p>要在主线程中安排作业，您必须：</p><ul><li>实例化作业。</li><li>填充作业的数据。</li><li>调用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>方法。</li></ul><p>调用<code>Schedule</code>将作业放入作业队列以便在适当的时间执行。一旦安排，你就不能打断工作。</p><a id="more"></a><p><strong>注意</strong>：您只能<code>Schedule</code>从主线程调用。</p><h4 id="安排工作的一个例子">安排工作的一个例子</h4><pre><code class="language-csharp">// Create a native array of a single float to store the result. This example waits for the job to complete for illustration purposesNativeArray&lt;float&gt; result = new NativeArray&lt;float&gt;(1, Allocator.TempJob);// Set up the job dataMyJob jobData = new MyJob();jobData.a = 10;jobData.b = 10;jobData.result = result;// Schedule the jobJobHandle handle = jobData.Schedule();// Wait for the job to completehandle.Complete();// All copies of the NativeArray point to the same memory, you can access the result in &quot;your&quot; copy of the NativeArrayfloat aPlusB = result[0];// Free the memory allocated by the result arrayresult.Dispose();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并行工作</title>
      <link href="/blog/3c908d6c.html"/>
      <url>/blog/3c908d6c.html</url>
      
        <content type="html"><![CDATA[<p>当<a href="https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html" target="_blank" rel="noopener">调度工作</a>，只能有一个工作做一个任务。在游戏中，通常希望对大量对象执行相同的操作。有一个名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobParallelFor.html" target="_blank" rel="noopener">IJobParallelFor</a>的独立作业类型来处理这个问题。</p><p><strong>注意</strong>：“ParallelFor”作业是Unity中用于实现<code>IJobParallelFor</code>接口的任何结构的集合术语。</p><a id="more"></a><p>ParallelFor作业使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html" target="_blank" rel="noopener">NativeArray</a>数据作为其数据源。ParallelFor作业跨多个核心运行。每个核心有一个作业，每个作业处理一部分工作量。<code>IJobParallelFor</code>表现得像<code>IJob</code>，但它不是单个<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJob.Execute.html" target="_blank" rel="noopener">Execute</a>方法，而是<code>Execute</code>在数据源中的每个项目上调用一次方法。方法中有一个整数参数<code>Execute</code>。该索引用于访问和操作作业实现中的数据源的单个元素。</p><h4 id="parallelfor作业定义的示例：">ParallelFor作业定义的示例：</h4><pre><code class="language-csharp">struct IncrementByDeltaTimeJob: IJobParallelFor{    public NativeArray&lt;float&gt; values;    public float deltaTime;    public void Execute (int index)    {        float temp = values[index];        temp += deltaTime;        values[index] = temp;    }}</code></pre><h4 id="调度parallelfor作业">调度ParallelFor作业</h4><p>在调度ParallelFor作业时，必须指定<code>NativeArray</code>要拆分的数据源的长度。<code>NativeArray</code>如果结构中有多个，Unity C＃作业系统无法知道您要将哪个用作数据源。长度还告诉C＃作业系统需要多少<code>Execute</code>方法。</p><p>幕后花絮，ParallelFor作业的调度更复杂。在调度ParallelFor作业时，C＃作业系统将工作分成批处理以在核心之间分配。每批包含一组<code>Execute</code>方法。然后，C＃作业系统在每个CPU核心的Unity本机作业系统中调度最多一个作业，并将该本机作业通过一些批次来完成。</p><p><a href="https://docs.unity3d.com/uploads/Main/jobsystem_parallelfor_job_batches.svg" target="_blank" rel="noopener"><img src="https://longshilin.com/images/20190811161551.png" alt="ParallelFor在核心之间划分批次的作业"></a></p><p>当本地作业在其他作业之前完成其批处理时，它会从其他本机作业中<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener">窃取</a>剩余批处理。它一次只能窃取本机作业剩余批次的一半，以确保<a href="https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance" target="_blank" rel="noopener">缓存局部性</a>。</p><p>要优化过程，您需要指定批次计数。批次计数控制您获得的作业数量，以及线程之间工作重新分配的细化程度。批量计数较低（例如1）可以使线程之间的工作分布更均匀。它确实带来了一些开销，所以有时候增加批量计数会更好。从1开始并增加批次计数直到可忽略不计的性能增益是一种有效的策略。</p><h4 id="调度parallelfor作业的示例">调度ParallelFor作业的示例</h4><p><strong>工作代码</strong>：</p><pre><code class="language-csharp">// Job adding two floating point values togetherpublic struct MyParallelJob : IJobParallelFor{    [ReadOnly]    public NativeArray&lt;float&gt; a;    [ReadOnly]    public NativeArray&lt;float&gt; b;    public NativeArray&lt;float&gt; result;    public void Execute(int i)    {        result[i] = a[i] + b[i];    }}</code></pre><p><strong>主线程代码</strong>：</p><pre><code class="language-csharp">NativeArray&lt;float&gt; a = new NativeArray&lt;float&gt;(2, Allocator.TempJob);NativeArray&lt;float&gt; b = new NativeArray&lt;float&gt;(2, Allocator.TempJob);NativeArray&lt;float&gt; result = new NativeArray&lt;float&gt;(2, Allocator.TempJob);a[0] = 1.1;b[0] = 2.2;a[1] = 3.3;b[1] = 4.4;MyParallelJob jobData = new MyParallelJob();jobData.a = a;jobData.b = b;jobData.result = result;// Schedule the job with one Execute per index in the results array and only 1 item per processing batchJobHandle handle = jobData.Schedule(result.Length, 1);// Wait for the job to completehandle.Complete();// Free the memory allocated by the arraysa.Dispose();b.Dispose();result.Dispose();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOTS原则和愿景</title>
      <link href="/blog/5628dba2.html"/>
      <url>/blog/5628dba2.html</url>
      
        <content type="html"><![CDATA[<p>Unity Data Oriented Tech Stack基于一系列原则。这些原则为我们正在努力实现的目标提供了良好的背景。一些原则清楚地反映在代码中。其他则只是我们为自己设定的目标。</p><a id="more"></a><h4 id="默认情况下的性能">默认情况下的性能</h4><p>我们希望为所有平台创建高效的机器代码变得简单。</p><p>我们使用手写的高度优化的<a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="noopener">simd</a>内在函数来衡量C ++中可以实现的性能。</p><p>我们使用编译器技术（Burst），容器（Unity.Collections），数据布局组件（ECS）的组合，以便在默认情况下轻松编写高效代码。</p><ul><li>数据布局和迭代 - 实体组件系统在默认情况下以块的形式迭代实体时保证线性数据布局。这是面向统一数据的技术栈提供性能提升的关键部分。</li><li>C＃作业系统允许您以简单的方式编写多线程代码。这也很安全。C＃Job Debugger可以检测任何竞争条件。</li><li>Burst是我们专门针对C＃作业的编译器。C＃作业代码遵循我们可用于生成更高效的机器代码的某些模式。使用SIMD指令为每个目标平台编译和优化代码。</li></ul><p>这方面的一个例子是Instantiation的性能。与实例化具有320字节memcpy的100,000个实体需要9ms的理论限制相比，通过实体组件系统实例化这些实体需要10ms。所以我们非常接近理论极限。</p><p>在Unite Austin，我们在60 FPS的大型战斗模拟中展示了一个包含100,000个独立单元的演示。所有游戏代码都运行多核。 [参见ECS性能演示<a href="https://www.youtube.com/watch?v=0969LalB7vw" target="_blank" rel="noopener">视频]</a></p><h4 id="简单">简单</h4><p>编写<a href="https://en.wiktionary.org/wiki/performant" target="_blank" rel="noopener">高性能</a>代码必须简单。我们相信我们可以编写快速代码，就像<strong>MonoBehaviour.Update</strong>一样简单。</p><blockquote><p>注意：为了正确设定期望，我们认为我们仍有一些方法可以实现这一目标。</p></blockquote><h4 id="编写代码的一种方法">编写代码的一种方法</h4><p>我们想要定义编写游戏代码、编辑器代码、资产管道代码以及引擎代码的单一方式。我们相信这为我们的用户创造了一个更简单的工具，并且更有能力改变现状。</p><p>物理学是一个很好的例子。目前物理学是一种黑盒解决方案。在实践中，许多开发人员希望调整模拟代码以适应他们的游戏需求。如果使用ECS以与游戏代码相同的方式编写物理引擎代码，则可以轻松地在现有物理仿真阶段之间插入您自己的仿真代码或完全控制。</p><p>另一个例子，让我们想象你想制作一个可以进行大规模修改的游戏。</p><p>如果我们的导入管道是作为一组<strong>ComponentSystems实现的</strong>。我们有一些FBX导入管道代码，默认情况下在资产管道中用于导入和后处理FBX文件。（在编辑器中使用Mesh和FBX导入代码。）</p><p>然后，很容易配置程序包管理器，可以在已部署的游戏中使用相同的FBX导入和后处理代码进行修改。</p><p>我们相信，在基础层面，这将使Unity比现在更加灵活。</p><h4 id="联网">联网</h4><p>我们想要定义一种编写所有游戏代码的简单方法。遵循此方法，您的游戏可以使用三种网络架构中的一种，具体取决于您创建的游戏类型。</p><p>我们专注于为托管游戏提供最佳的网络引擎支持。使用最近收购的<a href="http://multiplay.com/" target="_blank" rel="noopener">Multiplay.com</a>服务，我们提供了一个简单的管道来托管所述游戏。</p><ul><li>FPS - 服务器上的模拟</li><li>RTS - 确定性锁步模拟</li><li>街机游戏 - GGPO</li></ul><blockquote><p>注意：为了正确设置期望，我们尚未在实体组件系统之上提供任何网络代码。它正在进行中。</p></blockquote><h4 id="确定性">确定性</h4><p>我们的构建管道必须是<a href="https://en.wikipedia.org/wiki/Deterministic_algorithm" target="_blank" rel="noopener">确定性的</a>。用户可以选择是否所有模拟代码都应该确定性地运行。</p><p>无论使用何种设备，您都应该使用相同的输入获得相同的结果。这对于网络，重放功能甚至高级调试工具都很重要。</p><p>为此，我们将利用Burst编译器在不同平台之间生成精确的浮点数学运算。想象一下，运行相同浮点数学代码的linux服务器和iOS设备。这对于许多场景非常有用，特别是对于连接的游戏，还有调试，重放等。</p><blockquote><p>注意：浮点数学差异是Unity决定解决的问题。这个问题已经有一段时间了解，但到目前为止还没有足够的需要来鼓励人们解决它。为了解决这个问题，包括避免解决问题所需的一些解决方法，请考虑阅读<a href="https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/" target="_blank" rel="noopener">Bruce Dawson的浮点确定性</a>。</p></blockquote><h4 id="沙盒">沙盒</h4><p>Unity是一个沙盒，安全而简单。</p><p>当错误地使用API时，我们提供了很好的错误消息，我们从未将自己置于不正确的使用导致崩溃的位置，这是设计上的（而不是我们可以快速修复的错误）。</p><p>沙箱行为的一个很好的例子是我们的C＃作业系统保证您的C＃作业代码都没有竞争条件。我们通过静态代码分析和运行时检查的组合确定性地检查所有可能的竞争条件。我们会立即为您提供有关任何竞赛条件的错误信息。因此，您可以相信您的代码可以正常工作并且感觉安全，即使是第一次编写多线程游戏代码的开发人员也会做得很好。</p><h4 id="极小性">极小性</h4><p>我们希望Unity可用于从&lt;50kb可执行文件，到千兆字节大小的游戏的所有内容。我们希望Unity在不到1秒的时间内加载小内容。</p><h4 id="迭代时间">迭代时间</h4><p>我们的目标是在大型项目文件夹中任何常见操作的迭代时间保持500ms以下。</p><p>作为一个例子，我们正在努力将C＃编译器重写为完全增量，目标是：</p><blockquote><p>在大型项目中更改单个.cs文件时。组合的编译和热重载时间应小于500毫秒。</p></blockquote><h4 id="我们的代码提供完整的单元测试覆盖率">我们的代码提供完整的单元测试覆盖率</h4><p>我们相信从一开始就提供强大的代码。我们使用单元测试来证明我们的代码在开发人员编写和提交时正常工作。测试作为包的一部分提供。</p><h4 id="演化">演化</h4><p>我们知道我们在如何编写代码方面提出了相当大的改变。从MonoBehaviour.Update到ComponentSystem并使用作业。</p><p>我们相信，最终唯一可以说服游戏开发者的是<strong>尝试它，并亲眼看到自己的游戏结果</strong>。</p><p>因此，在现有项目中应用ECS方法应该容易且快速。我们的目标是在30分钟内，用户可以在大型项目中将一些代码从MonoBehaviour.Update更改为ComponentSystem，并拥有优化游戏代码的成功经验。</p><h4 id="包">包</h4><p>我们希望我们的大多数引擎代码都是用C＃编写的，并部署在一个Package中。所有Unity Pro客户均可使用所有源代码。</p><p>我们希望与客户建立快速反馈循环，因为我们可以推送代码并在包中快速获得反馈，而不会破坏其他部分的稳定性。</p><p>以前我们的大多数引擎代码都是用C ++编写的，这与我们的客户编写代码的方式以及Unity的程序员如何编写代码产生了脱节。由于Burst编译器技术和ECS，我们可以用C＃代码实现比C ++更好的结果，因此我们都能以完全相同的方式编写代码。</p><h4 id="合作">合作</h4><p>我们相信Unity用户和Unity开发人员都在同一个团队中。我们的目的是帮助所有Unity用户更快，更高质量和更好的性能创建最佳游戏体验。</p><p>我们相信，我们开发的每个功能都必须尽早开发真实的场景和真实的生产反馈。包管理器促进了这一点。</p><p>对于那些希望贡献引擎代码的社区用户，我们的目标是通过直接处理贡献者可以提交的相同代码存储库来实现这一目标。通过明确的原则和所有功能的全面测试覆盖，我们希望保持高贡献的质量。</p><p>源代码存储库将适用于所有Unity Pro客户。</p><h4 id="透明度">透明度</h4><p>我们相信透明度。我们公开发展我们的功能，我们在论坛和博客上积极沟通。我们保留时间，以便每个开发人员都可以花时间与客户一起了解用户的痛点。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> DOTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOTS学习资源</title>
      <link href="/blog/a6702756.html"/>
      <url>/blog/a6702756.html</url>
      
        <content type="html"><![CDATA[<p>以下是一些面向数据的资源，可以是Unity或我们已经验证过的外部资源。我们将包括外部资源，我们认为这些外部资源能够很好地理解面向数据的设计并包含高质量的信息（在贡献时）。</p><a id="more"></a><blockquote><p><strong>注意</strong>：由于Unity Data-Oriented Tech Stack的性质不断变化，链接可能会过时。将检查页面以确保它包含最佳资源，但如果您发现过时或断开链接的内容，请确保在<a href="http://unity3d.com/performance-by-default" target="_blank" rel="noopener">论坛中</a>告知我们或作为存储库中的<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/issues/new" target="_blank" rel="noopener">问题</a>。</p></blockquote><h4 id="教程">教程</h4><ul><li><a href="https://www.youtube.com/watch?v=WLfhUKp2gag&amp;list=PLX2vGYjWbI0S4yHZwjDI1boIrYStpBCdN" target="_blank" rel="noopener">Mike Geig的实体组件系统和C＃作业系统简介</a>（五部分视频教程系列。）</li></ul><h4 id="活动资源">活动资源</h4><p><img src="https://longshilin.com/images/20190811211722.jpg" alt=""></p><h5 id="unity-at-unite-la-2018">Unity at Unite LA 2018</h5><ul><li>[主题演讲：Joachim Ante和MartinKümmel的MEGACITY演示<a href="https://youtu.be/alZ6wmwvck0?t=6448" target="_blank" rel="noopener">视频]</a></li><li>[ECS：Joachim Ante的欢迎和概述<a href="https://youtu.be/fZfPv-oxO7U?t=545" target="_blank" rel="noopener">视频]</a></li><li>[ECS：由Mike Acton扩展的LOD和剔除系统<a href="https://youtu.be/fZfPv-oxO7U?t=4126" target="_blank" rel="noopener">视频]</a></li><li>[ECS：Andreas Fredriksson和Lee Hammerton的基于样条的AI代理<a href="https://youtu.be/fZfPv-oxO7U?t=7725" target="_blank" rel="noopener">视频]</a></li><li>[ECS：深入探索由Alexandre Mutel创作的Burst Compiler <a href="https://www.youtube.com/watch?v=fZfPv-oxO7U&amp;feature=youtu.be&amp;t=14930" target="_blank" rel="noopener">视频]</a></li><li>[ECS：韦恩·约翰逊在ECS世界中的图形驱动音频<a href="https://youtu.be/fZfPv-oxO7U?t=18550" target="_blank" rel="noopener">视频]</a></li><li>[ECS：马丁·库默尔（MartinKümmel）在预算上建立一个充满活力的呼吸世界<a href="https://youtu.be/fZfPv-oxO7U?t=22209" target="_blank" rel="noopener">视频]</a></li><li>[ECS：使用Daniel Brauer的实体调试器<a href="https://youtu.be/fZfPv-oxO7U?t=27107" target="_blank" rel="noopener">视频]</a></li><li>[ECS：FabriceLété和Simon Mogensen的流媒体和序列化<a href="https://youtu.be/fZfPv-oxO7U?t=29353" target="_blank" rel="noopener">视频]</a></li><li>[ECS：Aria Bonczek对ECS API的演变<a href="https://youtu.be/fZfPv-oxO7U?t=32882" target="_blank" rel="noopener">视频]</a></li></ul><p><img src="https://longshilin.com/images/20190811211728.jpg" alt=""></p><h5 id="unity-at-gdc-2018">Unity at GDC 2018</h5><ul><li>[主题演讲：Joachim Ante的Unity（实体组件系统和性能）的未来<a href="https://www.youtube.com/watch?v=3Mq9EH8RT_U" target="_blank" rel="noopener">视频]</a></li><li>[由Joachim Ante演变的团结<a href="https://www.youtube.com/watch?v=aFFLEiDr3T0" target="_blank" rel="noopener">视频]</a></li><li>[Tim Johansson的Unity作业系统和实体组件系统<a href="https://www.youtube.com/watch?v=kwnb9Clh2Is" target="_blank" rel="noopener">视频]</a></li><li>[面向数据的设计民主化：Mike Acton使用组件系统的面向数据的方法<a href="https://www.youtube.com/watch?v=p65Yt20pw0g" target="_blank" rel="noopener">视频]</a></li><li>[C＃Sharp to Machine Code by Andreas Fredriksson <a href="https://www.youtube.com/watch?v=NF6kcNS6U80" target="_blank" rel="noopener">视频]</a></li><li>[Vladimir Vukicevic的小事ECS <a href="https://www.youtube.com/watch?v=EWVU6cFdmr0" target="_blank" rel="noopener">视频]</a></li><li>[独家：Unity在GDC上采取原则性步骤进行AAA级演出<a href="https://www.mcvuk.com/development/exclusive-unity-takes-a-principled-step-into-triple-a-performance-at-gdc" target="_blank" rel="noopener">文章]</a></li></ul><p><img src="https://longshilin.com/images/20190811211732.jpg" alt=""></p><h5 id="unity-at-unite-austin-2017">Unity at Unite Austin 2017</h5><ul><li>[主题演讲：性能演示ft.Nordeus by Joachim Ante <a href="http://www.youtube.com/watch?v=0969LalB7vw" target="_blank" rel="noopener">视频]</a></li><li>[Nordeus演示的Unity GitHub存储库<a href="https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation" target="_blank" rel="noopener">视频]</a></li><li>[编写Joachim Ante的高性能C＃脚本<a href="http://www.youtube.com/watch?v=tGmnZdY5Y-E" target="_blank" rel="noopener">视频]</a></li></ul><p>（原文页面：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/ECSSamples/Documentation/resources.md" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/ECSSamples/Documentation/resources.md</a>）</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> DOTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOTS概述</title>
      <link href="/blog/c1466196.html"/>
      <url>/blog/c1466196.html</url>
      
        <content type="html"><![CDATA[<p>Unity数据导向技术栈有三个主要部分：Unity实体 - 组件 - 系统（ECS），Unity C＃作业系统和Unity Burst编译器。</p><a id="more"></a><h4 id="实体-组件-系统概述">实体 - 组件 - 系统概述</h4><p>ECS提供了一种游戏设计方法，使您可以专注于您正在解决的实际问题：组成游戏的数据和行为。ECS利用C＃作业系统和Burst编译器来充分利用当今的多核处理器。</p><p>除了更好地利用现代CPU之外，ECS背后<a href="https://en.wikipedia.org/wiki/Data-oriented_design" target="_blank" rel="noopener">的面向数据的</a>设计避免了<a href="https://simple.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">面向对象</a>的陷阱，这些陷阱可能困扰游戏等复杂项目，尤其是在尝试寻找最后几个FPS以达到您的发布目标时。面向数据的设计还可以使您更轻松地重用和发展您的代码，并让其他人理解和处理它。有关更多信息，请参阅：</p><ul><li><a href="https://www.cnblogs.com/longsl/p/11322011.html" target="_blank" rel="noopener">什么是ECS？</a></li><li><a href="https://www.cnblogs.com/longsl/p/11323671.html" target="_blank" rel="noopener">ECS原则</a></li><li><a href="https://www.cnblogs.com/longsl/p/11323715.html" target="_blank" rel="noopener">ECS适合你吗？</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/index.html" target="_blank" rel="noopener">ECS手册和脚本参考</a></li></ul><h4 id="c-作业系统概述">C＃作业系统概述</h4><p>C＃Job System利用了当今计算机中的多核。它旨在将此方法运用到C＃用户脚本，并允许用户编写安全，快速，有效的代码，同时防止多线程的一些陷阱，如竞争条件。</p><ul><li><a href="https://docs.unity3d.com/Manual/JobSystem.html" target="_blank" rel="noopener">C＃作业系统手册</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.jobs@0.0/manual/custom_job_types.html" target="_blank" rel="noopener">低级概述 - 创建容器和自定义作业类型</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.jobs@0.0/manual/scheduling_a_job_from_a_job.html" target="_blank" rel="noopener">从工作中安排工作 - 为什么不呢？</a></li></ul><h4 id="burst概述">Burst概述</h4><p>Burst是一种新的基于<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM</a>的后端编译器技术，可以让您更轻松。它需要C＃作业并利用您平台的特定功能生成高度优化的机器代码。因此，您可以在多个平台上获得手动调整的汇编程序代码的诸多好处，而无需付出艰苦的努力。Burst编译器可用于提高为C＃作业系统编写的作业的性能。</p><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.burst@1.0/manual/index.html" target="_blank" rel="noopener">Burst文档</a></li><li><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/ECSSamples/Documentation/burst_optimization.md" target="_blank" rel="noopener">如何针对Burst编译器进行优化</a></li></ul><h4 id="更多的信息">更多的信息</h4><ul><li><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/ECSSamples/Documentation/cheatsheet.md" target="_blank" rel="noopener">Unity Data-Oriented的备忘单</a></li><li><a href="https://www.cnblogs.com/longsl/p/11319782.html" target="_blank" rel="noopener">Unity Data-Oriented的学习资源</a></li><li><a href="https://www.cnblogs.com/longsl/p/11323845.html" target="_blank" rel="noopener">默认情况下的性能</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> DOTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DOTS默认情况下的性能</title>
      <link href="/blog/9c7fc9b9.html"/>
      <url>/blog/9c7fc9b9.html</url>
      
        <content type="html"><![CDATA[<p>利用Unity全新的高性能多线程数据导向技术堆栈（DOTS），充分利用当今的多核处理器。您的游戏运行速度更快，您的代码更易于在其他项目中阅读和重用。</p><a id="more"></a><h4 id="重建unity的核心">重建Unity的核心</h4><p>我们正在使用高性能多线程数据导向技术堆栈重建Unity的核心基础。DOTS使您的游戏可以充分利用最新的多核处理器，而不会遇到繁重的编程问题。DOTS包括以下功能：</p><ul><li>用于高效运行多线程代码<strong>的C＃作业系统</strong>。</li><li>用于编写高性能代码<strong>的实体组件系统（ECS）</strong>。</li><li><strong>Burst Compiler</strong>用于生成高度优化的本机代码。</li></ul><p>这些DOTS功能为程序员提供了方便的沙箱，可以编写具有巨大性能提升的多线程代码。DOTS目前在预览中可用。</p><p>DOTS的多线程系统使您能够创建在各种硬件上运行的游戏，通过更多元素和更复杂的模拟构建更丰富的游戏世界，甚至优化玩家移动设备上的热控制和电池寿命。通过从面向对象的设计转向面向数据的设计，您可以更轻松地重用代码，并让其他人理解和处理代码。</p><h5 id="c-作业系统">C＃作业系统</h5><p><em>新的C＃作业系统利用了当今计算机中的多核。它旨在将此方法打开到C＃用户脚本，并允许用户编写安全，快速，有效的代码，同时防止多线程的一些陷阱，如竞争条件。</em></p><h6 id="利用多个核心">利用多个核心</h6><p>C＃作业系统公开了Native C ++作业系统，允许C＃脚本与Unity内部组件一起工作。</p><h6 id="安全的环境">安全的环境</h6><p>提供对多线程的一些陷阱的保护，例如竞争条件。</p><h5 id="实体组件系统-ecs">实体组件系统（ECS）</h5><h6 id="更好的游戏设计方法">更好的游戏设计方法</h6><p>ECS是一种编写代码的方式，专注于您正在解决的实际问题：组成游戏的数据和行为。</p><p>除了出于设计原因更好地接近游戏编程之外，使用ECS使您处于利用Unity的C＃作业系统和Burst Compiler的理想位置，让您充分利用当今的多核处理器。</p><p>使用ECS，我们正在从面向对象转向数据导向设计，这意味着重用代码更容易，并且更容易让其他人掌握并做出贡献。</p><h5 id="突发编译器">突发编译器</h5><h6 id="优化的代码">优化的代码</h6><p>新的基于LLVM的后端编译器技术可以获取C＃作业并生成高度优化的机器代码。</p><h6 id="每个平台都是最好的">每个平台都是最好的</h6><p>针对您正在编译的平台的特定功能进行了优化。</p><h6 id="减少手工编码">减少手工编码</h6><p>在多个平台上获得手动调整的汇编程序代码的许多优点，而无需付出艰苦的努力。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> DOTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECS适合你吗？</title>
      <link href="/blog/43b8c1c3.html"/>
      <url>/blog/43b8c1c3.html</url>
      
        <content type="html"><![CDATA[<p>实体组件系统处于预览状态。不建议用于生产。</p><p>目前有两个很好的理由使用它。</p><a id="more"></a><h5 id="你想试验">你想试验</h5><p>这是令人兴奋的新技术，并且大规模性能提升的承诺正在引诱。试试看。给我们您的反馈。我们很乐意在论坛上与您交谈。</p><h5 id="您正在尝试构建一个在没有实体组件系统的情况下无法完成的游戏">您正在尝试构建一个在没有实体组件系统的情况下无法完成的游戏</h5><p>我们很想知道您的游戏。请随时在论坛上发布您正在尝试实现的内容以及您认为实体组件系统为您提供的无法实现的内容。</p><h4 id="尝试实体组件系统">尝试实体组件系统</h4><p>您已经听说过ECS不仅可以提高性能，还可以帮助您编写更清晰，更清晰，更易于维护的代码。你想看看它在实践中是如何运作的。这是一个有趣的场景，因为您可以从头开始编写简单的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS Samples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HelloCube</title>
      <link href="/blog/8282d3d8.html"/>
      <url>/blog/8282d3d8.html</url>
      
        <content type="html"><![CDATA[<p>此示例演示了一个简单的ECS系统，它可以旋转一对立方体。</p><a id="more"></a><h4 id="它显示了什么？">它显示了什么？</h4><p>此示例演示了ECS中数据和功能的分离。<br>数据存储在组件中，如下RadiansPerSecond属性存储在RotationSpeed_ForEach组件中， 该结构体数据组件有[Serializable]修饰符，表示实例化属性。</p><pre><code class="language-csharp">using System;using Unity.Entities;// Serializable attribute is for editor support. [Serializable] public struct RotationSpeed_ForEach : IComponentData {     public float RadiansPerSecond; }</code></pre><p>而功能则写入系统，如下<strong>RotationSpeedSystem_ForEach</strong> 使用存储在 <strong>RotationSpeed_ForEach</strong> 组件中的<em>data</em>更新对象的旋转。</p><pre><code class="language-csharp">using Unity.Entities;using Unity.Mathematics;using Unity.Transforms;using UnityEngine;// This system updates all entities in the scene with both a RotationSpeed_ForEach and Rotation component. public class RotationSpeedSystem_ForEach : ComponentSystem {     protected override void OnUpdate()     {         // Entities.ForEach processes each set of ComponentData on the main thread. This is not the recommended         // method for best performance. However, we start with it here to demonstrate the clearer separation         // between ComponentSystem Update (logic) and ComponentData (data).         // There is no update logic on the individual ComponentData.         Entities.ForEach((ref RotationSpeed_ForEach rotationSpeed, ref Rotation rotation) =&gt;         {             var deltaTime = Time.deltaTime;             rotation.Value = math.mul(math.normalize(rotation.Value),                 quaternion.AxisAngle(math.up(), rotationSpeed.RadiansPerSecond * deltaTime));         });     } }</code></pre><h4 id="componentsystems和entities-foreach">ComponentSystems和Entities.ForEach</h4><p>RotationSpeedSystem_ForEach是一个ComponentSystem，它使用Entities.ForEach委托来遍历实体。<br>此示例仅创建单个实体，但如果向场景添加了更多实体，则RotationSpeedSystem_ForEach会更新所有实体 - 只要它们具有RotationSpeed_ForEach组件（并且在将GameObject的Transform转换为ECS组件时添加了旋转组件）。<br>请注意，使用Entities.ForEach的ComponentSystems在主线程上运行。<br>要利用多个内核，可以使用JobComponentSystem（如下一个HelloCube示例所示）。</p><h4 id="从gameobject转换为entity">从GameObject转换为Entity</h4><p><strong>ConvertToEntity</strong> MonoBehaviour在Awake时将GameObject及其子节点转换为实体和ECS组件。<br>目前，ConvertToEntity可以转换的内置Unity MonoBehaviours集包括Transform和MeshRenderer。<br>您可以使用<strong>实体调试器</strong>（菜单：<strong>窗口</strong>&gt; <strong>分析</strong>&gt; <strong>实体调试器</strong>）来检查转换创建的ECS实体和组件。<br>您可以在自己的MonoBehaviours上实现IConvertGameObjectEntity接口，以提供ConvertToEntity用于将存储在MonoBehavi中的数据转换为ECS组件的转换函数。<br>在此示例中， <strong>RotationSpeedAuthoring_ForEach</strong> MonoBehaviour使用IConvertGameObjectEntity在转换时将RotationSpeed_ForEach组件添加到实体。</p><pre><code class="language-csharp">using System; using Unity.Entities; using Unity.Mathematics; using UnityEngine; [RequiresEntityConversion] public class RotationSpeedAuthoring_ForEach : MonoBehaviour, IConvertGameObjectToEntity {     public float DegreesPerSecond;​    // The MonoBehaviour data is converted to ComponentData on the entity.​     // We are specifically transforming from a good editor representation of the data (Represented in degrees)​     // To a good runtime representation (Represented in radians)​     public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)​     {​         var data = new RotationSpeed_ForEach { RadiansPerSecond = math.radians(DegreesPerSecond) };​         dstManager.AddComponentData(entity, data);​     } }</code></pre><hr><h3 id="hellocube-1b-foreachwithentitychanges">HelloCube_1b_ForEachWithEntityChanges</h3><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要更新的正确实体集。然后它在ForEach lambda函数内部修改这些实体。</p><p>该示例定义了两个标记组件，名为MovingCube_ForEachWithEntityChanges和MoveUp_ForEachWithEntityChanges。</p><pre><code class="language-csharp">using System;using Unity.Entities;namespace Samples.HelloCube_1b{    // Serializable attribute is for editor support.    [Serializable]    public struct MoveUp_ForEachWithEntityChanges : IComponentData    {        // MoveUp is a &quot;tag&quot; component and contains no data. Tag components can be used to mark entities that a system should process.    }}</code></pre><pre><code class="language-csharp">using System;using Unity.Entities;namespace Samples.HelloCube_1b{    // Serializable attribute is for editor support.    [Serializable]    public struct MovingCube_ForEachWithEntityChanges : IComponentData    {        // MovingCube_ForEachWithEntityChanges is a &quot;tag&quot; component and contains no data.        // Tag components can be used to mark entities that a system should process.    } }</code></pre><p>系统中的一个查询选择同时具有MoveUp_ForEachWithEntityChanges组件和Translation组件的所有实体。与此查询关联的ForEach lambda函数向上移动每个选定的实体，直到达到某个高度时，该函数将删除MoveUp_ForEachWithEntityChanges组件，以便下次系统更新时，将不会选择该实体，因此它不会向上移动任何更远的位置。</p><p>第二个查询选择具有Translation组件但没有MoveUp_ForEachWithEntityChanges组件的所有实体。与第二个查询关联的ForEach函数将实体向下移动到其起始位置，并添加新的MoveUp_ForEachWithEntityChanges组件。由于实体再次具有MoveUp_ForEachWithEntityChanges组件，因此下次系统更新时，实体将被第一个ForEach函数向上移动并被第二个查询跳过。</p><p>MovingCube_ForEachWithEntityChanges是一个标记组件，用于确保系统仅适用于为此示例标记的组件。示例中的两个查询都需要MovingCube_ForEachWithEntityChanges组件。</p><h4 id="它显示了什么？-v2">它显示了什么？</h4><p>此示例演示了一个简单的ECS系统，该系统使用查询来选择要向上移动的一组实体。当它们达到一定高度时，系统会删除一个组件并使用另一个查询在较低的高度重新生成它们。它还演示了使用“标签”组件来提供选择具有待处理标记组件的特定entite组的方法。最后，此示例演示了如何在ForEach lambda函数内修改实体。</p><h4 id="组件系统和实体-foreach">组件系统和实体.ForEach</h4><p>MovementSystem_ForEachWithEntityChanges是一个ComponentSystem，它使用Entities.ForEach lambda函数迭代实体。此示例使用WithAll和WithNone约束来选择要处理的特定实体集。</p><pre><code class="language-csharp"> using Unity.Entities; using Unity.Mathematics; using Unity.Transforms; using UnityEngine;namespace Samples.HelloCube_1b {     // This system updates all entities in the scene with Translation components.     // It treats entities differently depending on whether or not they also have a MoveUp component.     public class MovementSystem_ForEachWithEntityChanges : ComponentSystem     {         protected override void OnUpdate()         {             // If a MoveUp component is present, then the system updates the Translation component to move the entity upwards.             // Once the entity reaches a predetermined height, the function removes the MoveUp component.             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges, MoveUp_ForEachWithEntityChanges&gt;().ForEach(                 (Entity id, ref Translation translation) =&gt;                 {                     var deltaTime = Time.deltaTime;                     translation = new Translation()                     {                         Value = new float3(translation.Value.x, translation.Value.y + deltaTime, translation.Value.z)                     };​                    if (translation.Value.y &gt; 10.0f)​                         EntityManager.RemoveComponent&lt;MoveUp_ForEachWithEntityChanges&gt;(id);​                 }​             );​            // If an entity does not have a MoveUp component (but does have a Translation component),​             // then the system moves the entity down to its starting point and adds a MoveUp component.​             Entities.WithAllReadOnly&lt;MovingCube_ForEachWithEntityChanges&gt;().WithNone&lt;MoveUp_ForEachWithEntityChanges&gt;().ForEach(​                 (Entity id, ref Translation translation) =&gt;​                 {​                     translation = new Translation()​                     {​                         Value = new float3(translation.Value.x, -10.0f, translation.Value.z)​                     };​                    EntityManager.AddComponentData(id, new MoveUp_ForEachWithEntityChanges());​                 }​             );​         }​     } }</code></pre><p>注意：使用Entities.ForEach的组件系统在主线程上运行。要利用多个内核，可以使用JobComponentSystem（如其他HelloCube示例所示）。这也允许更改ForEach lambda函数内的实体。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS Samples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS Samples </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是ECS？</title>
      <link href="/blog/1bcc4240.html"/>
      <url>/blog/1bcc4240.html</url>
      
        <content type="html"><![CDATA[<p>用一张图来说明什么是ECS。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190811211342.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS Samples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C＃作业系统中的安全系统</title>
      <link href="/blog/70ae4a2e.html"/>
      <url>/blog/70ae4a2e.html</url>
      
        <content type="html"><![CDATA[<h4 id="比赛条件">比赛条件</h4><p>编写<a href="https://docs.unity3d.com/Manual/JobSystemMultithreading.html" target="_blank" rel="noopener">多线程代码时</a>，总是存在<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞争条件</a>的风险。当一个操作的输出取决于其控制之外的另一个过程的定时时，发生竞争条件。</p><p>竞争条件并不总是一个错误，但它是不确定行为的来源。当竞争条件确实导致错误时，可能很难找到问题的根源，因为它取决于时间，因此您只能在极少数情况下重新创建问题。调试它可能会导致问题消失，因为断点和日志记录可以改变单个线程的时间。竞争条件是编写多线程代码时最重大的挑战。</p><a id="more"></a><h4 id="安全系统">安全系统</h4><p>为了更容易编写多线程代码，Unity C＃作业系统可以检测所有潜在的竞争条件，并保护您免受可能导致的错误的影响。</p><p>例如：如果C＃作业系统将主线程中代码中的数据<a href="https://docs.microsoft.com/en-us/cpp/cpp/references-cpp" target="_blank" rel="noopener">引用</a>发送到作业，则无法验证主线程是否在作业写入数据的同时读取数据。此方案会创建竞争条件。</p><p>C＃作业系统通过向每个作业发送它需要操作的数据的副本来解决这个问题，而不是对主线程中的数据的引用。此副本隔离数据，从而消除竞争条件。</p><p>C＃作业系统复制数据的方式意味着作业只能访问<a href="https://en.wikipedia.org/wiki/Blittable_types" target="_blank" rel="noopener">blittable数据类型</a>。在<a href="https://en.wikipedia.org/wiki/Managed_code" target="_blank" rel="noopener">托管</a>代码和本机代码之间传递时，这些类型不需要转换。</p><p>C＃Job System可以使用<a href="http://www.cplusplus.com/reference/cstring/memcpy/" target="_blank" rel="noopener">memcpy</a>复制blittable类型，并在Unity的托管和本机部分之间传输数据。它用于<code>memcpy</code>在调度作业时将数据放入本机内存，并在执行作业时为受管方提供对该副本的访问权限。有关更多信息，请参阅<a href="https://docs.unity3d.com/Manual/JobSystemSchedulingJobs.html" target="_blank" rel="noopener">计划作业</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解读GitHub EntityComponentSystemSamples</title>
      <link href="/blog/c763759a.html"/>
      <url>/blog/c763759a.html</url>
      
        <content type="html"><![CDATA[<p>出自Unity官方的ECS项目示例，该项目的第一次Commit是在2018年3月20号，距离现在一年半的时间，这期间ECS本身的生态在快速发展，稳定性也是逐步提升，期待在2020年的Unity版本中作为正式组件发布。好了，下面进入正题~ 对该项目的README做简单翻译和总结。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190811214015.png" alt=""></p><h3 id="欢迎">欢迎</h3><p>欢迎来到DOTS样品资源！</p><p>在这里，您可以找到今天开始使用这些新系统构建所需的资源。</p><p>我们还提供了一个论坛，您可以在其中找到更多信息并与这些新系统分享您的经验。</p><p><a href="https://unity3d.com/performance-by-default" target="_blank" rel="noopener">点击此处访问论坛</a></p><h4 id="什么是面向unity数据的技术堆栈？">什么是面向Unity数据的技术堆栈？</h4><p>我们一直在研究一种新的<strong>高性能多线程系统</strong>，这将使<strong>游戏能够充分利用当今可用的多核处理器而不会出现繁重的编程问题</strong>。面向数据的技术栈包括以下主要系统：</p><ul><li>该<strong>实体组件系统</strong>提供了一种默认编写高性能的代码。</li><li>在<strong>C＃作业系统</strong>提供了一种方法来运行多个CPU内核并行游戏代码</li><li>该<strong>突发编译</strong>一个新的数学感知，后台编译器调整的产生高度优化的机器代码。</li></ul><p>通过这些系统，Unity可以为您正在编译的平台的特定功能生成高度优化的代码。</p><h4 id="entity-component-system">Entity Component System</h4><p>实体组件系统提供了一种更好的游戏设计方法，使您可以专注于您正在解决的实际问题：组成游戏的数据和行为。它利用C＃Job System和Burst Compiler使您能够充分利用当今的多核处理器。从面向对象的设计转向面向数据的设计使您可以更轻松地重用代码，并使其他人更容易理解和处理代码。</p><p>实体组件系统作为实验包提供，目前支持Unity 2018.3及更高版本。重要的是要强调实体组件系统不是生产就绪的。<em>（译者注：ECS目前是预览版发布，其稳定性还不能应用于生产环境~）</em></p><h4 id="c-job-system">C# Job System</h4><p>新的C＃作业系统以安全简便的方式利用多个核心。简单，因为它旨在将此方法打开到用户脚本，并允许您编写安全，快速，有效的代码，同时提供保护，以防止多线程的一些陷阱，如竞争条件。</p><p>C＃作业系统是Unity 2018.1+中包含的内置模块。</p><p><a href="https://github.com/stella3d/job-system-cookbook" target="_blank" rel="noopener">可以在此处找到有关C＃作业系统的更多示例项目</a></p><h4 id="burst">Burst</h4><p>Burst是一种新的基于LLVM的数学感知后端编译器。它将C＃作业编译为高度优化的机器代码，利用您正在编译的平台的特定功能。</p><p>Burst是一个实验包，目前支持Unity 2018.3及更高版本。重要的是要强调Burst没有准备好生产。</p><p><a href="https://youtu.be/tGmnZdY5Y-E" target="_blank" rel="noopener">观看Joachim Ante在Unite Austin展示这些新系统</a></p><h4 id="样例">样例</h4><p>为了帮助您入门，我们提供了此示例存储库，用于学习如何大规模编写系统。</p><h5 id="hellocube">HelloCube</h5><p>这是一组展示Unity ECS架构绝对基础的项目：</p><ul><li><strong>ForEach</strong> - 创建一对旋转立方体。此示例演示了使用System和Components分离数据和行为。</li><li><strong>IJobForEach</strong> - 使用基于作业的系统构建在ForEach示例上。基于IJobForEach的系统是推荐的方法，可以利用可用的CPU内核。</li><li><strong>IJobChunk</strong> - 演示如何使用IJobChunk编写系统。IJobChunk是处理组件的推荐方法，用于比简单IJobForEach可以描述的更复杂的情况。</li><li><strong>SubScene</strong> - 演示如何在Unity编辑器中使用SubScenes创建和修改实体。</li><li><strong>SpawnFromMonoBehaviour</strong> - 演示如何基于Prefab GameObject从MonoBehaviour函数中生成多个实体。</li><li><strong>SpawnFromEntity</strong> - 演示如何使用系统中的生成作业在运行时生成多个实体。</li><li><strong>FluentQuery</strong> - 演示如何使用流畅查询来选择要更新的正确实体集。</li><li><strong>SpawnAndRemove</strong> - 演示产生和从世界中删除实体。</li></ul><h5 id="boids">Boids</h5><p>Boids示例提供了包含数千个实体的更复杂场景。Boids模拟水下场景，鲨鱼和学校包含数千条鱼。（它使用经典的Boids植绒算法来教育鱼类行为。）</p><h4 id="空白ecs项目安装指南">空白ECS项目安装指南</h4><ol><li>打开Unity编辑器（<code>2019.1.0f1</code>或更高版本）</li><li>创建一个新项目。</li><li>打开包管理器（菜单：<strong>Window</strong> &gt; <strong>Package Manager</strong>）。</li><li>单击窗口顶部的“ **高级”**按钮，然后启用“ **显示预览包”**选项。</li><li>将以下包添加到项目中：</li></ol><ul><li>Entities</li><li>Hybrid.Renderer</li></ul><p>将实体包添加到项目中还会添加以下包：</p><ul><li>Burst</li><li>Collections</li><li>Jobs</li><li>Mathematics</li></ul><p>**注意：**您可以使用<a href="https://unity3d.com/get-unity/download" target="_blank" rel="noopener">Unity Hub</a>在同一台计算机上安装多个版本的Unity。</p><h4 id="文档">文档</h4><p>寻找有关如何入门或具体问题的信息？访问我们的ECS和工作系统文档。</p><p><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/ECSSamples/Documentation/index.md" target="_blank" rel="noopener">转到ECS Samples文档</a></p><p><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/UnityPhysicsSamples/Documentation/samples.md" target="_blank" rel="noopener">转到Unity Physics Samples文档</a></p><p>（原文链接：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/README.md" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/README.md</a>）</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS Samples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>世界</title>
      <link href="/blog/c01e72eb.html"/>
      <url>/blog/c01e72eb.html</url>
      
        <content type="html"><![CDATA[<p>A <code>World</code>拥有<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html" target="_blank" rel="noopener">EntityManager</a>和一组<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_system.html" target="_blank" rel="noopener">ComponentSystems</a>。您可以根据需要创建任意数量的<code>World</code>对象。通常，您将创建模拟<code>World</code>和渲染或演示<code>World</code>。</p><a id="more"></a><p>默认情况下，我们<code>World</code>在进入“ **播放模式”**时创建单个，并使用<code>ComponentSystem</code>项目中的所有可用对象填充它，但您可以禁用默认<code>World</code>创建并通过全局定义将其替换为您自己的代码。</p><ul><li><strong>默认世界创建代码</strong>（参见文件：<em>Packages / com.unity.entities / Unity.Entities.Hybrid / Injection / DefaultWorldInitialization.cs</em>）</li><li><strong>自动引导入口点</strong>（参见文件： <em>Packages / com.unity.entities / Unity.Entities.Hybrid / Injection / AutomaticWorldBootstrap.cs</em>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS手册和脚本参考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS手册和脚本参考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实体</title>
      <link href="/blog/f345f685.html"/>
      <url>/blog/f345f685.html</url>
      
        <content type="html"><![CDATA[<p>实体是实体组件系统体系结构的三个主要元素之一。它们代表游戏或程序中的个人“事物”。一个实体既没有行为也没有数据; 相反，它识别哪些数据属于一起。<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">系统</a>提供行为，<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a>存储数据。</p><a id="more"></a><p>实体本质上是一个ID。您可以将其视为一个超级轻量级<a href="https://docs.unity3d.com/Manual/class-GameObject.html" target="_blank" rel="noopener">GameObject</a>，默认情况下甚至没有名称。实体ID是稳定的。它们是存储对另一个组件或实体的引用的唯一稳定方式。</p><p>一个<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html" target="_blank" rel="noopener">EntityManager</a>管理一个<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.World.html" target="_blank" rel="noopener">世界</a>中的所有实体。EntityManager维护实体列表并组织与实体关联的数据以获得最佳性能。</p><p>虽然实体没有类型，但实体组可以根据与它们相关联的数据组件的类型进行分类。在创建实体并向其添加组件时，EntityManager会跟踪现有实体上组件的唯一组合。这种独特的组合称为<em>原型</em>。在向实体添加组件时，EntityManager会创建<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityArchetype.html" target="_blank" rel="noopener">EntityArchetype</a>结构。您可以使用现有的EntityArchetypes来创建符合该原型的新实体。您还可以提前创建EntityArchetype并使用它来创建实体。</p><h4 id="创建实体">创建实体</h4><p>创建实体的最简单方法是使用Unity编辑器。您可以设置放置在场景中的游戏对象和要在运行时转换为实体的预制件。对于游戏或程序的更多动态部分，您可以创建在作业中创建多个实体的衍生系统。最后，您可以使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">EntityManager.CreateEntity</a>函数之一一次创建一个实体。</p><h5 id="使用entitymanager创建实体">使用EntityManager创建实体</h5><p>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">EntityManager.CreateEntity</a>函数之一来创建实体。实体在与EntityManager相同的World中创建。</p><p>您可以通过以下方式逐个创建实体：</p><ul><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.ComponentType.html" target="_blank" rel="noopener">ComponentType</a>对象数组创建包含组件的实体。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityArchetype.html" target="_blank" rel="noopener">EntityArchetype</a>创建包含组件的实体。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_" target="_blank" rel="noopener">Instantiate</a>复制现有实体（包括其当前数据）</li><li>创建一个没有组件的实体，然后向其中添加组件。（您可以立即添加组件，也可以添加其他组件。）</li></ul><p>您也可以一次创建多个实体：</p><ul><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity" target="_blank" rel="noopener">CreateEntity</a>使用具有相同原型的新实体填充NativeArray 。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_" target="_blank" rel="noopener">Instantiate</a>向NativeArray填充现有实体的副本，包括其当前数据。</li><li>使用<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateChunk_" target="_blank" rel="noopener">CreateChunk</a>显式创建使用给定原型填充指定数量的实体的块。</li></ul><h4 id="添加和删除组件">添加和删除组件</h4><p>创建实体后，可以添加或删除组件执行此操作时，受影响实体的原型会发生变化，EntityManager必须将更改的数据移动到新的内存块，并在原始块中压缩组件数组。</p><p>导致结构更改的实体的更改（即添加或删除更改SharedComponentData的值的组件以及销毁实体）无法在Job内部完成，因为这些操作可能会使Job正在处理的数据无效。而是添加命令以对<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityCommandBuffer.html" target="_blank" rel="noopener">EntityCommandBuffer</a>进行这些类型的更改，并在Job完成后执行此命令缓冲区。</p><p>EntityManager提供了从单个实体以及NativeArray中的所有实体中删除组件的功能。有关更多信息，请参阅<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a></p><h4 id="迭代实体">迭代实体</h4><p>迭代具有匹配组件集的所有实体，是ECS体系结构的核心。请参阅<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html" target="_blank" rel="noopener">访问实体数据</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS手册和脚本参考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS手册和脚本参考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实体组件系统</title>
      <link href="/blog/68fc35ba.html"/>
      <url>/blog/68fc35ba.html</url>
      
        <content type="html"><![CDATA[<p><strong>栏目概述</strong></p><a id="more"></a><ul><li>Core ECS<ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_entities.html" target="_blank" rel="noopener">Entities</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/world.html" target="_blank" rel="noopener">Worlds</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">Components</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_data.html" target="_blank" rel="noopener">General Purpose Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/shared_component_data.html" target="_blank" rel="noopener">Shared Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/system_state_components.html" target="_blank" rel="noopener">System State Components</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/dynamic_buffers.html" target="_blank" rel="noopener">Dynamic Buffer Components</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">System</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_system.html" target="_blank" rel="noopener">Component Systems</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/job_component_system.html" target="_blank" rel="noopener">Job Component Systems</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_command_buffer.html" target="_blank" rel="noopener">Entity Command Buffers</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/system_update_order.html" target="_blank" rel="noopener">System Update Order</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html" target="_blank" rel="noopener">Accessing Entity Data</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_iteration_job.html" target="_blank" rel="noopener">Using IJobForEach</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration_job.html" target="_blank" rel="noopener">Using IJobChunk</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/entity_iteration_foreach.html" target="_blank" rel="noopener">Using ComponentSystem and ForEach</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/manual_iteration.html" target="_blank" rel="noopener">Manual iteration</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_group.html" target="_blank" rel="noopener">Component Groups</a></li></ul></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_write_groups.html" target="_blank" rel="noopener">Component WriteGroups</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/version_numbers.html" target="_blank" rel="noopener">Versions and Generations</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_job_overview.html" target="_blank" rel="noopener">Jobs in ECS</a><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_job_extensions.html" target="_blank" rel="noopener">ECS Job System extensions</a></li></ul></li></ul></li><li>Creating Gameplay<ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/transform_system.html" target="_blank" rel="noopener">Transforms</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/gp_rendering.html" target="_blank" rel="noopener">Rendering</a></li></ul></li></ul><p>实体组件系统（ECS）是Unity数据导向技术堆栈的核心。顾名思义，ECS有三个主要部分：</p><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_entities.html" target="_blank" rel="noopener">实体</a> - 填充您的游戏或程序的实体或事物</li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_components.html" target="_blank" rel="noopener">组件</a> - 与您的实体关联的数据，但由数据本身而不是按实体组织。（这种组织差异是面向对象和面向数据的设计之间的关键差异之一。）</li><li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/ecs_systems.html" target="_blank" rel="noopener">系统</a> - 将组件数据从其当前状态转换到其下一状态的逻辑 - 例如，系统可以通过其速度乘以自前一帧以来的时间间隔来更新所有移动实体的位置。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS手册和脚本参考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS手册和脚本参考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组件</title>
      <link href="/blog/34778b46.html"/>
      <url>/blog/34778b46.html</url>
      
        <content type="html"><![CDATA[<p>组件是实体组件系统体系结构的三个主要元素之一。它们代表您的游戏或程序的数据。实体本质上是标识符，用于索引组件集合。系统提供行为。</p><a id="more"></a><p>具体地说，ECS中的组件是具有以下“标记接口”之一的结构：</p><p>IComponentData<br>ISharedComponentData<br>ISystemStateComponentData<br>ISharedSystemStateComponentData<br>EntityManager将实体上出现的组件的唯一组合组织到Archetypes中。它将具有相同原型的所有实体的组件一起存储在名为Chunks的内存块中。给定Chunk中的实体都具有相同的组件原型。</p><p>共享组件是一种特殊的数据组件，您可以使用它来根据共享组件中的特定值（除了它们的原型之外）细分实体。将共享组件添加到实体时，EntityManager将具有相同共享数据值的所有实体放入同一块中。共享组件允许您的系统一起处理类似的实体。例如，共享组件Rendering.RenderMesh是Hybrid.rendering包的一部分，它定义了几个字段，包括mesh，material，receiveShadows等。渲染时，最有效的是处理所有具有相同值的3D对象。由于这些属性是在共享组件中指定的，因此EntityManager将匹配的实体放在内存中，以便呈现系统可以有效地迭代它们。</p><p>注意：过度使用共享组件会导致较差的块利用率，因为它涉及基于原型和每个共享组件字段的每个唯一值组合扩展所需的内存块数。避免向共享组件添加不必要的字段，使用Entity Debugger查看当前的Chunk利用率。</p><p>如果从实体添加或删除组件，或更改SharedComponent的值，EntityManager会将实体移动到其他Chunk，必要时创建新Chunk。</p><p>系统状态组件的行为类似于普通组件或共享组件，但在销毁实体时，EntityManager不会删除任何系统状态组件，也不会在删除实体ID之前回收它们。这种行为差异允许系统在销毁实体时清理其内部状态或释放资源。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS手册和脚本参考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECS手册和脚本参考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C＃作业系统提示和故障排除</title>
      <link href="/blog/feab267f.html"/>
      <url>/blog/feab267f.html</url>
      
        <content type="html"><![CDATA[<p>使用Unity C＃作业系统时，请确保遵守以下内容：</p><h4 id="不要从作业访问静态数据">不要从作业访问静态数据</h4><p>从作业访问静态数据会绕过所有安全系统。如果您访问错误的数据，您可能会以意想不到的方式崩溃Unity。例如，访问<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" target="_blank" rel="noopener">MonoBehaviour</a>可能会导致域重新加载崩溃。</p><p><strong>注意</strong>：由于存在这种风险，Unity的未来版本将阻止使用<a href="https://www.youtube.com/watch?v=VxeC7WFfg3Q" target="_blank" rel="noopener">静态分析</a>从作业进行全局变量访问。如果您确实访问作业中的静态数据，则应该期望您的代码在Unity的未来版本中中断。</p><a id="more"></a><h4 id="刷新预定批次">刷新预定批次</h4><p>如果希望作业开始执行，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html" target="_blank" rel="noopener">JobHandle.ScheduleBatchedJobs</a>刷新计划批处理。请注意，调用此方法会对性能产生负面影响。不刷新批处理会延迟调度，直到主线程等待结果。在所有其他情况下，使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.Complete.html" target="_blank" rel="noopener">JobHandle.Complete</a>来启动执行过程。</p><p><strong>注意</strong>：在<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">实体组件系统</a>（ECS）中，将为您隐式刷新批处理，因此<code>JobHandle.ScheduleBatchedJobs</code>不需要调用。</p><h4 id="不要尝试更新nativecontainer内容">不要尝试更新NativeContainer内容</h4><p>由于缺少<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/ref-returns" target="_blank" rel="noopener">ref返回</a>，因此无法直接更改<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>的内容。例如，<code>nativeArray[0]++;</code>与<code>var temp = nativeArray[0]; temp++;</code>不更新值的<code>nativeArray</code>写入相同。</p><p>相反，您必须将索引中的数据复制到本地临时副本，修改该副本并将其保存回来，如下所示：</p><pre><code>MyStruct temp = myNativeArray[i];temp.memberVariable = 0;myNativeArray[i] = temp;</code></pre><h4 id="致电jobhandle-complete以重新获得所有权">致电JobHandle.Complete以重新获得所有权</h4><p>跟踪数据所有权需要在主线程再次使用它们之前完成依赖项。检查<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.IsCompleted.html" target="_blank" rel="noopener">JobHandle.IsCompleted</a>是不够的。您必须调用该方法<code>JobHandle.Complete</code>以重新获得<code>NativeContainer</code>主线程的类型的所有权。调用<code>Complete</code>还可以清除安全系统中的状态。不这样做会引入内存泄漏。如果您在每个帧中安排新作业，并且依赖于前一帧的作业，则此过程也适用。</p><h4 id="在主线程中使用schedule和complete">在主线程中使用Schedule和Complete</h4><p>你只能调用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>和<code>Complete</code>主线程。如果一个作业依赖于另一个作业，则使用<code>JobHandle</code>管理依赖关系而不是尝试在作业内安排作业。</p><h4 id="在合适的时间使用计划和完成">在合适的时间使用计划和完成</h4><p><code>Schedule</code>只要您拥有所需的数据就立即打电话给工作，并且<code>Complete</code>在您需要结果之前不要打电话给它。优秀的做法是安排一个您不需要等待的工作，而不是与正在运行的任何其他工作竞争。例如，如果在一帧结束和下一帧的开始之间没有作业正在运行，并且可以接受一帧延迟，则可以将作业调度到帧的末尾并使用其结果在以下框架中。或者，如果您的游戏与其他工作的转换期间相比，并且框架中的其他位置存在大量未充分利用的时间段，则更有效地安排您的工作。</p><h4 id="将nativecontainer类型标记为只读">将NativeContainer类型标记为只读</h4><p>请记住，作业<code>NativeContainer</code>默认情况下对类型具有读写访问权限。<code>[ReadOnly]</code>适当时使用该属性可提高性能。</p><h4 id="检查数据依赖性">检查数据依赖性</h4><p>在Unity Profiler 窗口，主线程上的标记“WaitForJobGroup”表示Unity正在等待工作线程上的作业完成。此标记可能意味着您已在某处应引入数据依赖关系。寻找<code>JobHandle.Complete</code>跟踪数据依赖关系的位置，这些数据依赖关系迫使主线程等待。</p><h4 id="调试作业">调试作业</h4><p>作业具有一个<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Run.html" target="_blank" rel="noopener">Run</a>函数，您可以使用它来代替<code>Schedule</code>在主线程上立即执行作业。您可以将其用于调试目的。</p><h4 id="不要在作业中分配托管内存">不要在作业中分配托管内存</h4><p>在作业中分配托管内存非常慢，并且该作业无法使用Unity <a href="https://www.youtube.com/watch?v=NF6kcNS6U80&amp;t=2s" target="_blank" rel="noopener">Burst编译器</a>来提高性能。Burst是一种新的基于<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener">LLVM</a>的后端编译器技术，可以让您更轻松。它需要C＃作业并利用您平台的特定功能生成高度优化的机器代码。</p><h4 id="更多的信息">更多的信息</h4><ul><li>观看<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">Unity GDC 2018：</a>剪辑的<a href="https://www.youtube.com/playlist?list=PLX2vGYjWbI0RuXtGMYKqChoZC2b-H4tck" target="_blank" rel="noopener">C＃作业系统</a>播放列表。</li><li>有关C＃作业系统如何与ECS相关的更多高级信息，请参阅<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">GitHub上</a>的<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/blob/master/Documentation~/index.md" target="_blank" rel="noopener">ECS包文档</a>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JobHandle和依赖项</title>
      <link href="/blog/9bdee974.html"/>
      <url>/blog/9bdee974.html</url>
      
        <content type="html"><![CDATA[<h4 id="要当您调用作业的schedule方法时-它将返回jobhandle-您可以在代码中使用一个jobhandle作为其他作业的依赖项-如果作业取决于另一个作业的结果-您可以将第一个作业jobhandle作为参数传递给第二个作业的schedule方法-如下所示：">要当您调用作业的<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html" target="_blank" rel="noopener">Schedule</a>方法时，它将返回<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html" target="_blank" rel="noopener">JobHandle</a>。您可以在代码中使用一个<code>JobHandle</code>作为其他作业的依赖项。如果作业取决于另一个作业的结果，您可以将第一个作业<code>JobHandle</code>作为参数传递给第二个作业的<code>Schedule</code>方法，如下所示：</h4><a id="more"></a><pre><code class="language-csharp">JobHandle firstJobHandle = firstJob.Schedule();secondJob.Schedule(firstJobHandle);</code></pre><h4 id="结合依赖关系">结合依赖关系</h4><p>如果作业具有许多依赖项，则可以使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.CombineDependencies.html" target="_blank" rel="noopener">JobHandle.CombineDependencies</a>方法合并它们。<code>CombineDependencies</code>允许您将它们传递给<code>Schedule</code>方法。</p><pre><code class="language-csharp">NativeArray&lt;JobHandle&gt; handles = new NativeArray&lt;JobHandle&gt;(numJobs, Allocator.TempJob);// Populate `handles` with `JobHandles` from multiple scheduled jobs...JobHandle jh = JobHandle.CombineDependencies(handles);</code></pre><h4 id="在主线程中等待工作">在主线程中等待工作</h4><p>使用<code>JobHandle</code>强迫你的代码在主线程等待您的工作执行完毕。要做到这一点，调用<code>JobHandle的Complete方法</code>。此时，您知道主线程可以安全地访问作业正在使用的<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>。</p><p><strong>注意</strong>：在计划作业时，作业不会开始执行。如果您正在等待主线程中的作业，并且您需要访问作业正在使用的NativeContainer数据，则可以调用该方法<code>JobHandle.Complete</code>。此方法从内存高速缓存中刷新作业并启动执行过程。在<code>JobHandle```调用</code>Complete<code>以安全返回作业的</code>NativeContainer类型的主线程所有权<code>。您需要从一个</code>JobHandle上<code>调用</code>Complete<code>以再次从主线程安全地访问这些</code>NativeContainer<code>类型。也可以通过调用来自于一个作业依赖的</code>JobHandle上的<code>Complete`返回主线程的所有权。例如，你可以调用`jobA上的</code>Complete方法<code>，或者也可以调用依赖于</code>jobA的jobB上的``Complete方法<code>。两者在调用Complete方法后都能安全访问主线程得到</code>NativeContainer类型的结果。`</p><p>否则，如果您不需要访问数据，则需要明确刷新批处理。为此，请调用静态方法<a href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html" target="_blank" rel="noopener">JobHandle.ScheduleBatchedJobs</a>。请注意，调用此方法会对性能产生负面影响。</p><h4 id="多个作业和依赖项的示例">多个作业和依赖项的示例</h4><p><strong>工作代码</strong>：</p><pre><code class="language-csharp">// Job adding two floating point values togetherpublic struct MyJob : IJob{    public float a;    public float b;    public NativeArray&lt;float&gt; result;    public void Execute()    {        result[0] = a + b;    }}// Job adding one to a valuepublic struct AddOneJob : IJob{    public NativeArray&lt;float&gt; result;    public void Execute()    {        result[0] = result[0] + 1;    }}</code></pre><p><strong>主线程代码</strong>：</p><pre><code class="language-csharp">// Create a native array of a single float to store the result in. This example waits for the job to completeNativeArray&lt;float&gt; result = new NativeArray&lt;float&gt;(1, Allocator.TempJob);// Setup the data for job #1MyJob jobData = new MyJob();jobData.a = 10;jobData.b = 10;jobData.result = result;// Schedule job #1JobHandle firstHandle = jobData.Schedule();// Setup the data for job #2AddOneJob incJobData = new AddOneJob();incJobData.result = result;// Schedule job #2JobHandle secondHandle = incJobData.Schedule(firstHandle);// Wait for job #2 to completesecondHandle.Complete();// All copies of the NativeArray point to the same memory, you can access the result in &quot;your&quot; copy of the NativeArrayfloat aPlusB = result[0];// Free the memory allocated by the result arrayresult.Dispose();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NativeContainer</title>
      <link href="/blog/ac3c63a9.html"/>
      <url>/blog/ac3c63a9.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.unity3d.com/Manual/JobSystemSafetySystem.html" target="_blank" rel="noopener">安全系统</a>复制数据<a href="https://docs.unity3d.com/Manual/JobSystemSafetySystem.html" target="_blank" rel="noopener">的</a>过程的缺点是它还隔离了每个副本中作业的结果。要克服此限制，您需要将结果存储在一种名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html" target="_blank" rel="noopener">NativeContainer</a>的共享内存中。</p><a id="more"></a><h2 id="什么是nativecontainer？">什么是NativeContainer？</h2><p>A <code>NativeContainer</code>是托管值类型，为本机内存提供相对安全的C＃包装器。它包含指向非托管分配的指针。与Unity C＃作业系统一起使用时，a <code>NativeContainer</code>允许作业访问与主线程共享的数据，而不是使用副本。</p><h2 id="有哪些类型的nativecontainer？">有哪些类型的NativeContainer？</h2><p>Unity附带一个<code>NativeContainer</code>名为<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html" target="_blank" rel="noopener">NativeArray的程序</a>。您还可以<code>NativeArray</code>使用<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeSlice_1.html" target="_blank" rel="noopener">NativeSlice</a>操作a 以获取<code>NativeArray</code>从特定位置到特定长度的子集。</p><p>注意：<a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">实体组件系统</a>（ECS）包扩展了<code>Unity.Collections</code>命名空间以包括其他类型<code>NativeContainer</code>：</p><ul><li><code>NativeList</code>- 可调整大小<code>NativeArray</code>。</li><li><code>NativeHashMap</code> - 键和值对。</li><li><code>NativeMultiHashMap</code> - 每个键有多个值。</li><li><code>NativeQueue</code>- <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener">先进先出</a>（<a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" target="_blank" rel="noopener">FIFO</a>）队列。</li></ul><h2 id="nativecontainer和安全系统">NativeContainer和安全系统</h2><p>安全系统内置于所有<code>NativeContainer</code>类型。它跟踪什么是读写任何内容<code>NativeContainer</code>。</p><p>注意：所有<code>NativeContainer</code>类型的安全检查（例如越界检查，重新分配检查和竞争条件检查）仅在Unity 编辑器和播放模式下可用。</p><p>该安全系统的一部分是<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.DisposeSentinel.html" target="_blank" rel="noopener">DisposeSentinel</a>和<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle.html" target="_blank" rel="noopener">AtomicSafetyHandle</a>。该<code>DisposeSentinel</code>检测内存泄漏，给你一个错误，如果你没有正确地释放你的记忆。泄漏发生后很久就会发生内存泄漏错误。</p><p>使用<code>AtomicSafetyHandle</code>转移<code>NativeContainer</code>代码的所有权。例如，如果两个预定作业写入相同<code>NativeArray</code>，则安全系统会抛出异常，并显示明确的错误消息，说明解决问题的原因和方法。安排违规工作时，安全系统会抛出此异常。</p><p>在这种情况下，您可以安排具有依赖关系的作业。第一个作业可以写入<code>NativeContainer</code>，一旦完成执行，下一个作业就可以安全地读取和写入相同的作业<code>NativeContainer</code>。从主线程访问数据时，读写限制也适用。安全系统允许多个作业并行读取相同的数据。</p><p>默认情况下，当作业有权访问a时<code>NativeContainer</code>，它具有读写访问权限。此配置可能会降低性能。C＃作业系统不允许您计划与写入其中的<code>NativeContainer</code>另一个作业同时具有写访问权限的作业。</p><p>如果作业不需要写入a <code>NativeContainer</code>，请<code>NativeContainer</code>使用<code>[ReadOnly]</code>属性标记，如下所示：</p><pre><code>[ReadOnly]public NativeArray&lt;int&gt; input;</code></pre><p>在上面的示例中，您可以与其他对第一个也具有只读访问权限的作业同时执行作业<code>NativeArray</code>。</p><p>注意：无法防止从作业中访问静态数据。访问静态数据会绕过所有安全系统，并可能导致Unity崩溃。有关更多信息，请参阅<a href="https://docs.unity3d.com/Manual/JobSystemTroubleshooting.html" target="_blank" rel="noopener">C＃作业系统提示和故障排除</a>。</p><h2 id="nativecontainer分配器">NativeContainer分配器</h2><p>创建时<code>NativeContainer</code>，必须指定所需的内存分配类型。分配类型取决于作业运行的时间长度。通过这种方式，您可以定制分配以在每种情况下获得最佳性能。</p><p>内存分配和释放有三种<a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html" target="_blank" rel="noopener">Allocator</a>类型<code>NativeContainer</code>。在实例化你的时候需要指定合适的一个<code>NativeContainer</code>。</p><ul><li>Allocator.Temp分配最快。它适用于寿命为一帧或更少的分配。您不应将<code>NativeContainer</code>分配<code>Temp</code>用于作业。您还需要<code>Dispose</code>在从方法调用返回之前调用该方法（例如<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html" target="_blank" rel="noopener">MonoBehaviour.Update</a>，或从本机代码到托管代码的任何其他回调）。</li><li>Allocator.TempJob是一个比较慢的分配，<code>Temp</code>但速度比<code>Persistent</code>。它适用于四帧生命周期内的分配，并且是线程安全的。如果<code>Dispose</code>在四帧内没有，则控制台会打印一条警告，该警告是从本机代码生成的。大多数小型工作都使用此<code>NativeContainer</code>分配类型。</li><li>Allocator.Persistent是最慢的分配，但只要你需要它，并且如果有必要，可以持续整个应用程序的生命周期。它是直接调用<a href="http://www.cplusplus.com/reference/cstdlib/malloc/" target="_blank" rel="noopener">malloc</a>的包装器。较长的作业可以使用此<code>NativeContainer</code>分配类型。你不应该使用<code>Persistent</code>性能至关重要的地方。</li></ul><p>例如：</p><pre><code>NativeArray&lt;float&gt; result = new NativeArray&lt;float&gt;(1, Allocator.TempJob);</code></pre><p>注意：上例中的数字1表示的大小<code>NativeArray</code>。在这种情况下，它只有一个数组元素（因为它只存储一个数据<code>result</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ParallelForTransform作业</title>
      <link href="/blog/894c6889.html"/>
      <url>/blog/894c6889.html</url>
      
        <content type="html"><![CDATA[<p>ParallelForTransform作业是另一种<a href="https://docs.unity3d.com/Manual/JobSystemParallelForJobs.html" target="_blank" rel="noopener">ParallelFor作业</a> ; 专为在<a href="https://docs.unity3d.com/Manual/Transforms.html" target="_blank" rel="noopener">变形上</a>操作而设计。</p><p><strong>注意</strong>：ParallelForTransform作业是Unity中用于实现<a href="https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransform.html" target="_blank" rel="noopener">IJobParallelForTransform</a>接口的任何作业的集合术语。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> C＃ Job System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C＃ Job System </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity双击脚本不会自动跳转到vs中的解决方案</title>
      <link href="/blog/f243dbe9.html"/>
      <url>/blog/f243dbe9.html</url>
      
        <content type="html"><![CDATA[<h4 id="问题复现">问题复现</h4><p>在Unity中点击脚本不能直接打开vs编辑器，检查完Unity设置发现还是打不开</p><h4 id="问题原因">问题原因</h4><p>因为Unity中导入的VS Package版本不支持新版的Virtual Studio所导致的</p><h4 id="解决方案">解决方案</h4><p>升级Unity中的<code>Visual Studio Package</code>版本即可</p><a id="more"></a><p><img src="https://longshilin.com/images/20190522214037.png" alt="选择Package Manager"></p><p><img src="https://longshilin.com/images/20190523101650.png" alt="升级Visual Studio Editor Package"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 问题解决纪录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Visual Studio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GameFramework框架学习流程</title>
      <link href="/blog/b42dd2c7.html"/>
      <url>/blog/b42dd2c7.html</url>
      
        <content type="html"><![CDATA[<div style="padding-bottom:56.25%; position:relative; display:block; width: 100%"> <iframe width="100%" height="100%" src="https://www.processon.com/embed/5cb99469e4b0841b84374217" frameborder="0" allowfullscreen style="position:absolute; top:0; left: 0"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> GameFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GameFramework </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>virtual和override实现继承关系</title>
      <link href="/blog/3e7c0e8a.html"/>
      <url>/blog/3e7c0e8a.html</url>
      
        <content type="html"><![CDATA[<p>官方文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/inheritance" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/inheritance</a></p><p>详细信息直接看官方文档，我只记录自己的一点感受。</p><ol><li>子类继承父类时，需要用virtual和override配合。</li><li>子类重载方法中调用父类的该重载源方法，例如：<code>base.method();</code>，如果子类中没有调用，则不会执行父类该源方法的逻辑。</li></ol><a id="more"></a><p>------ 示例 ------</p><p><kbd>BaseClass.cs</kbd></p><pre><code class="language-csharp">using System;namespace LearnCSharp{    class BaseClass    {        public virtual void method()        {            Console.WriteLine(&quot;我是Base类！&quot;);        }    }}</code></pre><p><kbd>ChildClass.cs</kbd></p><pre><code class="language-csharp">using System;namespace LearnCSharp{    class ChildClass : BaseClass    {        public override void method()        {            // 调用子类的逻辑            Console.WriteLine(&quot;我是Child类!&quot;);            // 调用父类的逻辑            base.method();        }        static void Main()        {            ChildClass childClass = new ChildClass();            childClass.method();            Console.ReadKey();        }    }}</code></pre><p><kbd>控制台输出</kbd><br><img src="https://longshilin.com/images/20190524142854.png" alt="控制台输出"></p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Atom自定义代码片段以提高编码效率</title>
      <link href="/blog/f427fb19.html"/>
      <url>/blog/f427fb19.html</url>
      
        <content type="html"><![CDATA[<p>通过在Atom中自定义代码片段，绑定指定的文件类型，就可以在编辑该类型文件时实现快速提示功能。<br><img src="https://longshilin.com/images/20190523104526.gif" alt="Atom定制快捷提示片段示例"></p><a id="more"></a><p><img src="https://longshilin.com/images/20190523104940.png" alt="打开Atom的Snippets设置"></p><pre><code># 下面是我的自定义'.text.md':  'more':    'prefix': 'more'    'body': '&lt;!-- more --&gt;'  'title':    'prefix': 'title'    'body': '--- \ntitle: $1 \nlayout: post \ntags: \n  - $2 \ncategories: \n  - $3 \ncomments: true \ntoc: false \ndate: $4  \n---\n'</code></pre><p>具体Snippets文件中的语法参考下面的官方文档：</p><p><a href="https://flight-manual.atom.io/using-atom/sections/basic-customization/#_cson" title="Atom基本定制" target="_blank" rel="noopener">1.Atom基本定制官方文档</a></p><p><a href="https://flight-manual.atom.io/using-atom/sections/snippets/" target="_blank" rel="noopener">2.Atom片段设置</a></p><p><img src="https://longshilin.com/images/20190523105720.png" alt="查看文件类型的快速方式"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Atom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atom Snippets </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>创建ECS项目</title>
      <link href="/blog/ac01c54a.html"/>
      <url>/blog/ac01c54a.html</url>
      
        <content type="html"><![CDATA[<h3 id="选择unity版本">选择Unity版本</h3><p>我这里安装的是Unity2019.2.0b1版本，通过Unity Hub直接安装的，顺便推荐下Unity Hub这个软件。它是Unity官方用来在同一电脑上管理多个Unity版本的协同工具。</p><a id="more"></a><p><img src="https://longshilin.com/images/20190522212113.png" alt="选择Unity版本"></p><p><img src="https://longshilin.com/images/20190522212923.png" alt="创建项目"></p><p><img src="https://longshilin.com/images/20190522213442.png" alt="这是刚打开的样子"></p><h3 id="安装package">安装Package</h3><p><img src="https://longshilin.com/images/20190522214037.png" alt="打开Package Manager窗口"></p><p>由于ECS还没有作为正式组件公之于众，因此只能在预览包中看到它们的身影，ps：ECS作为正式组件预计在Unity2020.1版本中。</p><p><img src="https://longshilin.com/images/20190522214903.png" alt="预览版Package"></p><p>安装两个Package：</p><ul><li>Entities</li><li>Hybrid.Renderer</li></ul><p><img src="https://longshilin.com/images/20190522215142.png" alt="Entities Package"></p><p><img src="https://longshilin.com/images/20190522215208.png" alt="Hybrid.Renderer Package"></p><p>下面我们来对比下安装之前和安装之后，到底多了哪些包依赖，下面图是通过对比工具得到的，其实刚好就是增加安装的那两个包。</p><p><img src="https://longshilin.com/images/20190522214752.png" alt="安装package前后对比结果"></p><h3 id="了解package的依赖关系">了解Package的依赖关系</h3><p>另外需要补充的是，在安装这两个package的时候，下面这些包也已经被加入到项目中：</p><ul><li>Burst</li><li>Collections</li><li>Jobs</li><li>Mathematics</li></ul><p>可以通过勾选Advance -&gt; show dependencies查看两个package包依赖关系。</p><p><img src="https://longshilin.com/images/20190522215605.png" alt="Entities Package Dependence"></p><p><img src="https://longshilin.com/images/20190522215759.png" alt="Hybrid.Renderer Package Dependence"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> ECS Samples </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity3D中使用委托</title>
      <link href="/blog/30526cbb.html"/>
      <url>/blog/30526cbb.html</url>
      
        <content type="html"><![CDATA[<p>首先来了解委托是什么，在《Unity3D脚本编程》一书中，指明委托要确定一个回调方法签名，包括参数以及返回类型等。在下面的例子中，MyDelegate委托定制的回调方法的参数类型是int型，同时返回类型为void。</p><pre><code class="language-csharp">//声明一个委托类型，它的实例引用一个方法internal delegate void MyDelegate(int num);</code></pre><a id="more"></a><p>在为委托实例引用方法时，C#允许引用类型的协变性和逆变性。协变性是指方法的返回类型可以是从委托的返回类型派生的一个派生类，逆变性则是指方法获取的参数的类型可以是委托的参数的类型的基类。</p><pre><code class="language-csharp">// 声明一个委托类型delegate Object TellMeYourName(SoldierClass soldier);// 实例化一个方法，该方法的返回值是委托的返回类型派生的一个派生类string TellMeYourNameMethod(BaseUnitClass base);// 注意，这里该方法不能被绑定到委托实例上，编译器会报错。// 这是因为虽然int型和string型一样，都派生自Object类，但是int型是值类型，因此是不支持协变性的。int TellMeYourNameMethod(BaseUnitClass base);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> 脚本编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1. Scripts as Behaviour Components</title>
      <link href="/blog/d6acd003.html"/>
      <url>/blog/d6acd003.html</url>
      
        <content type="html"><![CDATA[<p>这是本栏目的开篇文章，从一开始就了解游戏开发的编程。</p><a id="more"></a><h3 id="流程">流程</h3><p>创建一个Scene并添加一个Cube，在Cube上挂载<code>ExampleBehaviourScript.cs</code>这个文件，然后启动游戏。通过键盘输入 <kbd>R</kbd> 或 <kbd>G</kbd> 或 <kbd>B</kbd> 来改变Cube的颜色。</p><pre><code class="language-csharp">using UnityEngine;using System.Collections;public class ExampleBehaviourScript : MonoBehaviour{    void Update()    {        if (Input.GetKeyDown(KeyCode.R))        {            GetComponent&lt;Renderer&gt; ().material.color = Color.red;        }        if (Input.GetKeyDown(KeyCode.G))        {            GetComponent&lt;Renderer&gt;().material.color = Color.green;        }        if (Input.GetKeyDown(KeyCode.B))        {            GetComponent&lt;Renderer&gt;().material.color = Color.blue;        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Unity基础入门学习笔记 </category>
          
          <category> Scripts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1. Scripts as Behaviour Components</title>
      <link href="/blog/d6acd003.html"/>
      <url>/blog/d6acd003.html</url>
      
        <content type="html"><![CDATA[<p>这是本栏目的开篇文章，从一开始就了解游戏开发的编程。</p><a id="more"></a><h3 id="流程">流程</h3><p>创建一个Scene并添加一个Cube，在Cube上挂载<code>ExampleBehaviourScript.cs</code>这个文件，然后启动游戏。通过键盘输入 <kbd>R</kbd> 或 <kbd>G</kbd> 或 <kbd>B</kbd> 来改变Cube的颜色。</p><pre><code class="language-csharp">using UnityEngine;using System.Collections;public class ExampleBehaviourScript : MonoBehaviour{    void Update()    {        if (Input.GetKeyDown(KeyCode.R))        {            GetComponent&lt;Renderer&gt; ().material.color = Color.red;        }        if (Input.GetKeyDown(KeyCode.G))        {            GetComponent&lt;Renderer&gt;().material.color = Color.green;        }        if (Input.GetKeyDown(KeyCode.B))        {            GetComponent&lt;Renderer&gt;().material.color = Color.blue;        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Unity基础入门学习笔记 </category>
          
          <category> Scripts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows和mac上安装Tower破解版</title>
      <link href="/blog/b5410c9.html"/>
      <url>/blog/b5410c9.html</url>
      
        <content type="html"><![CDATA[<p>Tower确实蛮好用的，才试用了几天就爱上了它。在<a href="https://www.git-tower.com" target="_blank" rel="noopener">Tower官网</a>这里有关它的介绍，以及有专门的<a href="https://www.git-tower.com/learn/" target="_blank" rel="noopener">电子书和视频</a>来让你快速上手Tower和git。</p><p><img src="https://ws1.sinaimg.cn/large/005EsThygy1fzs24oey0aj31z413ztdg.jpg" alt=""></p><a id="more"></a><p>#<kbd>Tower for windows</kbd><br>版本号截图<br><img src="https://longshilin.com/images/20190507100004.jpg" alt=""></p><p>Tower内部界面<br><img src="https://longshilin.com/images/20190507100014.jpg" alt=""></p><blockquote><p>下载地址：<a href="https://pan.baidu.com/s/1uFCJ3m18RUA1vhPfs27Zvw" target="_blank" rel="noopener">https://pan.baidu.com/s/1uFCJ3m18RUA1vhPfs27Zvw</a> 密码：r1ys</p></blockquote><p>#<kbd>Tower for Mac</kbd><br>版本号截图<br><img src="https://longshilin.com/images/20190507100042.jpg" alt=""></p><p>Tower内部界面<br><img src="https://longshilin.com/images/20190507100050.jpg" alt=""></p><blockquote><p>下载链接：<a href="https://pan.baidu.com/s/1mIQQXm-bEZcbnz06G-FJ2w" target="_blank" rel="noopener">https://pan.baidu.com/s/1mIQQXm-bEZcbnz06G-FJ2w</a> 密码：6fbn</p></blockquote><blockquote><p>有任何问题，请在留言区留言给我~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tower </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>更新你的highlightjs版本和支持语言</title>
      <link href="/blog/61ee7b96.html"/>
      <url>/blog/61ee7b96.html</url>
      
        <content type="html"><![CDATA[<p>HighlightJS<br>发布状态：稳定<br>履行解析器功能<br>描述“highlight.js”客户端语法高亮显示的包装器<br>作者（S）Aran Dunkley（Nad）</p><a id="more"></a><p><kbd>Getting highlight.js</kbd><br>在<a href="https://highlightjs.org/download/" target="_blank" rel="noopener">https://highlightjs.org/download/</a>下载自定义的语法js文件，并替换hexo博客中原始的版本。注意博客中要用自己的js，而不是cdn中的。<br><img src="https://ws1.sinaimg.cn/large/005EsThygy1fzrwcicv8ej30mf1280vk.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> highlightjs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写博文的常用板书格式</title>
      <link href="/blog/7eae6d59.html"/>
      <url>/blog/7eae6d59.html</url>
      
        <content type="html"><![CDATA[<div class="bs-callout bs-callout-primary"><p>c如何写的漂亮… 这是一个好问题</p></div><p>下面会以这样的格式展示每一个模块<br>Markdown:</p><pre><code>ABC</code></pre><p>…outputs:<br>ABC</p><a id="more"></a><h3 id="表格">表格</h3><p>Markdown:</p><pre><code>| Table Header 1 | Table Header 2 | Table Header 3 || - | - | - || Division 1 | Division 2 | Division 3 || Division 1 | Division 2 | Division 3 || Division 1 | Division 2 | Division 3 |</code></pre><p>…outputs:</p><table><thead><tr><th>Table Header 1</th><th>Table Header 2</th><th>Table Header 3</th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr></tbody></table><h3 id="bootstrap重点标注">Bootstrap重点标注</h3><p>这个Bootstrap标注可以给你的文章增添更多的醒目标记信息。可选项：default | primary | success | info | warning | danger<br>Markdown:</p><pre><code>{% callout info %}#### {% fa info-circle %} InfoThis is some info content{% endcallout %}{% callout warning %}#### {% fa exclamation-triangle %} WarningThis is some warning content{% endcallout %}{% callout danger %}#### {% fa exclamation-triangle %} DangerThis is some danger content{% endcallout %}</code></pre><p>…outputs:</p><div class="bs-callout bs-callout-info"><h4 id="i-class-fa-fa-info-circle-i-info"><i class="fa fa-info-circle"></i> Info</h4><p>This is some info content</p></div><div class="bs-callout bs-callout-warning"><h4 id="i-class-fa-fa-exclamation-triangle-i-warning"><i class="fa fa-exclamation-triangle"></i> Warning</h4><p>This is some warning content</p></div><div class="bs-callout bs-callout-danger"><h4 id="i-class-fa-fa-exclamation-triangle-i-danger"><i class="fa fa-exclamation-triangle"></i> Danger</h4><p>This is some danger content</p></div><h3 id="fa图标">fa图标</h3><p>在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome 资源</a>  可以选择你需要的任意图标。<br>Markdown：</p><pre><code>{% fa github %}</code></pre><p>…outputs:</p><i class="fa fa-github"></i><h3 id="hexo-github-card">hexo-github-card</h3><p>在文章中引入某个github项目卡片，<a href="https://github.com/Gisonrg/hexo-github-card" target="_blank" rel="noopener">参考地址</a><br>Markdown:</p><pre><code>{% githubCard user:your_user [repo:your_repo] [width:400] [theme:Default] [client_id:your_client_id] [client_secret:your_client_secret] [align:text-align_position] %}如：</code></pre><p>…outputs:</p><div style="text-align:center">  <div class="github-card" data-user="longshilin" data-repo="" data-width="400" data-theme="default" data-target="" data-client-id="" data-client-secret=""></div></div><script src="/github-card-lib/githubcard.js"></script><div style="text-align:center">  <div class="github-card" data-user="longshilin" data-repo="" data-width="400" data-theme="default" data-target="" data-client-id="" data-client-secret=""></div></div><script src="/github-card-lib/githubcard.js"></script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> write </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写博文必备的工具合集</title>
      <link href="/blog/4b315c79.html"/>
      <url>/blog/4b315c79.html</url>
      
        <content type="html"><![CDATA[<p>这里的工具合集主要是我写博客时需要涉及到的工具，这些工具的使用能够提高我的创作效率，并且给我带来实质上的便利。下面基本上是一句话概括每一个工具，并且配上官方使用的网页介绍，以及对于功能介绍的<i class="fa fa-file-pdf"></i>离线PDF版本以及<i class="fa fa-box"></i>安装包等资源的<i class="fa fa-archive"></i>归档文件目录分享。</p><a id="more"></a><h2 id="电脑优化性能集合">电脑优化性能集合</h2><h3 id="1-与多个平台进行整合的图床工具">[1] 与多个平台进行整合的图床工具</h3><ul><li>名称：PicGo</li><li>官方地址：<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">https://molunerfinn.com/PicGo/</a></li><li>介绍：很不错的图床工具，适配多个平台，如：GitHub、微博、七牛、腾讯云等等。</li><li>推荐指数：⭐️⭐️⭐️⭐️⭐️</li></ul><h3 id="2-资源归档工具">[2] 资源归档工具</h3><ul><li>介绍：百度云网盘</li><li>官方地址：<a href="https://pan.baidu.com" target="_blank" rel="noopener">https://pan.baidu.com</a></li><li>介绍：网盘资源存放</li><li>推荐指数：⭐️⭐️⭐️⭐️⭐️</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Double365</title>
      <link href="/blog/3e68368d.html"/>
      <url>/blog/3e68368d.html</url>
      
        <content type="html"><![CDATA[<p>这一次是我们第一次一起跨年，下面是我宝精心制作的视频剪辑哦，看的出来是花费了很多的精力的啦，嘻嘻 💘 希望宝贝以后的Vlog越来越多我也会更加配合的，哈哈哈😈 最后祝我宝猪年大吉呀🐷</p><a id="more"></a><p><video src="http://repo.longshilin.com/video/double365.mov" poster="https://ws1.sinaimg.cn/large/005EsThygy1fyx9bjpedvj30940fymx6.jpg" preload="" controls style="max-width: 50%; display: block; margin-left: auto; margin-right: auto;"><br>your browser does not support the video tag<br></video></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>提升使用体验的工具合集</title>
      <link href="/blog/725d13af.html"/>
      <url>/blog/725d13af.html</url>
      
        <content type="html"><![CDATA[<p>这里的工具合集，基本上是一句话概括每一个工具，并且配上官方使用的网页介绍，以及对于功能介绍的<i class="fas fa-file-pdf"></i>离线PDF版本以及安装包等资源 <i class="fas fa-archive"></i>。</p><a id="more"></a><h2 id="电脑优化性能集合">电脑优化性能集合</h2><h3 id="1-轻量化去广告的内存清理工具">[1] 轻量化去广告的内存清理工具</h3><ul><li>名称：Mem Reduct</li><li>官方地址：<a href="https://www.henrypp.org/product/memreduct" target="_blank" rel="noopener">https://www.henrypp.org/product/memreduct</a></li><li>介绍：轻量化清理机器内存的利器，具体的看我的另外一篇文章介绍 <a href="https://longshilin.com/blog/70c155f1.html">轻量化去广告的内存清理工具</a> <i class="fas fa-archive"></i> <a href="https://pan.baidu.com/s/1FyGqexfCUFrEp-ZKxqcPuw" target="_blank" rel="noopener">详细地址</a></li><li>推荐指数：⭐️⭐️⭐️⭐️</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 电脑管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在mybatis中构建带有sql in查询的mapper语法</title>
      <link href="/blog/9880d52a.html"/>
      <url>/blog/9880d52a.html</url>
      
        <content type="html"><![CDATA[<p>在mapper中编写带有sql in语法的sql时，需要注意不能直接以字符串&quot;in(…)&quot;的形式将语句贴在sql中，需要以list集合的形式遍历出来，具体的表达方式如下：</p><pre><code>&lt;select id=&quot;selectAllServiceByServiceType&quot; resultMap=&quot;BaseResultMap2&quot; parameterType=&quot;java.util.List&quot;&gt; SELECT DISTINCT SERVICE_TYPE, IMAGE_TAG FROM `SERVICE_CONFIG` WHERE STATUS = 1 AND SERVICE_TYPE IN &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;  #{item} &lt;/foreach&gt; ORDER BY SERVICE_TYPE;&lt;/select&gt;</code></pre><a id="more"></a><p>上面得到的sql也就是：</p><pre><code>SELECT DISTINCT SERVICE_TYPE, IMAGE_TAGFROM `SERVICE_CONFIG`WHERE STATUS = 1AND SERVICE_TYPE IN (1, 2, 3, 4, 5);</code></pre><p>这里需要注意的是，foreach中的collection字段的list值是固定表达方式，在对应的mapper方法中，传入参数名也应为list，具体表示如下：</p><pre><code>List&lt;ServiceConfig&gt; selectAllServiceByServiceType(List&lt;Integer&gt; list);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Keep Running</title>
      <link href="/blog/f1cb4bde.html"/>
      <url>/blog/f1cb4bde.html</url>
      
        <content type="html"><![CDATA[<p>今晚的线上Keep跑~ 慢慢的跑而又满满的幸福</p><a id="more"></a><p><img src="https://ws1.sinaimg.cn/large/005EsThygy1fx8h12ek7fj30yi1pctpb.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005EsThygy1fx8h1a6fdmj30u01hcq5e.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>AWS Certified SysOps Administrator – Associate 考试的建议准备路径</title>
      <link href="/blog/2e3c6403.html"/>
      <url>/blog/2e3c6403.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/8xNyw7N.png" alt=""> 本篇博文主要介绍AWS Certified SysOps Administrator – Associate 考试的建议准备路径的详细执行计划清单。参考<a href="https://amazonaws-china.com/cn/certification/certification-prep/" target="_blank" rel="noopener">准备认证</a></p><p><img src="https://i.imgur.com/Ria4nMk.png" alt="AWS学习路径"></p><a id="more"></a><div class="bs-callout bs-callout-primary"><p>下面介绍的每个环节都是需要重视的~</p></div><h2 id="第-1-步：参加-aws-培训课程">第 1 步：参加 AWS 培训课程</h2><p>培训可以帮助您提高技术技能，并了解 AWS 最佳使用实践。</p><p><a href="https://amazonaws-china.com/training/course-descriptions/sysops" target="_blank" rel="noopener">Systems Operations on AWS</a><br>课堂 | 3 天</p><blockquote><p>这里没有参加培训课程，改为自己自学了解，下面是在这个阶段会接触到的一些内容。</p></blockquote><h3 id="awsome-day-官方视频-英文版">AWSome Day 官方视频（英文版）</h3><p>下面推荐YouTube上AWS官方发布的三个视频，是 <kbd>AWSome Day 2018</kbd> 的官方视频。</p><div class="video-container"><iframe src="//www.youtube.com/embed/K3qbY8j_Qfs" frameborder="0" allowfullscreen></iframe></div><br><div class="video-container"><iframe src="//www.youtube.com/embed/xToY64aiCgc" frameborder="0" allowfullscreen></iframe></div><br><div class="video-container"><iframe src="//www.youtube.com/embed/2-F4bariCcs" frameborder="0" allowfullscreen></iframe></div><h3 id="awsome-day-2018-全国大学生巡回视频-中文版">AWSome Day 2018 全国大学生巡回视频（中文版）</h3><p><a href="http://www.xuetangx.com/courses/course-v1:AWS+awsomeday+2017_t1/courseware" target="_blank" rel="noopener">AWSome Day 2018 全国大学生巡回视频</a></p><p>接下来的进阶课程，可以在学堂在线的<a href="http://www.xuetangx.com/livecast/microdegree/introduce/3/" target="_blank" rel="noopener">云计算解决方案架构师</a>课程中获得。</p><h3 id="附加">附加</h3><p>接下来你可以点击<a href="https://www.aws.training/" target="_blank" rel="noopener">这个链接</a>了解AWS教学视频和自主进度实验室。</p><h2 id="第-2-步：查看考试指南和样题">第 2 步：查看考试指南和样题</h2><p>了解考试涉及的概念并整体了解需要学习哪些内容。查看 <a href="http://awstrainingandcertification.s3.amazonaws.com/production/AWS_certified_sysops_associate_blueprint.pdf" target="_blank" rel="noopener">AWS Certified SysOps Administrator – Associate 考试指南</a>。<br>学习提示：不要跳过样题。</p><p>考试<a href="https://d0.awsstatic-china.com/training-and-certification/docs/AWS_certified_sysops_associate_examsample.pdf" target="_blank" rel="noopener">样题</a>可以帮助您检查自己对知识的掌握情况，并指明需要进一步学习的概念和领域。</p><h2 id="第-3-步：阅读官方考试学习指南">第 3 步：阅读官方考试学习指南</h2><p>AWS Certified SysOps Administrator – Associate 考试：官方学习指南由 AWS 专家编写而成。该指南可以让您做好准备以便在考试中证明自己的网络技能，其中涵盖各项考试目标，并结合 AWS Certified SysOps Administrator 可能遇到的各种情况指导您完成动手实验。从部署、管理和操作到迁移、数据流、成本控制等等，本指南将帮助您掌握与 AWS 相关的流程和最佳实践。</p><p>这里可以参考我的另外一篇博文<a href="https://longshilin.com/blog/112641e9.html">有关AWS考证的思考</a></p><h2 id="第-4-步：研究-aws-白皮书和常见问题">第 4 步：研究 AWS 白皮书和常见问题</h2><p>通过 AWS 团队、独立分析师和 AWS 合作伙伴编制的白皮书加深您的技术理解。</p><p>学习提示：重点学习以下白皮书。</p><p>云架构设计：AWS 最佳实践 || AWS 安全最佳实践 || Amazon Web Services：安全流程概述 || AWS 架构完善的框架 || AWS 上的开发和测试 || 使用 AWS 的备份与恢复方法 || Amazon Virtual Private Cloud 连接选项 || AWS 的定价机制</p><p>查看所有白皮书</p><p>浏览常见问题列表，熟悉不同用户经常提出的问题。</p><p>学习提示：重点查看以下常见问题。</p><p>Amazon EC2 || Amazon S3 || Amazon VPC || Amazon Route 53 || Amazon RDS || Amazon SQS</p><p>查看所有常见问题</p><h2 id="第-5-步：参加备考培训">第 5 步：参加备考培训</h2><p>利用我们的备考：AWS Certified SysOps Administrator – Associate（AWS 认证系统操作管理员 – 助理级）课程，向经过认证的技术讲师学习备考策略。</p><p><img src="https://i.imgur.com/mPAj5wu.png" alt="AWS培训课程指南"></p><blockquote><p>这一步也没有参加备考培训，转为是自己的自学过程，会在下面贴出自己的学习路径</p></blockquote><h3 id="aws尖峰学堂系列">AWS尖峰学堂系列</h3><p>通过<kbd>AWS尖峰学堂系列</kbd>课程的学习，可以掌握各个主要服务的入门级介绍，下面是整个视频列表。</p><ul><li>01-IAM忠实的AWS守门员.mp4</li><li>02-AWS安全运营体系概览.mp4</li><li></li></ul><h3 id="快速上手实验室">快速上手实验室</h3><p><a href="https://amazon.qwiklabs.com/catalog?locale=zh" target="_blank" rel="noopener">动手实验</a></p><h2 id="第-6-步：参加模拟考试">第 6 步：参加模拟考试</h2><p>在规定时间内答题，测试自己对知识的掌握情况。前往 aws.training 注册。</p><blockquote><p>这一步也没有参加线上模拟考试，下面会记录自己的刷题路径</p></blockquote><h2 id="第-7-步：报考并获得认证">第 7 步：报考并获得认证</h2><p>前往 aws.training 在您附近的测试中心报考。下面是AWS中各个认证类型</p><p><img src="https://i.imgur.com/enpg9cz.png" alt="AWS认证类别"></p>]]></content>
      
      
      <categories>
          
          <category> 认证 </category>
          
          <category> AWS认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aws-soa </tag>
            
            <tag> aws </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何更优雅的写文章</title>
      <link href="/blog/52b07b5c.html"/>
      <url>/blog/52b07b5c.html</url>
      
        <content type="html"><![CDATA[<div class="bs-callout bs-callout-primary"><p>如何优雅的写作，这里会包含两个模块：一个是如何方便些，一个是如何写的漂亮。</p></div><a id="more"></a><h2 id="如何写的方便">如何写的方便</h2><p>下面首先从如何方便写开始，这里我推荐Atom这款由 <i class="fa fa-github"></i>开发的编辑器，其中包含丰富的插件系统，可以支撑你的MarkDown写作，并且这些个性化设置及插件可以跨平台同步，实现你在多台机器上可以快速搭建你最熟悉的写作环境。</p><p>对于我使用的插件，可以参考我的这篇文章 <a href="https://longshilin.com/wiki/editor/atom-practice.html">Atom 实战</a>，里面包含如何同步fork我的插件列表到你的Atom个人配置中~ 🎆</p><p>下面我简单罗列下我安装的插件，在<a href="https://atom.io/packages" target="_blank" rel="noopener">Atom Packages</a>可以查询到下面这些的插件，并自行安装各个插件。</p><ul><li>atom-terminal</li><li>autocomplete-emjis</li><li>language-markdown</li><li>markdown-preview-enhanced</li><li>markdown-table-editor</li><li>markdown-writer</li><li>sync-setting</li></ul><h2 id="如何写的漂亮">如何写的漂亮</h2><p>这里分享有关这个hexo 主题原作者分享的一些渲染方法 <a href="https://www.cgmartin.com/tags/hexo/" target="_blank" rel="noopener">Hexo Theme</a>，详细信息可以查看在线PDF <a href="https://github.com/longshilin/files-repo/blob/master/Getting%20Started%20with%20the%20Hexo%20Blogging%20Framework%20_%20Christopher%20Martin.pdf" target="_blank" rel="noopener">Getting Started with the Hexo Blogging Framework</a> 和 <a href="https://github.com/longshilin/files-repo/blob/master/Hexo%20Theme_%20Bootstrap%20Blog%20_%20Christopher%20Martin.pdf" target="_blank" rel="noopener">Hexo Theme_ Bootstrap Blog</a></p><p>下面会总结一下最佳实践方式：</p><h3 id="表格">表格</h3><p>Markdown:</p><pre><code>| Table Header 1 | Table Header 2 | Table Header 3 || - | - | - || Division 1 | Division 2 | Division 3 || Division 1 | Division 2 | Division 3 || Division 1 | Division 2 | Division 3 |</code></pre><p>…outputs:</p><table><thead><tr><th>Table Header 1</th><th>Table Header 2</th><th>Table Header 3</th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr></tbody></table><h3 id="bootstrap标注">Bootstrap标注</h3><p>这个Bootstrap标注可以给你的文章增添更多的醒目标记信息。</p><p>In the Markdown:</p><pre><code>{% callout info %}#### {% fa info-circle %} InfoThis is some info content{% endcallout %}{% callout warning %}#### {% fa exclamation-triangle %} WarningThis is some warning content{% endcallout %}{% callout danger %}#### {% fa exclamation-triangle %} DangerThis is some danger content{% endcallout %}</code></pre><p>…outputs:</p><div class="bs-callout bs-callout-info"><h4 id="i-class-fa-fa-info-circle-i-info"><i class="fa fa-info-circle"></i> Info</h4><p>This is some info content</p></div><div class="bs-callout bs-callout-warning"><h4 id="i-class-fa-fa-exclamation-triangle-i-warning"><i class="fa fa-exclamation-triangle"></i> Warning</h4><p>This is some warning content</p></div><div class="bs-callout bs-callout-danger"><h4 id="i-class-fa-fa-exclamation-triangle-i-danger"><i class="fa fa-exclamation-triangle"></i> Danger</h4><p>This is some danger content</p></div><h3 id="fa图标">fa图标</h3><p>在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome 资源</a>  可以选择你需要的任意图标。</p><blockquote><p>举个栗子： 对于<i class="fa fa-github"></i>在Font Awesome中是<code>&lt;i class=&quot;fa github&quot;&gt;&lt;/i&gt;</code>，于是在博客中引入这个图标时，写入<code><i class="fa fa-github"></i></code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> write </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优秀文章合集</title>
      <link href="/blog/f04e.html"/>
      <url>/blog/f04e.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://liuyandong.com/2017/10/25/122/" target="_blank" rel="noopener">1. 十年学会编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优秀文章 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于GitLab和GitHub个人博客自动化部署及发布（CI/CD）</title>
      <link href="/blog/f56958c8.html"/>
      <url>/blog/f56958c8.html</url>
      
        <content type="html"><![CDATA[<p>今天看了业界比较知名的个人博主左耳朵耗子-陈浩在极客时间专栏的博文深有感触，其中对于自己写博如何将文章写得“独一份”，这是你需要思考和追求的，与其你不断优化站点的SEO，不如让你的文章更加与众不同，观点是别人少有研究，或者你的观点更鲜明，你就能被别人搜索到。</p><p>基于这个理念，我觉得对这两个月折腾的个人建站最有价值的部分，有必要好好写写，分享给想通过自动化的方式部署及发布你的博文的朋友。</p><a id="more"></a><p>在这篇文章中，我主要分享如何借助外部工具实现你的博文自动部署及更新发布站点，其中涉及的主要技术有：</p><ul><li>docker</li><li>git</li></ul><p>借助的第三方平台时<a href="https://www.gitlab.com" target="_blank" rel="noopener">Gitlab</a>，可能很多朋友听说或是用过<a href="https://www.github.com" target="_blank" rel="noopener">Github</a>，但对前者熟悉度不高。其实我也是在最近搞自动化部署站点的时候，才了解这个工具的。它的优势在于，不仅同样提供Pages功能，而且能够支持将资源push到仓库后，自动触发Gitlab的<a href="https://about.gitlab.com/features/gitlab-ci-cd/" target="_blank" rel="noopener">CI/CD模块</a>，这样能够按照你设定的方式进行构建和部署发布。</p><p><img src="https://longshilin.com/images/20190507102157.png" alt="ci-cd-test-deploy-illustration"></p><p>就如同下面这张图中，你的资源更新和自动化部署是可以迭代更新的，运用到我们持续集成我们的文章，持续发布我们的站点，同样是可以的。</p><p><img src="https://longshilin.com/images/20190507102146.png" alt="ci-cd-devops-loop"></p><p>下面我详细说一下我们站点的自动化部署及发布需要进行的准备工作：</p><ol><li>首先你需要创建一个gitlab的项目仓库，这里gitlab比github更nice的地方是支持免费的私有仓库服务，见<a href="https://docs.gitlab.com/ee/user/project/repository/" target="_blank" rel="noopener">创建资源仓库</a></li><li>然后编写gitlab能够自动部署的脚本命令 <a href="https://docs.gitlab.com/ee/ci/yaml/" target="_blank" rel="noopener">.gitlab-ci.yml</a></li><li>在编写上一步yml文件时，可以模仿这个<a href="https://gitlab.com/pages/hexo#gitlab-ci" target="_blank" rel="noopener">gitlab hexo page</a><br>这里我将我项目中用的yml文件贴出来，供大家参考：</li></ol><pre><code class="language-yml"># longsl/hexo2simikiimage: $你的docker-image镜像，如：longsl/hexo2simikipages:  cache:    paths:    - /builds/longshilin/longshilindotcom/blog/node_modules  script:    - HOME=`pwd`    - REMOTE_PROJECT=longshilindotcom    - git config --global user.email &quot;583297550@qq.com&quot;    - git config --global user.name &quot;longsl&quot;    # 构建hexo    - cd $HOME/blog    - npm install    - hexo g    - cp -r blog $HOME/public    # 构建simiki    - cd $HOME/wiki    - simiki g    - cp -r wiki $HOME/public    # 同步静态网页到国内git.dev.tencent.com仓库    - cd ~; git clone git@git.dev.tencent.com:yilong0722/longshilindotcom.git;    - rm -rf $REMOTE_PROJECT/*; cp -rf $HOME/public/* $REMOTE_PROJECT; cd $REMOTE_PROJECT    - git add *; git commit -a -m &quot;Site updated：`date`&quot;; git push -f  artifacts:    paths:    - public  only:  - master</code></pre><p>在你的新增资源push到gitlab的代码仓库中，会自动触发CI/CD程序，即运行这个默认脚本。最终上面的artifacts中表示的是你要发布的静态资源。默认情况下它是可以通过<a href="https://docs.gitlab.com/ee/user/project/pages/" target="_blank" rel="noopener">gitlab page</a>来访问，如果你觉得gitlab pages对国内的访问速度不够快的话，<a href="http://xn--publicpagescoding-jy50af2jj0cwxs9ey3mk8csxm4vaj94d6h7aseyp5t1tevvow9ynk3c7f6cra0130h6qzec9ualpbe51o.net" target="_blank" rel="noopener">你还可以将public下的静态资源再推送到国内同样支持pages功能的coding.net</a>，ps:最近coding.net被腾讯开发者平台收购了，成为了腾讯开发者平台的资源仓库。</p><ol start="5"><li>在gitlab pages或者coding pages上绑定你的域名，可以参考<a href="https://longshilin.com/blog/57c188a8.html">gitlab绑定域名</a>，并设置国内和国外的分区访问和DNS解析。实现国内国外对资源的加载速度的优化。下面是我的域名在腾讯云控制台中的设置详情。<br><img src="https://i.imgur.com/MdwYs8q.png" alt=""></li></ol><p><strong>这样能够使得国内用户和海外用户能相对快读的加载你的静态资源网页。</strong></p><blockquote><p>2019-01-09 更新<br>目前直接是通过将静态网站部署在github上，并开启page功能向全网同步。 资源CI/CD依然是gitlab，<a href="http://xn--coding-hs2ji57af9rzh6cped.net" target="_blank" rel="noopener">弃用国内的coding.net</a> 因为在我使用期间经常出现域名解析出问题，访问不了的情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习资源（一期）</title>
      <link href="/blog/649f.html"/>
      <url>/blog/649f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Avalon js在线教程<br><a href="http://edu.51cto.com/center/course/lesson/index?id=46928" target="_blank" rel="noopener">http://edu.51cto.com/center/course/lesson/index?id=46928</a></p></blockquote><a id="more"></a><blockquote><p>「极客时间」极客专栏-左耳听风 [PDF] (268M) <a href="https://time.geekbang.org/column/intro/48?from=trial" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/48?from=trial</a><br>地址：<a href="http://www.52studyit.com/thread-1242-1-1.html" target="_blank" rel="noopener">http://www.52studyit.com/thread-1242-1-1.html</a><br>链接: <a href="https://pan.baidu.com/s/1xTnzDZxMOMU7kLWD1XCyjA" target="_blank" rel="noopener">https://pan.baidu.com/s/1xTnzDZxMOMU7kLWD1XCyjA</a><br>提取码: xzcw</p></blockquote><blockquote><p>Docker+Kubernetes(k8s)微服务容器化实战 [MP4]<br>地址：<a href="http://www.52studyit.com/forum.php?mod=viewthread&amp;tid=193&amp;highlight=Kubernetes" target="_blank" rel="noopener">http://www.52studyit.com/forum.php?mod=viewthread&amp;tid=193&amp;highlight=Kubernetes</a><br>链接: <a href="https://pan.baidu.com/s/1B1hqpzEBWH-du-aEMZFBoQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1B1hqpzEBWH-du-aEMZFBoQ</a><br>密码: vmgv</p></blockquote><blockquote><p>Docker技术高级应用实战（含KubernetesK8S）[MP4] (8.33G)<br>地址：<a href="http://www.52studyit.com/thread-909-1-1.html" target="_blank" rel="noopener">http://www.52studyit.com/thread-909-1-1.html</a></p></blockquote><blockquote><p>Kubernetes企业级Docker容器集群管理平台实战 [MP4] (3.52G)<br>地址：<a href="http://www.52studyit.com/thread-907-1-1.html" target="_blank" rel="noopener">http://www.52studyit.com/thread-907-1-1.html</a></p></blockquote><blockquote><p>AWS 云计算-AWS 操作指南系列课程 [MP4] (1.58G)<br><a href="http://www.52studyit.com/thread-1426-1-1.html" target="_blank" rel="noopener">http://www.52studyit.com/thread-1426-1-1.html</a><br>链接: <a href="https://pan.baidu.com/s/1m3Q2MEJ0d8xRHmcRzDwrrw" target="_blank" rel="noopener">https://pan.baidu.com/s/1m3Q2MEJ0d8xRHmcRzDwrrw</a><br>提取码: hj34</p></blockquote><blockquote><p>魔乐科技 SpringBoot框架开发详解 [MP4] (6.13G)<br><a href="http://www.52studyit.com/thread-1290-1-1.html" target="_blank" rel="noopener">http://www.52studyit.com/thread-1290-1-1.html</a><br>链接: <a href="https://pan.baidu.com/s/1smc0b14lo6Nx1Bgx120DzQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1smc0b14lo6Nx1Bgx120DzQ</a><br>提取码: iwfa</p></blockquote><blockquote><p>Spring源码解读与设计详析 [MP4] (3.87G)<br><a href="http://www.52studyit.com/thread-715-1-1.html" target="_blank" rel="noopener">http://www.52studyit.com/thread-715-1-1.html</a><br>链接: <a href="https://pan.baidu.com/s/1ZUf_LM7z2xcnJ2DEbZnFtw" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZUf_LM7z2xcnJ2DEbZnFtw</a><br>密码: xdn9</p></blockquote><blockquote><p>极客时间零基础学Python [MP4] (2.06G)<br><a href="http://www.52studyit.com/thread-1513-1-1.html" target="_blank" rel="noopener">http://www.52studyit.com/thread-1513-1-1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极客时间 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>风移影动 | 珊珊可爱</title>
      <link href="/blog/157464b7.html"/>
      <url>/blog/157464b7.html</url>
      
        <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Welcome to my blog, enter password to read." />    <label for="pass">Welcome to my blog, enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+unZLJPLG0ukiAzguZJA7MZfzn5jOt2wDeH6cQY0C5lYBmdZ5SOPyXUQIlZHCrP4M1C2BY+TOtfNDFQd42+pCNk6HSnabsGkytdT8yQ3wXMOSrnSgCgT1nH1M/lzdZsPSmKo6RwbQj2k4SZtggyc3A/UZsW1Noa39Zw3uH1qh3lecQi3gjuFs5CRqjwwv82p2ECiZ6ExaQ8SADIgS41Aj74yrxBxgj5BUasQtLqxM6+Rooo1Ie8vjtwRuNDnX/X6FoemKSrjDdJptRCKzScCKJ2UGVgQAJDAMic/sBKN5SfefRIdKV3U2rCJGlxuNKk6zNQAnJcTcuKDqeUbLah8e+rKVWFiGN2izzz7HHc/bPqjKog9p6l3ojJB7e5Jm1J9bMcMT2za2XHU8jp5hzXOyLYKjcbemwAAXb2Z8gq5Wp91NEUrpuzMN6zAhesqNQiDkATJMArUViXGl19HIZOT8suPszw23Ly3V52kyC408ynD+4QUxpFss6f3MG9S/A3bb3aaGM+eRvSJ584oKkrJLlxJYAv+HOTa2/xvYQD9i5sTAtxL98HTlJcxTP12CN9OPjVwRlOfcfsKTjT9iP+9+GUNqC9TVr9LXixPBuE+KxpqOHAobfgfYxBlkVsS0Sxl4tG50kwphcNEiLxwQXPmpFezFjqRGILLwbDE+rBxIFDcGQD9VO+ah3GldmcWgRTCzMEl+aNU60jo8514owwExFLYfjg7+tplZNGgO7DbFCb7k9+0Rjm2QeLyMkxRFBM/dnRGZeeCyI2w==</div><script src="/blog/lib/crypto-js.js"></script><script src="/blog/lib/blog-encrypt.js"></script><link href="/blog/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>轻量化去广告的内存清理工具</title>
      <link href="/blog/70c155f1.html"/>
      <url>/blog/70c155f1.html</url>
      
        <content type="html"><![CDATA[<p>其实我的需求仅仅是需要是在电脑上安装一个清理内存的软件，但是在安装了那么多大型软件之后，我发现或多或少会有一些广告的成分在其中，因为他们需要从广告中获利，才能继续维系他们的产品开发也业务拓展，所以对于用这些大型管理软件和我的需求是有冲突的，因为我不喜欢臃肿的功能以及广告弹窗的出现，因此我选择了这个应用，它足够轻量 免费，而且无广告。</p><a id="more"></a><p>下面，我介绍一款自认为足够满足轻量化与去广告需求的开源应用，并且仅仅是具备清理机器内存这一个功能，非常有针对性，很Nice！</p><p>它是个人项目，这里是网址：<a href="https://www.henrypp.org/product/memreduct" target="_blank" rel="noopener">https://www.henrypp.org/product/memreduct</a></p><p><img src="https://i.imgur.com/GoD9FAR.jpg" alt="memreduct"></p><p>轻松上手，下面是自定义设置，可以达到双击右下角图标自动清理机器内存的目的。<br><img src="https://i.imgur.com/pnTJ47T.png" alt=""></p><p>下面是个人设置，实现上面的双击图标自动清理内存，并没有任何弹窗，极其方便~ 🌛<br><img src="https://i.imgur.com/rOtHQQV.png" alt=""><img src="https://i.imgur.com/pX6btFW.png" alt=""><img src="https://i.imgur.com/lJFvaGL.png" alt=""><img src="https://i.imgur.com/nbSPcPl.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 电脑管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> memreduct </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>站点开源框架</title>
      <link href="/blog/fb05e777.html"/>
      <url>/blog/fb05e777.html</url>
      
        <content type="html"><![CDATA[<h1>DokuWiki</h1><p>DokuWiki是一个简单易用，功能多样的开源维基软件，不需要数据库。用户喜欢它清晰易读的语法。易于维护，备份和集成使其成为管理员的最爱。内置的访问控制和身份验证连接器使DokuWiki在企业环境中特别有用，其充满活力的社区贡献的大量插件允许广泛的用例超越传统的wiki。   <a href="https://www.dokuwiki.org" target="_blank" rel="noopener">https://www.dokuwiki.org</a><br><img src="https://longshilin.com/images/20190507102234.png" alt="DokuWiki Home"></p><h1>Homeland</h1><p>开源、免费、不限制商业使用的社区/论坛系统   <a href="https://gethomeland.com" target="_blank" rel="noopener">https://gethomeland.com</a><br><img src="https://longshilin.com/images/20190507102245.png" alt="Homeland Home"></p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DokuWiki </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>website优化之路</title>
      <link href="/blog/baf88334.html"/>
      <url>/blog/baf88334.html</url>
      
        <content type="html"><![CDATA[<p>在这里我会从上到下介绍我所做的优化和调整，会把每个模块的修改都覆盖到，而中间踩过的坑都给大家添上。同时也会记录自己的创新点和实践心得等等，欢迎大家评论~</p><a id="more"></a><p><img src="https://i.imgur.com/5x7OAkx.png" alt="Blog首页"></p><p>其中这个样式的原版是下面这样的：<br><img src="https://i.imgur.com/a6hZnuv.png" alt="原版博客样式"><br><a href="https://www.cgmartin.com" target="_blank" rel="noopener">详见原作者博客</a> | 另外该样式的<a href="https://github.com/cgmartin/hexo-theme-bootstrap-blog" target="_blank" rel="noopener">Github地址</a></p><blockquote><p>乍一看，感觉两者没有实质上的改变，大部分都相同。确实是这样的，下面我会一一列举我新增的内容和填过的坑。😄</p></blockquote><h2 id="导航栏">导航栏</h2><p>首先是导航栏部分，可以看到左侧导航栏出现了多个标签页，这里我需要在<code>theme/_config.yml</code>文件中新增menu菜单栏，实质上脚本文件会自动解析你的config配置项，然后到<code>masthead.ejs</code>文件中将所有的menu以遍历的形式进行展现出来，具体看下面相关的代码：</p><pre><code>[第16行开始]&lt;!-- Collect the nav links, forms, and other content for toggling --&gt;&lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;main-menu-navbar&quot;&gt;  &lt;ul class=&quot;nav navbar-nav&quot;&gt;    &lt;% for (var i in theme.menu){ %&gt;      &lt;li&gt;&lt;a class=&quot;&lt;%= is_current(theme.menu[i]) ? 'active' : '' %&gt;&quot;             href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;/li&gt;    &lt;% } %&gt;  &lt;/ul&gt;......</code></pre><h2 id="导航栏右侧的个人站点图表">导航栏右侧的个人站点图表</h2><p>在 <kbd>masthead.ejs</kbd> 文件中加入下面的内容，这是整个顶部导航栏右侧的图表列表。</p><pre><code>&lt;ul class=&quot;nav navbar-nav navbar-right&quot; id=&quot;sub-menu-navbar&quot;&gt;  &lt;% if (theme.rss){ %&gt;    &lt;li&gt;&lt;a href=&quot;&lt;%- theme.rss %&gt;&quot; title=&quot;RSS Feed&quot;&gt;&lt;i class=&quot;fa fa-rss&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;  &lt;% } %&gt;  &lt;% if (theme.github){ %&gt;    &lt;li&gt;&lt;a href=&quot;https://github.com/&lt;%- theme.github %&gt;&quot; title=&quot;Github&quot;&gt;&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;  &lt;% } %&gt;  &lt;% if (theme.gitlab){ %&gt;    &lt;li&gt;&lt;a href=&quot;https://gitlab.com/&lt;%- theme.gitlab %&gt;&quot; title=&quot;Gitlab&quot;&gt;&lt;i class=&quot;fa fa-gitlab&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;  &lt;% } %&gt;  &lt;% if (theme.stackoverflow){ %&gt;    &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/users/&lt;%- theme.stackoverflow %&gt;&quot; title=&quot;StackOverFlow&quot;&gt;&lt;i class=&quot;fa fa-stack-overflow&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;  &lt;% } %&gt;&lt;/ul&gt;</code></pre><h2 id="个人头像专栏设置">个人头像专栏设置</h2><p><img src="https://i.imgur.com/BBSVXSH.png" alt=""></p><p>这里也是有一个文件保存这些信息 <kbd>header.ejs</kbd></p><pre><code>&lt;div class=&quot;blog-header hidden-xs&quot;&gt;  &lt;img id=&quot;blog-logo&quot; width=&quot;80&quot; height=&quot;80&quot; alt=&quot;Long Shilin&quot; src=&quot;https://www.gravatar.com/avatar/06c71e5f94c268040fd4068f336188e7.png&quot;&gt;  &lt;h2 class=&quot;blog-title&quot;&gt;&lt;%= config.title %&gt;&lt;/h2&gt;  &lt;% if (theme.subtitle){ %&gt;    &lt;p class=&quot;lead blog-description&quot;&gt;&lt;%= theme.subtitle %&gt;&lt;/p&gt;  &lt;% } %&gt;&lt;/div&gt;&lt;div class=&quot;blog-header visible-xs&quot;&gt;  &lt;h1 class=&quot;blog-title&quot;&gt;&lt;%= config.title_mobile %&gt;&lt;/h1&gt;  &lt;% if (theme.subtitle){ %&gt;    &lt;p class=&quot;lead blog-description&quot;&gt;&lt;%= theme.subtitle_mobile %&gt;&lt;/p&gt;  &lt;% } %&gt;&lt;/div&gt;</code></pre><h2 id="博客分享按钮的添加">博客分享按钮的添加</h2><p><img src="https://i.imgur.com/Ycqq7iw.png" alt=""><br>这里我加入来五种平台的分享，其中除微信外，其他集中可以直接跳转到对应的Web或App中进行分享。</p><p>下面主要介绍这几个平台分享URL是如何进行拼接的。当时找微博的url拼接的方法还是找了好一圈，不过最后还是解决了～😄 (有问题可以在下面评论区留言)</p><ul><li>微博、微信、Twitter、Facebook、Google+</li></ul><pre><code>&lt;a href=&quot;http://service.weibo.com/share/share.php?appkey=&amp;title='+ &quot;【&quot; + title + &quot;】&quot; + description +'&amp;url=' + encodedUrl + '&amp;searchPic=false&amp;style=simple&quot; class=&quot;article-share-weibo&quot; target=&quot;_blank&quot; title=&quot;微博&quot;&gt;&lt;/a&gt;,&lt;a href=&quot;http://qr.liantu.com/api.php?text=' + encodedUrl + '&quot; class=&quot;article-share-weixin&quot; target=&quot;_blank&quot; title=&quot;微信&quot;&gt;&lt;/a&gt;,&lt;a href=&quot;https://twitter.com/intent/tweet?url=' + encodedUrl + '&quot; class=&quot;article-share-twitter&quot; target=&quot;_blank&quot; title=&quot;Twitter&quot;&gt;&lt;/a&gt;,&lt;a href=&quot;https://www.facebook.com/sharer.php?u=' + encodedUrl + '&quot; class=&quot;article-share-facebook&quot; target=&quot;_blank&quot; title=&quot;Facebook&quot;&gt;&lt;/a&gt;,&lt;a href=&quot;https://plus.google.com/share?url=' + encodedUrl + '&quot; class=&quot;article-share-google&quot; target=&quot;_blank&quot; title=&quot;Google+&quot;&gt;&lt;/a&gt;</code></pre><h2 id="博客中增加emoji表情">博客中增加emoji表情</h2><p>我推荐这篇博文 <a href="https://www.cnblogs.com/fsong/p/5929773.html" target="_blank" rel="noopener">Hexo中添加emoji表情</a>，持久化保存的pdf版<a href="https://pan.baidu.com/s/1PQdP5PQ-6HqFYAOq0AZY5A" target="_blank" rel="noopener">下载</a></p><h2 id="hexo文章置顶功能">hexo文章置顶功能</h2><p>npm插件：<a href="https://www.npmjs.com/package/hexo-generator-topindex" target="_blank" rel="noopener">hexo-generator-topindex</a></p><p>另外在index页面的文章简介出，修改了显示置顶文章的样式，新增了一个小图标<br><img src="https://i.imgur.com/c5soh5Y.png" alt=""></p><pre><code>&lt;% if (post.top){ %&gt;&lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;font color=7D26CD&gt;&amp;nbsp;置顶 &amp;nbsp;&amp;nbsp;&lt;/font&gt;|&lt;/i&gt;&lt;% } %&gt;</code></pre><h2 id="对接评论系统">对接评论系统</h2><p>在我的博客中，我先后接入评论有四款，按照时间先后顺序分别是：<a href="https://disqus.com" target="_blank" rel="noopener">disqus</a> -&gt; <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a> -&gt; <a href="https://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言</a> -&gt; <a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">valine</a>，现在选择了valine 也是我比较看好的。首先它不像disqus，需要翻墙才能评论，虽然有博友已经开发了对于disqus的代理，但是还是有缺陷；后来转战gitment，这个由于<a href="https://github.com/imsun/gitment/issues/170" target="_blank" rel="noopener">存在第三方验证</a>的事情，感觉会导致评论系统的不稳定；转而国内比较稳的畅言，也因为我的域名有备案，因此还是很顺利的接入了，但是个人感觉UI实在不适合技术类博客，因此最后选择valine这一款评论系统，它是基于<a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud</a>，我们使用免费版即可满足小规模的评论，这里推荐一个valine上手参考博文<a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">Valine Admin 配置手册</a>，支持邮件通知新评论。<a href="https://pan.baidu.com/s/13chCFPv-NX1B0kJUdFl2lw" target="_blank" rel="noopener">Valine Admin pdf版下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第一次来南京</title>
      <link href="/blog/adb7c3d4.html"/>
      <url>/blog/adb7c3d4.html</url>
      
        <content type="html"><![CDATA[<p>这是我第一次来到珊珊的城市，心情无比的激动和兴奋，在这里和我宝开心的渡过了四天假期，下面是我宝精心制作的视频剪辑哦，非常Nice，另外她还给我秀了一波她剪辑的小工具“Vlog” 👯</p><a id="more"></a><video src="http://repo.longshilin.com/video/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8E%BB%E5%8D%97%E4%BA%AC.mp4" poster="https://ws1.sinaimg.cn/large/005EsThygy1fxfy8o5oiij30k20qrnpd.jpg" preload="" controls style="max-width: 60%; display: block; margin-left: auto; margin-right: auto;">your browser does not support the video tag</video>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>利用Docker快速部署wordpress站点</title>
      <link href="/blog/b39d28f7.html"/>
      <url>/blog/b39d28f7.html</url>
      
        <content type="html"><![CDATA[<p>在学习Docker的时候，看到关于通过Docker容器的方式快速搭建WordPress站点，这里加以记录，便于日后的查看。</p><a id="more"></a><h2 id="在单一容器中使用supervisor运行wordpress">在单一容器中使用Supervisor运行WordPress</h2><h3 id="问题">问题</h3><p>你希望在一个容器中运 行应用程序所需的所有服务。以运行 WordPress 为例，你想在一个容器中同时运行 MySQL 和 HTTPD 服务。由于 Docker 运行的是前台进程，所以你需要找到一种同时运行多个“前 台”进程的方式。</p><h3 id="解决方案">解决方案</h3><p>使 用 Supervisor(<a href="http://supervisord.org/index.html" target="_blank" rel="noopener">http://supervisord.org/index.html</a>) 来 监 控 并 运 行 MySQL 和 HTTPD。<br>Supervisor 不是一个 init 系统，而是一个用来控制多个进程的普通程序。</p><p>本范例是一个在容器中使用 Supervisor 同时运行多个进程的例子。你可以以 此为基础在一个 Docker 镜像中运行多个服务(比如 SSH、Nginx)。本范例 中，WordPress 的配置是一个最精简的可行配置，并不适用于生产环境。</p><p>示例中的文件可以在 GitHub(<a href="https://github.com/how2dock/docbook/tree/master/ch01/supervisor" target="_blank" rel="noopener">https://github.com/how2dock/docbook/tree/master/ch01/supervisor</a>) 下载。这些文件中包括一个用于启动虚拟机的 Vagrantfile，Docker 运行在该虚拟机 中，还包含一个 Dockerfile 来定义要创建的镜像，此外还有一个 Supervisor 的配置文件(supervisord.conf)和一个 WordPress 的配置文件(wp-config.php)。</p><p>为了运行 WordPress，你需要安装 MySQL、Apache 2(即 httpd)、PHP 以及最新版本 的 WordPress。你将需要创建一个用于 WordPress 的数据库。在该范例的配置文件中， WordPress 数据库用户名为 root，密码也是 root，数据库名为 wordpress。如果你想对数据 库的配置进行修改，需要同时修改 wp-config.php 和 Dockerfile 这两个文件，并让它们的设 置保持一致。</p><p>这里定义了两个被监控和运行的服务:mysqld 和 httpd。每个程序都可以使用诸如 autorestart 和 autostart 等选项。最重要的指令是 command，其定义了如何运行每个程序。 在这个例子中，Docker 容器只需要运行一个前台进程:supervisord。从 Dockerfile 中的 CMD [“/usr/bin/supervisord”] 这一行也能看出来。</p><p>在你的 Docker 主机上，构建该镜像并启动一个后台容器。如果按照例子中的配置文件使 用了基于 Vagrant 的虚拟机，可以执行如下命令。</p><pre><code> $ cd /vagrant $ docker build -t wordpress . $ docker run -d -p 80:80 wordpress</code></pre><p>容器启动后还会在宿主机和 Docker 容器之间为 80 端口进行端口映射。现在只需要在浏览 器中打开 http://&lt;ip_of_docker_host&gt;，就可以进入到 WordPress 的配置页面了。</p><h3 id="讨论">讨论</h3><p>尽管通过 Supervisor 在一个容器内同时运行多个应用服务工作起来非常完美，但是你最好 还是使用多个容器来运行不同的服务。这能充分利用容器的隔离优势，也能帮助你创建基 于微服务设计思想的应用(参见《微服务设计》1)。最终这也将会使你的应用更具弹性和可 扩展性。</p><h3 id="参考">参考</h3><p>• Supervisor 文档(<a href="http://supervisord.org/index.html" target="_blank" rel="noopener">http://supervisord.org/index.html</a>)<br>• Docker Supervisor 文档(<a href="https://docs.docker.com/articles/using_supervisord/" target="_blank" rel="noopener">https://docs.docker.com/articles/using_supervisord/</a>)</p><h2 id="使用两个链接在一起的容器运行wordpress博客程序">使用两个链接在一起的容器运行WordPress博客程序</h2><h3 id="问题-v2">问题</h3><p>你希望通过容器来运行一个 WordPress 网站(<a href="http://wordpress.com/" target="_blank" rel="noopener">http://wordpress.com/</a>)，但是你不想让 MySQL 和 WordPress 在同一个容器中运行。你时刻谨记对关注点进行分离的原则，并尽 可能地对应用程序的不同组件进行解耦。</p><h3 id="解决方案-v2">解决方案</h3><p>启动两个容器:一个运行来自 Docker Hub(<a href="http://hub.docker.com/" target="_blank" rel="noopener">http://hub.docker.com/</a>)的官方 WordPress， 另一个运行 MySQL 数据库。这两个容器通过 Docker 命令行工具的 --link 选项链接在 一起。<br>开始下载最新的 WordPress(<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><em>/wordpress/)和 MySQL(https://.hub. <a href="http://docker.com/" target="_blank" rel="noopener">docker.com/</a></em>/mysql/)镜像，如下所示。$ docker pull wordpress:latest<br>$ docker pull mysql:latest</p><p>启动一个 MySQL 容器，并通过命令行工具的 --name 选项为这个容器设置一个名称，通过 MYSQL_ROOT_PASSWORD 环境变量来设置 MySQL 的密码，如下所示。</p><pre><code> $ docker run --name mysqlwp -e MYSQL_ROOT_PASSWORD=wordpressdocker -d mysql</code></pre><p>如果在使用 mysql 镜像时没有指定标签，Docker 会自动使用 latest 标签， 这也是前面刚刚下载的镜像。容器通过 -d 选项以守护式的方式开始运行。</p><p>现在就可以基于 wordpress:latest 镜像启动 WordPress 容器了。这个容器将会通过 --link 选 项链接到 MySQL 容器，这样 Docker 会自动进行网络配置，让 WordPress 容器能访问到 MySQL 容器中暴露出来的端口，如下所示。</p><pre><code> $ docker run --name wordpress --link mysqlwp:mysql -p 80:80 -d wordpress</code></pre><p>两个容器都会以后台方式运行，WordPress 容器的 80 端口会被映射到宿主机的 80 端口上， 如下所示。</p><pre><code>[root@ip-172-31-1-1 supervisor]# docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                 NAMES48b9c0cabe31        wordpress           &quot;/usr/bin/supervisord&quot;   5 seconds ago       Up 4 seconds        0.0.0.0:80-&gt;80/tcp    wordpress3756d0e220bf        mysql               &quot;docker-entrypoint...&quot;   44 seconds ago      Up 43 seconds       3306/tcp, 33060/tcp   mysqlwp</code></pre><p>在浏览器中打开 http://&lt;ip_of_host&gt; 就会看到 WordPress 的安装界面，里面有选择语言的窗 口，如图 1-10 所示。完成了 WordPress 的安装过程，你将会得到一个在两个链接到一起的 容器之上运行的 WordPress 网站。</p><h3 id="讨论-v2">讨论</h3><p>这两个 WordPress 和 MySQL 镜像都是官方镜像，分别由 WordPress 和 MySQL 的社区来维护。Docker Hub 这些镜像的页面都有关于如何进行配置以从这些镜像创建容器的详细文档。</p><p>令人感兴趣的是，你可以通过设置几个环境变量来创建一个数据库，并且只有具有相应权 限的用户才能操作数据库:MYSQL_DATABASE、MYSQL_USER 和 MYSQL_PASSWORD。在前面的例子中，WordPress 使用了 MySQL 的 root 用户，这并不是一个好实践。最好是创建一个名 为 wordpress 的数据库，并为其创建一个用户，像下面这样。</p><pre><code>$ docker run --name mysqlwp -e MYSQL_ROOT_PASSWORD=wordpressdocker \                                 -e MYSQL_DATABASE=wordpress \                                 -e MYSQL_USER=wordpress \                                 -e MYSQL_PASSWORD=wordpresspwd \                                 -d mysql</code></pre><p>数据库容器启动之后，可以启动 WordPress 容器并指定你设置好的数据库表，如下所示。</p><pre><code>$ docker run --name wordpress --link mysqlwp:mysql -p 80:80 \                                   -e WORDPRESS_DB_NAME=wordpress \                                   -e WORDPRESS_DB_USER=wordpress \                                   -e WORDPRESS_DB_PASSWORD=wordpresspwd \                                   -d wordpress</code></pre><p>如果你需要删除所有容器，可以使用下面这种嵌套 shell 的快捷方式。</p><pre><code>$ docker stop $(docker ps -q)$ docker rm -v $(docker ps -aq)</code></pre><p>docker rm 命令的 -v 选项用来删除 MySQL 镜像中定义的数据卷。</p><h2 id="docker搭建wordpress的最佳实践">docker搭建WordPress的最佳实践</h2><p>上面两个模块的内容是出自于《docker实战》这本书中，下面我结合自己的实际操作，总结出搭建的实际步骤。</p><h3 id="1-docker-mysql">1.docker mysql</h3><p>实战模块还待完善…敬请期待</p><h2 id="linux搭建wordpress环境">Linux搭建Wordpress环境</h2><p>最后附上不是通过docker方式搭建博客的教程实例<a href="https://docs.ksyun.com/read/latest/129/_book/%E6%90%AD%E5%BB%BAwordpress%E7%8E%AF%E5%A2%83.html" target="_blank" rel="noopener">Linux搭建Wordpress环境</a> <a href="https://github.com/longshilin/files-repo/blob/master/Linux%E6%90%AD%E5%BB%BAWordpress%E7%8E%AF%E5%A2%83%20%C2%B7%20%E9%87%91%E5%B1%B1%E4%BA%91.pdf" target="_blank" rel="noopener">pdf下载</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人建站SEO优化之路</title>
      <link href="/blog/cf14f41a.html"/>
      <url>/blog/cf14f41a.html</url>
      
        <content type="html"><![CDATA[<h2 id="个人站点优化">个人站点优化</h2><ol><li><a href="https://neilpatel.com/wp-content/uploads/2018/10/Neil-Patels-Advanced-Cheatsheet-to-SEO.pdf" target="_blank" rel="noopener">ADVANCED CHEAT SHEET TO SEO.pdf</a></li><li><a href="https://neilpatel.com/blog/personal-branding-seo/" target="_blank" rel="noopener">Personal SEO: 14-Point Checklist to Dominate Your Personal Brand on Google</a></li></ol><h3 id="none"></h3><h2 id="向搜索引擎推送站点链接">向搜索引擎推送站点链接</h2><h3 id="baidudotcom">Baidudotcom</h3><ol><li>获取自动推送脚本 <a href="https://longshilin.com/blog/js/baidu_js_push.js">baidu_push_js</a></li><li>将上述脚本放入<kbd>$themes/layout/layout.ejs</kbd>的<kbd><code>&lt;body&gt;&lt;/body&gt;</code></kbd>体内，即可实现在每个页面的HTML代码中包含以下自动推送JS代码。</li></ol><h3 id="参考">参考</h3><p><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title19" target="_blank" rel="noopener">百度站长工具</a></p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人建站的心路历程</title>
      <link href="/blog/d6a28195.html"/>
      <url>/blog/d6a28195.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/qOzpn01.jpg" alt=""></p><p><a href="https://blog.csdn.net/Coder__CS" target="_blank" rel="noopener"><code>CSDN BLOG</code></a> --&gt; <code>WordPress.com</code> --&gt; <code>wordpress vps</code> --&gt; <a href="https://gitlab.com/longshilin/longshilindotcom" target="_blank" rel="noopener"><code>Hexo + Github</code></a> --&gt; <a href="https://longshilin.gitlab.io/longshilindotcom/blog" target="_blank" rel="noopener"><code>gitlab pages</code></a> (阶段性胜利)</p><a id="more"></a><p>从2016年春天开始我的博客记录以来，这里走过了两年半的时间，其中前面两年是大学期间，因此主要是以CSDB Blog为主，而在最近的半年，才开始往自定义博客方面来考虑，下面我会分享我在上面给出的建站历程中的收获和好玩的事。</p><h2 id="为什么要写博客">为什么要写博客</h2><h3 id="它的意义是什么？">它的意义是什么？</h3><p>写博的过程是一个对知识的总结和提炼的过程，它是知识通过大脑加工后的产物，可以被持久化的有价值的东西。当你想通过文字的方式记录时，或者你想和他人分享时，写博这个举动也就应运而生。</p><h3 id="它的好处在哪？">它的好处在哪？</h3><ul><li>其一、由于它是一个持久化的东西，相较而言短期内不会消失，因此可以通过博客，窥探你最近的个人动态。</li><li>其二、可以作为归档地，将总结的知识整理为博客，方便日后查找。</li><li>其三、作为自己学习的成功展示和短期总结，更是为日后的二次更新优化提供基础蓝本。</li></ul><h3 id="为什么选择迁移自定义博客">为什么选择迁移自定义博客?</h3><p>所谓迁移自定义博客，指的是通过自己的域名，访问自己搭建的博客，使用DIY博客主题，撰写所学所感所悟…<br>那为什么要这么做呢，首先与第三方博客平台解耦合，能够脱离原博客平台对博客主题的限制，以此更能凸显自定义需求。另外，自定义博客是一个言论自由的地方，不会被第三方博客平台干涉。对于博客的持久化发布也更加彻底。另外，可以完全抛除博客界面嵌入广告之嫌，这也是我不选择第三方博客平台的原因，他们博客网站需要盈利，因此需要广告要盈收这个无可厚非。</p><h2 id="阶段性胜利的前因后果">阶段性胜利的前因后果</h2><h3 id="csdn-blog">CSDN BLOG</h3><p>这是我经历时间最长的<a href="https://blog.csdn.net/Coder__CS" target="_blank" rel="noopener">博客</a>，伴随着我大学后半段时间，因此上面记录着我大学期间的所学所感所悟。</p><h3 id="wordpress-com"><a href="http://WordPress.com" target="_blank" rel="noopener">WordPress.com</a></h3><p>第一次尝试是在<a href="https://wordpress.com/" target="_blank" rel="noopener">wordpress.com</a>搭建在线的博客网站，你无须掌握任何的网站搭建技术，只需要轻点鼠标即可完成所有设置操作，并可以更换博客主题以及自定义插件等等。</p><h3 id="wordpress-vps">wordpress vps</h3><p>算起来，从五一劳动节申请服务器主机到现在也就五个月不到，在那个三天假期，完成了WordPress在服务器上的搭建，并成功部署了自己的博客网站，并将访问站点添加了SSL证书，由http访问转为https。（开销：1核500MB内存，每个月500G流量的搬瓦工VPS服务器，上面搭建的ssr服务现在也还在用）</p><h3 id="hexo-github">Hexo + Github</h3><p>在上一步中提到的在服务器上搭建WordPress博客框架，各方面体验都很不错，但是我马上意识到这不是一个长久的办法，虽然部署博客网站以及自定义博客主题都非常方便，是以界面点击方式来进行的，但是你需要为服务器长期支付费用，而我的需求仅仅是一个博客站点，无需通过服务器来大动干戈。</p><p>所以采用下面的静态网站构建的方式：利用<a href="https://hexo.io" target="_blank" rel="noopener">hexo</a>框架构建静态网页，利用<a href="https://pages.github.com/" target="_blank" rel="noopener">github pages</a>功能来部署和发布。在实践过程中，时间主要花在git分支处理，以及博客主题的修改上。学习和了解了hexo主题模板构造模块和修改技巧等。</p><h3 id="gitlab-pages">Gitlab Pages</h3><p>采用Gitlab Page功能，并提供pages模板，你能够轻松部署静态网站，并通过Gitlab提供的CI/CD功能，轻松实现持续集成持续发布，修改提交即发布的理念, 详见<a href="https://longshilin.com/blog/2018/09/22/website-on-gitlab/">GitLab CI/CD</a>.</p><p>更多内容，详见 <a href="https://docs.gitlab.com/ee/university/README.html" target="_blank" rel="noopener">GitLab University</a></p><h3 id="wiki">wiki</h3><p>通过<a href="http://simiki.org/" target="_blank" rel="noopener">simiki框架</a>，搭建了自己的<a href="https://longshilin.gitlab.io/longshilindotcom/wiki" target="_blank" rel="noopener">wiki站点</a>，这个是个人网站的一部分，用来记录流程化的东西。</p><h2 id="个人写博的最佳实践">个人写博的最佳实践</h2><p>这里我会将我最终总结沉淀下来的写博最佳实践加以分享。</p><ul><li><p>编辑器 <a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> ，另外新增了几个插件，能够非常方便的支持我的写作：<br><img src="https://i.imgur.com/WL0Sz2j.png" alt="atom-plugin-for-markdown"></p></li><li><p>发布及部署平台 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitLab Pages</a><br><img src="https://i.imgur.com/nwIAHtY.png" alt="pages-group"></p></li></ul><p>在前期的搭建环境及其部署工作准备就绪后，我后期需要关注的仅仅是写作本身，另外将我新增的文件推送到远程代码仓库，仅此而已。然后稍微等待one minute，就可以在 <a href="https://longshilin.com/blog">页面</a> 上看到我的新增内容了。</p><h2 id="总结">总结</h2><p>回顾这整个搭建历程，给我感触最深的体会就是：**兴趣驱使着我往前走，折腾精神使得我有所收获！**不满足才能探索更大的未来，不是未来没有而是自己认知不够，因为你还远远没有触及边界。</p><blockquote><p>Change Log<br>2018/10/15 - 新增个人写博的最佳实践</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> longshilindotcom </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>有关AWS考证的思考</title>
      <link href="/blog/112641e9.html"/>
      <url>/blog/112641e9.html</url>
      
        <content type="html"><![CDATA[<p>对于之前做的几件事，其实会把对于aws复习的内容有所推迟，比如最近一直在做的个人建站以及工作上的开发事情，但是话说回来，虽然时间花在其他事情上面，但是要想达到备考AWS的状态，你就必须每天抽出一定的时间来定时学习和看书刷题等等。</p><p>下面我会做出一个细致的计划安排，在转正之前能够顺利考证（预计转正是2018-11-15，离现在还有50天不到），仔细想一想🤔，时间真的不多了哈。</p><a id="more"></a><p>按照之前的学习情况，自己做了有关<code>aws sdk for java</code>的接入，能够实现EC2对象的信息获取。现在准备起来，应该更加顺利～</p><table><thead><tr><th>备考要求</th><th>备考类型</th><th>备考内容</th><th>时间节点</th></tr></thead><tbody><tr><td>⚠️重点</td><td>看书</td><td>AWS-SYSOPS认证</td><td>两个星期左右的时间，书籍➕章节习题</td></tr><tr><td>重点</td><td>每个服务后面的Q&amp;A</td><td>常见问题的熟悉</td><td>一个星期轮完所有服务</td></tr><tr><td>重点</td><td>白皮书</td><td>每个类型服务的白皮书以及最佳实践</td><td>一个星期轮完</td></tr><tr><td>重点</td><td>练习题</td><td>历史公布的题库</td><td>最后的时间</td></tr></tbody></table><p>每天都要抽出大量的时间来进行自我备考学习，抽出全部的私人时间来投入最后的备考，真的不能再拖了… 时间节点很重要，时间计划和进度把控也要具备。</p><h2 id="aws-sysops书籍学习">AWS-SYSOPS书籍学习</h2><p><img src="https://i.imgur.com/cdGh95j.png" alt=""><br><a href="https://www.wiley.com/WileyCDA/WileyTitle/productCd-1119377420,miniSiteCd-SYBEX.html" target="_blank" rel="noopener">AWS Certified SysOps Administrator Official Study Guide: Associate Exam</a></p><p>电子版英文原版书籍 通过配合<a href="https://drive.google.com/drive" target="_blank" rel="noopener">Google Driver</a>和<a href="https://docs.google.com/document" target="_blank" rel="noopener">Google Document</a>在线编辑工具来整篇翻译PDF。这里需要注意的是：Google Document支持的在线翻译内容长度有限制，需要借助<a href="https://www.ilovepdf.com/zh_cn/fencai_pdf" target="_blank" rel="noopener">PDF分割工具</a>进行拆分。</p><p>在本书中访问<a href="http://www.wiley.com/go/sybextestprep" target="_blank" rel="noopener">http://www.wiley.com/go/sybextestprep</a>，使用学习工具注册并访问此交互式在线学习环境和测试库。具体的注册流程如下：</p><ul><li>进入<a href="http://customer.wiley.com/CGI-BIN/lansaweb?procfun+shopcart4+SH4FN19+funcparms+PARMKEYG%28A0060%29:SYBEX" target="_blank" rel="noopener">链接</a>，通过注册回答有关问题，获取访问PIN码。</li><li>收到包含PIN码的邮件。</li><li>点击<a href="http://testbanks.wiley.com/" target="_blank" rel="noopener">Register PIN or Login</a>，填入你的个人信息以及PIN码完成账号注册。</li><li>你就可以开始您自己的自定进度测试准备，<a href="https://testbanks.wiley.com/WPDACE/Products" target="_blank" rel="noopener">点击进入</a></li></ul><p><img src="https://i.imgur.com/2rGORyT.png" alt=""></p><p><img src="https://i.imgur.com/6KKopqj.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 认证 </category>
          
          <category> AWS认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aws </tag>
            
            <tag> sysops </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GitLab CI/CD</title>
      <link href="/blog/b4ccb03f.html"/>
      <url>/blog/b4ccb03f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/BrmSMBD.png" alt="GitLab CI/CD"></p><p>在之前的github上搭建静态资源网站的基础上有了新的提升。把原来在本地机器编译的工作，通过gitlab实现自动化编译部署及发布，我只用专注于写作及将写好的内容上传到gitlab上即可。这也是现在最流行的CI/CD理念（持续集成持续发布）。</p><a id="more"></a><blockquote><p>下面着重来说明下我在部署过程中主要过程及填的坑等等，主要是提供一个部署思路和学习路径。</p></blockquote><h2 id="注册gitlab账号">注册gitlab账号</h2><p>在进行此次迁移资源之前，我是没有接触过<a href="https://gitlab.com/" target="_blank" rel="noopener">gitlab</a>的，自己这一块也是现用现学，所以说都是自己需要才会真正去接触它和学习它，好了继续~</p><h2 id="官方pages">官方Pages</h2><p>在gitlab上，有专门的<a href="https://gitlab.com/pages" target="_blank" rel="noopener">pages页面</a>，这里目前总共有三十种不同的模板，种类还是一应俱全。下面是首页的内容<br><img src="https://i.imgur.com/pXS3DgP.png" alt="gitlab pages"></p><p>我们的目的是通过官方<a href="https://gitlab.com/pages/hexo" target="_blank" rel="noopener">hexo pages</a>来学习快速入门及部署我们自己的静态网页。</p><h2 id="学习yaml">学习YAML</h2><p>通过gitlab<a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">YAML官方文档</a>来学习YAML格式，这里我展示下在我的项目中的YAML文件</p><pre><code>image: longsl/hexo2simikipages:  cache:    paths:    - blog/node_modules/  script:    - HOME=/builds/longshilin/longshilindotcom    - cd blog    - npm install    - hexo deploy    - cp -r blog $HOME/public    - cd $HOME/wiki    - simiki g    - cp -r wiki $HOME/public/  artifacts:    paths:    - public  only:  - master</code></pre><p>这里还是比较清晰，容易理解的。上面的YAML文件主要进行的操作时通过longsl/hexo2simiki镜像作为基础环境，并在上面进行项目构建，并将指定的文件目录public作为发布资源进行发布。详细说明：</p><ol><li>image是本次构建所使用的镜像，这里我使用的是包含hexo和simiki构建工具的自定义镜像，详见<a href="https://longshilin.com/blog/2018/09/22/hexo2simiki/">hexo2simiki</a></li><li>pages表示是一个默认的任务</li><li>cache表示在该任务下将指定的路径下的文件进项缓存（其实就是在构建开始的时候将上次打包并保存的文件再次拿来用），这样在每次构建并发布时，可以省去很多固定资源的构建开销。</li><li>script下面是编写shell脚本，这些脚本命令直接就是在docker容器中执行的，因此如果你的镜像时以linux为基础，可以直接执行。</li><li>artifacts是发布项，可以指定本次构建出的哪部分内容会被保留下来，并作为该pipline的发布源文件。</li><li>only指的是本次job任务只会涉及到master分支上的内容。</li></ol><p>更多信息详见 <a href="https://docs.gitlab.com/ce/ci/" target="_blank" rel="noopener">GitLab Continuous Integration</a></p><h2 id="部署及发布">部署及发布</h2><p>编写自己的.gitlab-ci.yml文件，并放在项目的根目录下，这样在每次有新的更新提交到gitlab上时，会自动触发进行项目构建。</p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给自定义博客增加totop按钮</title>
      <link href="/blog/5b764c97.html"/>
      <url>/blog/5b764c97.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://longshilin.com/images/20190507102321.png" alt=""><br>新增图片右下角的totop按钮</p><a id="more"></a><h3 id="新增totop-ejs文件">新增totop.ejs文件</h3><p>在文件目录<code>blog/themes/hexo-theme-bootstrap-blog/layout/_partial</code>中新增 <a href="https://gitlab.com/longshilin/longshilindotcom/blob/master/blog/themes/hexo-theme-bootstrap-blog/layout/_partial/totop.ejs" target="_blank" rel="noopener">totop.ejs</a></p><h3 id="修改layout-ejs">修改layout.ejs</h3><p>layout.ejs表示的是blog页面的主页面样式排版，将上一步中的文件纳入到最终的页面样式中。</p><pre><code>&lt;%- partial('_partial/totop') %&gt;</code></pre><h3 id="js文件">js文件</h3><p><a href="https://gitlab.com/longshilin/longshilindotcom/blob/master/blog/themes/hexo-theme-bootstrap-blog/source/js/totop.js" target="_blank" rel="noopener">totop.js</a></p><h3 id="css格式">css格式</h3><pre><code class="language-css">#totop {  position: fixed;  bottom: 4em;  right: 2em;  cursor: pointer;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gitlab绑定域名</title>
      <link href="/blog/57c188a8.html"/>
      <url>/blog/57c188a8.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/rQfzXnn.png" alt=""></p><p>通过gitlab部署并发布静态网站，通过绑定自己的域名来实现自定义访问。</p><a id="more"></a><p>在项目的设置中，选择pages项，里面配置你的域名证书，这里可以使用域名的注册商提供给你的证书，或者是通过<a href="https://freessl.org/" target="_blank" rel="noopener">FreeSSL</a>提供免费证书申请，将得到的证书文件依次拷贝到Pages中，创建 <strong>New Pages Domain</strong></p><p><img src="https://i.imgur.com/vO69TtL.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab pages </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>构建hexo和simiki工具的docker镜像</title>
      <link href="/blog/fd401cf5.html"/>
      <url>/blog/fd401cf5.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/flxHs0r.png" alt=""><br>基于<a href="https://hexo.io" target="_blank" rel="noopener">hexo</a>和<a href="http://simiki.org/" target="_blank" rel="noopener">simiki</a>工具构建基础镜像环境，用作我website项目中<a href="https://longshilin.com/blog/2018/09/22/website-on-gitlab/">website-on-gitlab CI/CD</a>的基础镜像。并将其发布到Docker Hub的<br><a href="https://hub.docker.com/r/longsl/hexo2simiki/" target="_blank" rel="noopener">PUBLIC REPOSITORY</a></p><a id="more"></a><h1>DockerFile</h1><p>通过官方centos7镜像为基础来构建包含构建website的构建环境。具体的环境包括：hexo, python3.6, nodejs, simiki, pip3.6</p><pre><code>FROM centos#安装EPEL依赖 Python3.6 pip3 nodejs npm hexo simikiRUN yum install -y epel-release; yum install -y https://centos7.iuscommunity.org/ius-release.rpm; yum install -y python36u; yum install -y python36u-pip; pip3.6 install --upgrade pip; curl -sL https://rpm.nodesource.com/setup_8.x | bash -; yum install -y nodejs; npm install hexo-cli -g; pip3.6 install simiki</code></pre><h1>Docker Build</h1><pre><code>docker build -t longsl/hexo2simiki .</code></pre><h1>Docker Container</h1><pre><code>docker run -it --rm longsl/hexo2simki /bin/sh</code></pre><h1>Supply</h1><p>关于下载最新版本的nodejs费了笔者一些功夫，因为通过<code>yum install -y nodejs</code>直接下载的包不是最新的版本，在hexo构建时，会提示npm版本过低的报错，因此我通过参考 <a href="https://linuxize.com/post/how-to-install-node-js-on-centos-7/" target="_blank" rel="noopener">How to install Node.js on CentOS 7</a>，更新yum源来下载node 8.x的版本。</p><pre><code>curl -sL https://rpm.nodesource.com/setup_8.x | sudo bash -sudo yum install nodejs</code></pre>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> simiki </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>公司团建</title>
      <link href="/blog/7380e114.html"/>
      <url>/blog/7380e114.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/7umqiRu.jpg" alt="团建公司合照"><br>今天（2018-09-15）迎来了90km的2018年秋季团建。上面这张是我们本次团建收获的团队合照~~</p><a id="more"></a><h1>清晨集合 准备出发</h1><p>早市八点在公司集合，八点半准时出发。我们搭乘的旅游车分成经济舱和商务舱两个部分，两辆大巴塞下了全公司。</p><p>这次我们要驱车200多公里，来到浙江省湖州市安吉县的百草原景区参加公司团建，下面是我google地图路线。<br><img src="https://i.imgur.com/zExtQ8S.png" alt="永和路--安吉百草原"></p><p>经过上午的颠簸，我们在中午12点多到达安吉县，在进行午饭会餐后，我们又驱车前往下午的活动场地–<a href="http://www.znc.cn/" target="_blank" rel="noopener">中南百草原</a></p><p>来到了浙江湖州的安吉县-百草原景区，开展我们的团建活动，整个园区的风景还是非常nice的~<br><img src="https://i.imgur.com/JZmpRcN.jpg" alt=""></p><h1>团建活动</h1><h2 id="团队制作赛车大比拼">团队制作赛车大比拼</h2><p>我们将公司70多位员工分为6组，每组需要在一个小时内，完成整个赛车的拼装与装饰，而且要求能够乘人，即精美与实用性并存的赛车制作大赛。</p><p>下面我通过图片的形式加以展现每个队的风采</p><p><img src="https://i.imgur.com/oGUrs5k.jpg" alt="Part 1"></p><p><img src="https://i.imgur.com/LypeUUI.jpg" alt="Part 2"></p><p><img src="https://i.imgur.com/lcAYaj4.jpg" alt="Part 3"></p><p><img src="https://i.imgur.com/3TYqbjM.jpg" alt="Part 4"></p><p><img src="https://i.imgur.com/ADHbxKI.jpg" alt="Part 5"></p><p><img src="https://i.imgur.com/SAV6hqx.jpg" alt="Part 6"></p><h2 id="真人cs">真人CS</h2><p><img src="https://i.imgur.com/0nOTCW0.jpg" alt=""></p><p><img src="https://i.imgur.com/AR2I9Yw.jpg" alt=""></p><p><img src="https://i.imgur.com/oj0j4B2.jpg" alt=""></p><h2 id="卡丁车项目">卡丁车项目</h2><p><img src="https://i.imgur.com/RNGwfmO.jpg" alt=""></p><p><img src="https://i.imgur.com/xMLCSPL.jpg" alt=""></p><h1>团建晚会</h1><h2 id="bbq烧烤">BBQ烧烤</h2><p><img src="https://i.imgur.com/tU7ofPq.jpg" alt=""></p><p><img src="https://i.imgur.com/AxXd7h3.jpg" alt=""></p><p><img src="https://i.imgur.com/JDHIaGV.jpg" alt=""></p><h2 id="游戏晚会">游戏晚会</h2><p><img src="https://i.imgur.com/nkq5aYw.jpg" alt="被打扮得婀娜多姿的公司男同事们 (/ω＼)"></p><p><img src="https://i.imgur.com/NgEqL2e.jpg" alt=""></p><h2 id="篝火晚会">篝火晚会</h2><p><img src="https://i.imgur.com/BprN7Ql.jpg" alt=""></p><p><img src="https://i.imgur.com/BAZpIdh.jpg" alt=""></p><p><img src="https://i.imgur.com/pALx5qf.jpg" alt=""></p><p><img src="https://i.imgur.com/CJSMKaz.jpg" alt=""></p><p><img src="https://i.imgur.com/Op5uCqP.jpg" alt=""></p><h1>参观大熊猫</h1><p><img src="https://i.imgur.com/QoH3HfE.jpg" alt="so cute"></p><div class="video-container"><iframe src="//www.youtube.com/embed/LW2D7D5kbro" frameborder="0" allowfullscreen></iframe></div><h1>感触</h1><p>在这两天一晚的团建活动中，我收获了很多，其中除了放松身心外，还包括对公司文化的人士，朋友结交以及团队的建设方面都有深刻的体会。</p><p>谢谢公司的良好氛围，另外附上一段当晚住的四星级酒店的小视频 YouTube视频需要科学上网：)</p><div class="video-container"><iframe src="//www.youtube.com/embed/njhPDOC1hqY" frameborder="0" allowfullscreen></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 90km </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>制作带有java监控命令的镜像</title>
      <link href="/blog/5544e824.html"/>
      <url>/blog/5544e824.html</url>
      
        <content type="html"><![CDATA[<p>在生产环境中，经常有docker容器的CPU消耗太高而导致宿主机的CPU占用率攀升，引起AWS CloudWatch的警报邮件等，另外在批量重启容器的时候，也会经常遇到短暂对宿主机的CPU消耗过高的情况，现阶段准备再原来的容器中新增java的监控命令。具体是在镜像中包含如：jps、jstat和ps等命令的容器。</p><a id="more"></a><h2 id="寻找包含jstat的openjdk">寻找包含jstat的openjdk</h2><p>可以通过以下命令查找哪些openjdk版本包中含需要的命令。</p><pre><code>yum provides &quot;*jstat&quot; --enablerepo=epelyum provides &quot;*jps&quot; --enablerepo=epelyum provides &quot;*ps&quot; --enablerepo=epel</code></pre><p>最终选择你需要的版本，这里我选择的是<code>java-1.8.0-openjdk-devel-1.8.0.181-3.b13.el7_5.x86_64</code>,在这个版本包中包含所需的java监控命令。</p><blockquote><p><strong>(一步到位, 一个Dockerfile搞定所有)</strong></p></blockquote><h2 id="制作非缩减版镜像">制作非缩减版镜像</h2><h3 id="dockfile">Dockfile</h3><pre><code class="language-dockerfile">FROM docker.io/centos:7.4.1708# authorMAINTAINER longsl &lt;583297550@qq.com&gt;# install jdk including jps,jstat,ps command.RUN yum -y update &amp;&amp; yum -y install java-1.8.0-openjdk-1.8.0.191.b12-0.el7_5.x86_64 &amp;&amp; yum -y install java-1.8.0-openjdk-devel-1.8.0.191.b12-0.el7_5.x86_64# add group and user in OSRUN groupadd -g 2003 kpgame &amp;&amp; useradd -u 2003 -g 2003 -s /sbin/nologin -d /dev/null -M kpgame# add tomcat gzfileADD tomcat8.tar /usr/local/tomcat/ADD kp.tar /usr/local/tomcat/webapps/kp/# set envADD https://s3.amazonaws.com/resource.pinball-heroes.com/dockerfiles/common/tomcat/setenv.sh /usr/local/tomcat/binRUN chown -R kpgame:kpgame /usr/local/tomcat/ENV CATALINA_HOME /usr/local/tomcatENV CATALINA_BASE /usr/local/tomcatENV PATH ${PATH}:${JAVA_HOME}/bin::$CATALINA_HOME/lib:$CATALINA_HOME/bin# run container with base path:/usr/local/tomcat/bin/catalina.shCMD [&quot;/usr/local/tomcat/bin/catalina.sh&quot;, &quot;run&quot;]</code></pre><h3 id="build-image">build image</h3><pre><code class="language-bash">#! /bin/bashsudo docker build -t longsl/kp .</code></pre><h3 id="进入容器内部">进入容器内部</h3><pre><code class="language-bash">sudo docker exec -it KP_KP_SERVER_s8009_kp_29 /bin/bash# 通过镜像的方式直接启动容器并进入sudo docker run -it ec2-18-221-193-240.us-east-2.compute.amazonaws.com/kp-longsl /bin/bash</code></pre><h3 id="镜像大小">镜像大小</h3><pre><code class="language-bash">ec2-18-221-193-240.us-east-2.compute.amazonaws.com/kp   latest   4870cc895b20   3 hours ago   499 MB</code></pre><blockquote><p><strong>（分步完成）</strong></p></blockquote><h2 id="制作openjdk-tomcat8-image-第一步">制作openjdk+tomcat8 Image（第一步）</h2><p>上面那种是一次构建完成所有步骤，在我们的集群环境中，可能存在项目包的版本更新，所有需要制作一个基础的jdk+tomcat的基础版本，然后在这个镜像之上进行项目的版本迭代。</p><h3 id="dockerfile">Dockerfile</h3><pre><code class="language-dockerfile">FROM docker.io/centos:7.4.1708# authorMAINTAINER longsl &lt;583297550@qq.com&gt;# install jdk including jps,jstat,ps command.RUN yum -y install java-1.8.0-openjdk-devel-1.8.0.181-3.b13.el7_5.x86_64# add group and user in OSRUN groupadd -g 2003 kpgame &amp;&amp; useradd -u 2003 -g 2003 -s /sbin/nologin -d /dev/null -M kpgame# add tomcat gzfileADD tomcat8.tar.gz /usr/local/tomcat/</code></pre><h3 id="build-image-v2">build image</h3><pre><code class="language-bash">sudo docker build -t longsl/tomcat:8.0 .</code></pre><h2 id="制作镜像-第二步">制作镜像（第二步）</h2><h3 id="dockerfile-v2">Dockerfile</h3><pre><code class="language-dockerfile"># kpserver dockerfileFROM ec2-18-221-193-240.us-east-2.compute.amazonaws.com/tomcatMAINTAINER dingxing &lt;303159963@qq.com&gt;ADD https://s3.amazonaws.com/resource.pinball-heroes.com/dockerfiles/common/tomcat/setenv.sh /usr/local/tomcat/binADD kp.tar /usr/local/tomcat/webapps/kp/RUN chown -R kpgame:kpgame /usr/local/tomcat/CMD [&quot;/usr/local/tomcat/bin/catalina.sh&quot;, &quot;run&quot;]</code></pre><h3 id="build-image-v3">build image</h3><pre><code class="language-bash">sudo docker build -t ec2-18-221-193-240.us-east-2.compute.amazonaws.com/kp:P11_1_V1.05.longsl .</code></pre><h3 id="镜像大小-v2">镜像大小</h3><pre><code class="language-bash">ec2-18-221-193-240.us-east-2.compute.amazonaws.com/kp  P11_1_V1.05.longsl   8bcfe44ba2e5   9 minutes ago   617 MB</code></pre><h2 id="测试centos官方镜像">测试centos官方镜像</h2><h3 id="官方centos7镜像">官方centos7镜像</h3><pre><code class="language-bash">sudo docker run -it centos:7.5.1804 /bin/bashsudo docker images | grep centos7.5.1804docker.io/centos      7.5.1804     fdf13fa91c6e      4 weeks ago      200 MB</code></pre><h3 id="官方最小版centos7镜像">官方最小版centos7镜像</h3><p>操作系统模板缓存是安装在容器中的操作系统模板，然后打包到gzip压缩包中。使用这样的缓存，可以在几分钟内创建新容器。<br>导入模板并启动容器 <a href="https://download.openvz.org/template/precreated/" target="_blank" rel="noopener">模板下载地址</a></p><pre><code class="language-bash">docker import https://download.openvz.org/template/precreated/centos-7-x86_64-minimal.tar.gz longsl/centos-7-x86_64-minimalsudo docker images | grep centos-7-x86_64-minimallongsl/centos-7-x86_64-minimal     latest    08001dd5a457    7 minutes ago     435 MBsudo docker run -it longsl/centos-7-x86_64-minimal /bin/bash</code></pre><h2 id="制作精简版镜像-一个dockerfile搞定所有">制作精简版镜像(一个Dockerfile搞定所有)</h2><p>精简版镜像主要缩减的地方：centos不能缩减，jdk可以缩减到只需要最基本的功能。</p><h3 id="缩减jdk源文件">缩减jdk源文件</h3><pre><code class="language-bash">#首先下载jre，下载地址是https://www.java.com/en/download/manual.jsp，大概是77M。wget http://javadl.oracle.com/webapps/download/AutoDL?BundleId=234464_96a7b8442fe848ef90c96a2fad6ed6d1mv AutoDL\?BundleId\=234464_96a7b8442fe848ef90c96a2fad6ed6d1 jre-8u181-linux-x64.tar.gz#解压，删除根目录下文本文件，然后删除其他不必要文件。tar xvcf jre-8u161-linux-x64.tar.gz#进入目录cd jre1.8.0_161/#删除文本文件rm -rf COPYRIGHT LICENSE README release THIRDPARTYLICENSEREADME-JAVAFX.txt THIRDPARTYLICENSEREADME.txt Welcome.html#删除其他无用文件rm -rf  lib/plugin.jar \           lib/ext/jfxrt.jar \           bin/javaws \           lib/javaws.jar \           lib/desktop \           plugin \           lib/deploy* \           lib/*javafx* \           lib/*jfx* \           lib/amd64/libdecora_sse.so \           lib/amd64/libprism_*.so \           lib/amd64/libfxplugins.so \           lib/amd64/libglass.so \           lib/amd64/libgstreamer-lite.so \           lib/amd64/libjavafx*.so \           lib/amd64/libjfx*.so# 重新打包所有文件(不打包也可以，在Dockerfile里ADD这个目录即可，当前精简完jre目录大小是107M，压缩后是41M)# 注意这里打出的包解压出来就直接是各个文件模块，不包含外层的文件夹tar -zcvf jre8.tar.gz *</code></pre><h3 id="dockerfile-v3">Dockerfile</h3><pre><code class="language-dockerfile">FROM docker.io/centos:7.4.1708# authorMAINTAINER longsl &lt;583297550@qq.com&gt;# install slim jdkADD jre8.tar.gz /usr/local/jdk/# add group and user in OSRUN groupadd -g 2003 kpgame &amp;&amp; useradd -u 2003 -g 2003 -s /sbin/nologin -d /dev/null -M kpgame# add tomcat gzfileADD tomcat8.tar /usr/local/tomcat/ADD kp.tar /usr/local/tomcat/webapps/kp/# set envADD https://s3.amazonaws.com/resource.pinball-heroes.com/dockerfiles/common/tomcat/setenv.sh /usr/local/tomcat/binRUN chown -R kpgame:kpgame /usr/local/tomcat/ENV JAVA_HOME /usr/local/jdk/ENV CATALINA_HOME /usr/local/tomcatENV CATALINA_BASE /usr/local/tomcatENV PATH ${PATH}:${JAVA_HOME}/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin# run container with base path:/usr/local/tomcat/bin/catalina.shCMD [&quot;/usr/local/tomcat/bin/catalina.sh&quot;, &quot;run&quot;]</code></pre><h3 id="build-image-v4">build image</h3><pre><code class="language-bash">sudo docker build ec2-18-221-193-240.us-east-2.compute.amazonaws.com/kp:kp-slim .</code></pre><h3 id="镜像大小-v3">镜像大小</h3><pre><code>ec2-18-221-193-240.us-east-2.compute.amazonaws.com/kp   kp-slim   3187e2e4a18d   36 minutes ago   458 MB</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>致  谢</title>
      <link href="/blog/e3e209fc.html"/>
      <url>/blog/e3e209fc.html</url>
      
        <content type="html"><![CDATA[<p>从论文的选题、资料收集再到撰写的整个过程，在碰到基因测序的疑难问题时，得到了许多老师和同学的热情帮助。</p><p>首先，我要感谢的是我的导师邝祝芳老师，当他得知我的毕设课题需要大数据平台与基因测序结合，询问我是否需要高性能计算的服务器，并随后立马帮我申请了湖南大学的天河一号超级计算机的使用账号。在我毕业设计的基因样本数据的准备过程，和基于Hadoop大数据平台的搭建过程中，他对我的研究提出了很多宝贵的意见，这也使我基因测序的研究方向更加清晰了，最后得以顺利开发出系统平台。</p><a id="more"></a><p>其次要感谢我们学院计算机教研室的各位老师们，在大学四年的求学生涯中，是他们循循善诱的教导开启了我的计算机专业的大门，并给了我无尽的启迪，使我毕业后能从事计算机行业相关工作，非常感谢老师们！</p><p>最后我要感谢陪伴在我身边的父母、同学和朋友们，谢谢他们在我成长过程中提出的意见和建议，感谢他们给我的生活提供的支持和帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>参 考 文 献</title>
      <link href="/blog/3a1e37f9.html"/>
      <url>/blog/3a1e37f9.html</url>
      
        <content type="html"><![CDATA[<p>[1] Sanger, F. &amp; Nicklen, S. DNA sequencing with chain-terminating[P]. 74, 5463–5467 (1977).<br>[2] Struster SC.Next-generation sequencing transform today’s biology[J].Nat Methods.5(1):16-18 (2008).</p><a id="more"></a><p>[3] 解增言,林俊华,谭军,舒坤贤. DNA测序技术的发展历史与最新进展[J]. 生物技术通报. 2010(08).<br>[4] Rusk N. Cheap third-generation sequecing[J]. Nature. 6(4): 244-245 (2011).<br>[5] J. Craig Venter, Mark D. Adams, Eugene W. Myers. The Sequence of the Human Genome[J]. Science, 2001, 291(5507): 1304-1351.<br>[6] 高通量DNA测序技术及其应用进展[J]. 于聘飞,王英,葛芹玉. 南京晓庄学院学报2010-05-20 (05).<br>[7] 衣春翔. 哈工大牵头启动十万人基因组计划[N]. 黑龙江日报. 2017-12-29 (003).<br>[8] Jeffrey Dean, Sanjay Ghemawat. MapReduce: Simplified Data Processing on Large Clusters[C]. America:Google, Inc., 2004. 137-149.<br>[9] Garry Turkington. Hadoop基础教程[M]. 张治起译. 人民邮电出版社 第1版, 2014.<br>[10] 新一代基因组测序-通往个性化医疗[M]. 贾尼特编著,薛庆中等译. 科学出版社, 2012.<br>[11] 蔡斌, 陈湘萍. Hadoop 技术内幕：深入解析Hadoop Common 和HDFS 架构设计与实现原理[M]. 机械工业出版社, 2013.<br>[12] 董西成. Hadoop技术内幕：深入解析MapReduce架构设计与实现原理[M]. 机械工业出版社, 2013.<br>[13] 董西成. Hadoop技术内幕：深入解析YARN架构设计与实现原理[M]. 机械工业出版社, 2013.<br>[14] 陈浩锋. 新一代基因组测序技术[M]. 科学出版社, 2017.<br>[15] Richard M, Leggett. Sequencing quality assessment tools to enable data-driven informatics for high throughput genomics[R]. US National Library of Medicine, 2013. 4-28.<br>[16] FastQC. The FastQC Toolkit[EB/OL]. <a href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/" target="_blank" rel="noopener">https://www.bioinformatics.babraham.ac.uk/projects/fastqc/</a>, 2018.<br>[17] Li H1, Durbin R. Fast and accurate short read alignment with Burrows-Wheeler transform[R]. US National Library of Medicine, 2009.<br>[18] BioITeam. Burrows-Wheeler Aligner[EB/OL]. <a href="https://github.com/lh3/bwa" target="_blank" rel="noopener">https://github.com/lh3/bwa</a>, 2018.<br>[19] Heng, Li. SAMtools[EB/OL]. <a href="http://samtools.sourceforge.net/" target="_blank" rel="noopener">http://samtools.sourceforge.net/</a>, 2018.<br>[20] BroadInstitute. The Genome Analysis Toolkit[EB/OL]. <a href="https://software.broadinstitute.org/gatk/" target="_blank" rel="noopener">https://software.broadinstitute.org/gatk/</a>, 2018.<br>[21] Joseph M. Caswell. Equilibrium and Association Analyses for Single Biallelic SNPs with Multiple Genetic Models: A SAS Macro with Simulated Data Examples[D]. Northeast Cancer Centre.<br>[22] Mohammad Shabbir Hasan, Xiaowei Wu, Layne T. Watson &amp; Liqing Zhang. UPS-indel: a Universal Positioning System for Indels[J]. nature, 2017.<br>[23] wikipedia. FASTA format[EB/OL]. <a href="https://en.wikipedia.org/wiki/FASTA_format" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/FASTA_format</a>, 2018.<br>[24] wikipedia. FASTQ format[EB/OL]. <a href="https://en.wikipedia.org/wiki/FASTQ_format" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/FASTQ_format</a>, 2018.<br>[25] Samy Ghoneimy, Samir Abou El-Seoud. A MapReduce Framework for DNA Sequencing Data Processing[D]. British University 2017.<br>[26] Apache. Apache FreeMarker™[EB/OL]. <a href="https://freemarker.apache.org/" target="_blank" rel="noopener">https://freemarker.apache.org/</a>, 2018.<br>[27] Mahmoud Parsian. 数据算法（Hadoop/Spark大数据处理技巧）[M]. 苏金国,杨健康等译. 清华大学出版社 第四版 2016.<br>[28] Tom White. Hadoop权威指南[M]. 王海,华东,刘喻,吕粤海译. 清华大学出版社 第四版 2017.<br>[29] Apache. Apache MRUNIT™[EB/OL]. <a href="http://mrunit.apache.org/" target="_blank" rel="noopener">http://mrunit.apache.org/</a>, 2018.<br>[30] The sratoolkit Toolkit [EB/OL]. <a href="https://github.com/ncbi/sra-tools/wiki/Downloads" target="_blank" rel="noopener">https://github.com/ncbi/sra-tools/wiki/Downloads</a>, 2018.</p>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>结  论</title>
      <link href="/blog/88854671.html"/>
      <url>/blog/88854671.html</url>
      
        <content type="html"><![CDATA[<p>在本次的论文中，主要对Hadoop大数据框架做了深入了解，并对生物信息学中基因测序领域有了一个全新的认识。在这次基于Hadoop的基因组测序大数据分析平台研究的课题中，构建了针对生物全基因组的测序流程，并将自己所学的大数据领域的知识与全基因组测序流程相结合，利用Hadoop特有的HDFS分布式存储系统的特性，来容错的存储样本数据，并通过MapReduce计算框架将原本串行分析的WGS流程构建成不同的Map任务和Reduce任务，达到对不同的样本流程进行并行分析，提高基因测序的时效性和高扩展性。</p><a id="more"></a><p>该平台的研发可以适配大部分的全基因组测序处理流程，对于不同物种的全基因组测序，我们只需修改WGS测序流程模板和参考基因组序列即可，其他模块如数据存储与访问模式是一样的，另外FreeMarker相关的模板转换为脚本流程也是通用的等等。</p><p>在本次基于Hadoop的基因组测序大数据分析平台研发中，不仅让我了解Hadoop大数据平台的组件和框架应用，也让我看到了基因测序与个性化医疗的前景所在，完成一个人的全基因组测序所花的时间将会越来越短，个性化医疗离我们的脚步也越来越近！</p>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5 系统的测试与扩展</title>
      <link href="/blog/c7060cce.html"/>
      <url>/blog/c7060cce.html</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-mrunit测试类编写">5.1 MRUnit测试类编写</h2><p><a href="http://mrunit.apache.org" target="_blank" rel="noopener">MRUnit</a>是一个MapReduce的测试库，它能将已知的输入通过函数的形式直接传递给Map()函数，然后该函数直接被调用运行，或者检查Reduce()函数的输出和测试的指定输出匹配，看是否符合预期输出。MRUnit与标准的测试执行框架（如：JUnit）一起使用<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，因此可以在正常的开发环境中运行MapReduce作业的测试。</p><a id="more"></a><h3 id="5-1-1-map任务的测试类编写与调度">5.1.1 Map任务的测试类编写与调度</h3><p>这里通过对Mapper函数传入一个样本名称，如SRR3226035，测试其程序是否调用流程分析脚本，并输出正常结果。</p><pre><code class="language-java">public class wgsMapperTest {    /*        测试Mapper     */    @Test    public void wgs() throws IOException {        Text value = new Text(“SRR3226035”);        new MapDriver&lt;LongWritable, Text, Text, Text&gt;()                .withMapper(new wgsMapper())                .withInput(new LongWritable(0), value)                .withOutput(new Text(“1”), value)                .runTest();}}</code></pre><h3 id="5-1-2-reduce任务的测试类编写与调度">5.1.2 Reduce任务的测试类编写与调度</h3><p>这里通过对Reducer函数传入多个样本名称，如SRR3226035，测试其程序是否调用shell脚本，整合多个gvcf变异文件，并整合为一个VCF文件。</p><pre><code class="language-java">public class wgsReducerTest {    /*        测试Reducer     */    @Test    public void merge() throws IOException {        Text value1 = new Text(&quot;SRR3226035&quot;);        Text value2 = new Text(&quot;SRR3226039&quot;);        Text value3 = new Text(&quot;SRR3226042&quot;);        new ReduceDriver&lt;Text, Text, Text, Text&gt;()                .withReducer(new wgsReducer())                .withInputKey(new Text(&quot;1&quot;))                .withInputValues(Arrays.asList(value1,value2,value3))                .withOutput(new Text(&quot;1&quot;), value3)                .runTest();    }}</code></pre><h2 id="5-2-hadoop测序平台的测试">5.2 Hadoop测序平台的测试</h2><p>人类的参考基因组数据文件很大，其序列长度大概在3GB，包含30亿个碱基信息。而一个人的高深度测序所需要准备的样本数据往往是这个数字的30倍多，大约达到100GB。如果直接用这样的数据来完成基因测序分析，会下载大量的数据以及花费大量的处理时间，而且对机器性能也要有很高的要求。</p><p>因此在保证WGS全基因组测序流程的的完整性和正确性的情况下，使用一种大肠杆菌E.coli K12的全基因组数据作为代替。这是美国国家生物技术信息中心的一个研究课题，主要是针对一种大肠杆菌的全基因组测序的实验项目。该E.coli K12生物的基因组比较单一，全基因组中仅包含NC_000913.3这一种染色体，数据量相比于人类来说算很小的，它的全基因组的文本数据总大小只有4.6Mb，非常适合用来测试基于Hadoop的全基因组测序分析平台。以后对人类基因组数据作分析时再作替换即可。</p><h3 id="5-2-1-测试环境与测试数据准备">5.2.1 测试环境与测试数据准备</h3><p>在测试环境的准备中，在上一章中着重介绍了Hadoop伪分布式的搭建和Hadoop分布式的搭建流程，由于机器的限制，就本次的测试选择Hadoop伪分布环境下进行，我可以在我自己学习用的笔记本上直接搭建好该环境，接着对测试样本数据进行下载和预处理。</p><p>1）处理E.coli K12的参考基因组序列<br>物种的基因组参考序列可以在NCBI上获取，下面是E.coli K12参考序列的<a href="ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz" target="_blank" rel="noopener">ftp地址</a>。为了接下来表达上的清晰和操作上的方便，通过bgzip将这个序列文件进行解压并重命名为E.coli_K12_MG1655.fa<br><code>$ gzip -dc GCF_000005845.2_ASM584v2_genomic.fna.gz &gt; E.coli_K12_MG1655.fa</code><br>接着，使用Samtools软件为参考文件建立索引，方便其他数据分析工具（比如GATK）能够快速地获取fasta上的任何位点的序列信息。<br><code>$ /home/elon/biosoft/samtools/1.0/bin/samtools faidx E.coli_K12_MG1655.fa</code></p><p>2）下载E.coli K12的测序数据<br>基因组参考序列准备好之后，我们还需要准备该物种的测序样本数据。这里使用一组科研的E.coli K12实验数据<a href="https://www.ncbi.nlm.nih.gov/biosample/SAMN04505064/" target="_blank" rel="noopener">E.coli K12测试数据 </a>，其作为一种供研究使用的模式生物，已经在NCBI上有许多的测序数据了。我这里选取某次科研组织的样本数据共9组，样本号序列分别为：SRR3226034、SRR3226035 … SRR3226042。</p><p>通过<a href="http://www.ebi.ac.uk/ena/data/view/SRR_number" target="_blank" rel="noopener">点击下载数据样本</a>，并把最后SRR_number替换成指定的样本号。这些样本数据来自Illumina MiSeq测序平台，read长度是300bp，测序类型Pair-End，说明样 本有R1和R2双端测序数据。</p><p>从NCBI上下载下来的测序数据是一种NCBI的特殊格式SRA，它具较高的压缩率。我们需要对下载下来的SRA数据进行转换，得到我们需要的FASTQ格式数据，需要用到NCBI的官方工具包sratoolkit<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，解压之后就可以使用了。</p><p>sratoolkit是一个工具包，所有的执行程序都在它解压后的bin文件夹下，我们要把SRA转换为fastq，只需直接通过工具包中的fastq-dump即可完成。<br><code>$ /home/elon/biosoft/sratoolkit/2.9.0/bin/fastq-dump --split-files SRR_number.sra</code></p><p>然后我们就会得到这个E.coli K12数据的read1和read2了：SRR_number_1.fastq和SRR_number_2.fastq。在得到R1和R2序列对之后，可以用bgzip命令将其压缩为.gz文件，这样可以节省空间，并且不会对接下来的数据分析产生影响。</p><pre><code>$ bgzip -f SRR_number_1.fastq$ bgzip -f SRR_number_2.fastq</code></pre><p>在得到gz格式的FASTQ样本数据之后，接下来就可以进行下面具体的测序分析流程了。</p><h3 id="5-2-2-系统平台的测试">5.2.2 系统平台的测试</h3><p>在本机的伪分布式的Hadoop环境中，用IDEA开发平台进行测试。首先通过以下指令运行Hadoop集群：<br><code>$ start-dfs.sh &amp;&amp; start-yarn.sh</code></p><p>编辑Mapper阶段的输入文本sample.txt，每行指定一个样本数据：</p><pre><code>SRR3226034SRR3226035SRR3226036SRR3226037SRR3226038SRR3226039SRR3226040SRR3226041SRR3226042</code></pre><p>接下来，需要通过以下命令将样本数据上传到HDFS上的指定文件夹：<br><code>$ hadoop fs -put sample.txt /wgsv2-input/</code></p><p>最后，调用wgsDriver驱动程序，这是整个项目的入口程序。从这里开始整个项目的MapReduce分析流程，并在指定文件夹中打印日志和脚本信息，最终得到VCF变异检测文件，并已上传到HDFS的指定位置。</p><p>对gVCF文件和VCF文件的解读在第二章的相关文件格式介绍中已经提及，其中的样本数据就是来自这一组测试数据得到的最终变异集合。</p><h2 id="5-3-测序平台的分析与优化">5.3 测序平台的分析与优化</h2><h3 id="5-3-1-测序平台与传统测序流程的比较">5.3.1 测序平台与传统测序流程的比较</h3><p>与传统的处理流程相比，对于这九组样本数据，在传统的分析流程中，需要手动编写九组测序的脚本，这个重复性的工作在FreeMarker的引入之后可以简化了。只需编写一套测序分析模板脚本，通过模版生成引擎，得到九组不同的测序分析脚本。</p><p><img src="https://i.imgur.com/LTjKPzf.png" alt="图5-1  Map阶段测序分析运行时间比对"></p><p>Map阶段测序分析运行时间比对如图5-1所示，横坐标表示的是用于测序的样本个数，纵坐标表示的是测序流程总的运行时间。在传统的测序分析是进行串行处理的方式，在处理单个样本对数据时，耗时大概12分钟左右，因此对于样本个数逐个递增的情况其总耗时时间呈线性递增；而对于分布式环境的Map任务执行，各个map任务在集群中是同时提交并行执行的，在每一种测序样本数处理情况中，以处理用时最长那一组的测序时间作为总运行时间。<br>因此由图5-1可知，随着样本数的增多，传统的测序方法的运行时间呈线性增加，而基于Hadoop的分布式测序所需要的时间基本保持不变。</p><p><img src="https://i.imgur.com/ACMv0sK.png" alt="图5-2  Reduce阶段测序分析运行时间比对"></p><p>Reduce阶段测序分析运行时间比对如图5-2所示，在Reducer规约阶段需要将上一步骤中各个样本产生的单个变异检测样本合并，而这里都是经由一个脚本程序处理，因此传统基因测序时间和分布式基因测序时间相近。</p><h3 id="5-3-2-增加测序流程处理的时间戳标记">5.3.2 增加测序流程处理的时间戳标记</h3><p>在每个分析流程执行的时候，在各个Shell命令中加入time命令，可以在日志中打印该流程所花费的时间。比如：程序执行的开始时间和程序执行的结束时间，一共花费了多少时间等，这样可以对分析流程中各个程序的执行时间和执行流程顺序更加了解。</p><h3 id="5-3-3-引入log4j日志框架">5.3.3 引入Log4j日志框架</h3><p>在整个项目中引入Log4j日志框架，将不同的日志类型的信息导向不同的文件中存储，便于项目的开发和调试。下面是我的log4j的配置文件：</p><pre><code class="language-shell">### Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。###log4j.rootLogger = stdout,D,E,I### 输出信息到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n### 输出DEBUG 级别以上的日志到 $PROJECT_HOME/wgsv2/wgs-logs/debug.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = ./wgs-logs/debug.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUGlog4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n### 输出ERROR 级别以上的日志到 $PROJECT_HOME/wgsv2/wgs-logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =./wgs-logs/error.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = ERRORlog4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n### 输出INFO 级别以上的日志到=$PROJECT_HOME/wgsv2/wgs-logs/TemplateEngine-info.log ###log4j.appender.I = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.I.File =./wgs-logs/info.loglog4j.appender.I.Append = truelog4j.appender.I.Threshold = INFOlog4j.appender.I.layout = org.apache.log4j.PatternLayoutlog4j.appender.I.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n</code></pre><p>从配置文件中可以看到，日志优先级共四种，优先级从高到低分别是ERROR、WARN、INFO、DEBUG，对于不同日志等级的日志文件进行分文件存储。这样对于后期的系统调试至关重要。</p><h2 id="5-4-基于hadoop基因测序平台的扩展">5.4 基于Hadoop基因测序平台的扩展</h2><p>在对不同物种进行基于Hadoop平台的全基因组测序流程开发时，只需对WGS处理模板进行重构，适配特定的物种即可，在本章的测试样本中，我使用的是大肠杆菌的K12生物来进行测序流程构建，而将其换作是其他生物的全基因组数据完全可以。下图是测序平台的扩展性示意图，由于每个样本的测序分析流程都是封装在Map任务和Reduce任务中的，因此可以同时并行化的开展对不同物种的测序流程，Hadoop大数据测序平台扩展如图5-3所示。</p><p><img src="https://i.imgur.com/A7ytgpS.png" alt="图5-3 Hadoop大数据测序平台扩展图"></p><p>在该Hadoop基因测序平台中，对于其他物种如人类，只需将人类的全基因组测序样本上传至HDFS分布式存储系统中，将人类的参考基因组数据在集群的各个主机上进行分布，再设计人类基因测序流程的模板文件即可适配该平台。因为各个Map任务和Reduce任务是独立存在，并隔离在不同的container中执行的，因此各个子任务之间互不干扰，达到完全并行化计算处理。<br>##5.5 本章小结<br>本章主要对搭建的基于Hadoop的WGS分析流程平台的一个测试，在保证WGS全基因组测序流程的的完整性和正确性的情况下，用 E.coli K12生物的数据作为代替，测试平台的可用性和健壮性等。对传统WGS分析流程与Hadoop大数据框架整合，从测序源到产生最终的变异结果gVCF和VCF文件的过程进行测试。<br>在这次测试中，通过观察运行过程的日志信息，发现尝试分析最耗时间的步骤基本聚集在比对和变异检测这两步中，最后对于测序平台的扩展性进行论述，说明其如何适配不同物种的基因测序流程，并进行并行化计算等。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Apache. Apache MRUNIT™[EB/OL]. <a href="http://mrunit.apache.org/" target="_blank" rel="noopener">http://mrunit.apache.org/</a>, 2018. <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>The sratoolkit Toolkit [EB/OL]. <a href="https://github.com/ncbi/sra-tools/wiki/Downloads" target="_blank" rel="noopener">https://github.com/ncbi/sra-tools/wiki/Downloads</a>, 2018. <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4 基于Hadoop的平台搭建与MapReduce作业设计</title>
      <link href="/blog/3fd0f93f.html"/>
      <url>/blog/3fd0f93f.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-基于hadoop的伪分布式平台搭建">4.1 基于Hadoop的伪分布式平台搭建</h2><p>在搭建Hadoop分布式系统平台<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>时，我们有两种方式可以选择，分别是伪分布的模式和完全分布式模式。这两种模式的主要区别在于前者是在本地一台机器中运行Hadoop框架中的各种服务，是一种模拟分布式的集群环境。而完全分布式的环境就是在真实的多个主机上配置Hadoop，并搭建整个集群环境。</p><a id="more"></a><h3 id="4-1-1-搭建hadoop伪分布式平台">4.1.1 搭建Hadoop伪分布式平台</h3><p>使用分布式的环境对全基因组测序的环境进行搭建，下面介绍整个分布式环境的搭建流程。<br><img src="https://i.imgur.com/kBOP38U.png" alt="图4-1 Hadoop伪分布式集群架构图"></p><p>1）安装并检查Java版本<br>必须确保Hadoop集群安装的是合适版本的Java。可以通过Hadoop wiki界面<a href="http://wiki.apache.org/hsdoop/HadoopJavaVersions" target="_blank" rel="noopener">Hadoop wiki界面</a>来查看具。通过键入以下命令，查看本机的java版本信息：</p><pre><code>elon@longsl:~$ java -versionjava version &quot;1.8.0_161&quot;Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</code></pre><p>2）创建Unix用户账号<br>最好创建特定的Unix用户账号以区分各Hadoop进程，及区分同一机器上的其他服务。在我的主机上，我创建一个名叫elon的用户名来执行Hadoop程序。</p><p>3）安装Hadoop<br>从<a href="http://hadoop.apache.org/common/realease.html" target="_blank" rel="noopener">Apache Hadoop发布页</a>下载一个稳定版的二进制发布版本包（通常打包为一个tar.gz结尾的文件），再解压缩到本地文件系统。在我的主机上执行以下命令即可：<br><code>elon@longsl:~$ tar -zxvf hadoop-2.7.6.tar.gz -C .</code></p><p>4）SSH配置<br>SSH免密码登录的原理是首先在主机A的本地生成公钥和私钥，然后将本机的公钥发送到要免密登录的主机上，然后在访问目的主机时，本机的私钥和目的主机中的公钥配对成功，即可以免密登录。<br>在本次伪分布式环境中，只需配置本机用户自己和自己免密登陆以及自己和localhost用户免密登陆即可。我本机的主机名为longsl，因此我需要为longsl用户生成公私密钥对:</p><pre><code class="language-shell">elon@longsl:~$ ssh-keygen -t rsa# 并且配置ssh longsl和ssh localhost能免密登陆:elon@longsl:~$ ssh-copy-id longslelon@longsl:~$ ssh-copy-id localhost</code></pre><p>5）配置Hadoop<br>Hadoop集群的配置文件在$HADOOP_HOME/etc/hadoop目录下，主要修改五个配置文件，分别是slaves、core-site.xml、hdfs-site.xml、mapred-site.xml和yarn-site.xml。<br>修改slaves文件，这个文件表明该集群中的子节点的主机名，在伪分布式环境中，直接将localhost添加进去即可。<br>配置core-site.xml，主要设置NameNode运行的主机信息。</p><pre><code class="language-xml">&lt;configuration&gt;    &lt;property&gt;&lt;name&gt;fs.defaultFS&lt;/name&gt;&lt;value&gt;hdfs://longsl:8080/&lt;/value&gt;    &lt;/property&gt;&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&lt;value&gt;/home/elon/hadoop/tmp&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;&lt;!-- 配置hdfs-site.xml，需要设置的dfs.replication的参数，主要用于设置集群中副本的个数，由于这个是伪分布模式，因此副本数设置为1即可。 --&gt;&lt;configuration&gt;    &lt;property&gt;&lt;name&gt;dfs.replication&lt;/name&gt;&lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>配置mapred-site.xml，首先设置了日志聚合相关的参数配置，我们可以理解为将集群环境中原本存储于系统tmp目录下的作业运行日志作了归档处理，并存储在了HDFS上。接下来，对集群中在各个容器中作业的运行环境做了相应的配置，具体是设置了每个作业在map阶段和reduce阶段能够被分配的最大运行内存，另外设置了其可以使用的java虚拟机的最大内存资源数。最后对map阶段和reduce阶段能够被使用的CPU核数做了相应配置。</p><pre><code class="language-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;    &lt;/property&gt;&lt;!-- log aggreation --&gt;&lt;property&gt;&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;&lt;value&gt;localhost:10020&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;&lt;value&gt;localhost:19888&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.jobhistory.intermediate-done-dir&lt;/name&gt;&lt;value&gt;/mr-history/done_intermediate&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.jobhistory.done-dir&lt;/name&gt;&lt;value&gt;/mr-history/done&lt;/value&gt;&lt;/property&gt;&lt;!-- configure RAM for a Container --&gt;&lt;property&gt;&lt;name&gt;mapreduce.map.memory.mb&lt;/name&gt;&lt;value&gt;2048&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.reduce.memory.mb&lt;/name&gt;&lt;value&gt;2048&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.map.java.opts&lt;/name&gt;&lt;value&gt;-Xmx1024m&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.reduce.java.opts&lt;/name&gt;&lt;value&gt;-Xmx1024m&lt;/value&gt;&lt;/property&gt;&lt;!-- configure cpu core on map and reduce --&gt;&lt;property&gt;&lt;name&gt;mapreduce.map.cpu.vcores&lt;/name&gt;&lt;value&gt;4&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.reduce.cpu.vcores&lt;/name&gt;&lt;value&gt;4&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>配置yarn-site.xml，主要需配置RM运行的主机，在伪分布式环境中就是指本地主机，另外NM节点上运行的服务是mapreduce_shuffle，这个选项是必须配置的，因为我们需要处理的就是mapreduce程序。最后开启了yarn上的日志聚合功能，并将各个容器上产生的日志存储在HDFS上。</p><pre><code class="language-xml">&lt;configuration&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;&lt;value&gt;longsl&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;!-- log aggreation --&gt;&lt;property&gt;&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt;&lt;value&gt;/user/container/logs&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>6）环境设置<br>需要设置Hadoop系统的Java安装的位置，通过在etc/hadoop/hadoop-env.sh文件中设置JAVA_HOME项。<br><code>export JAVA_HOME=/opt/jdk1.8</code></p><p>7）格式化HDFS文件系统<br>在能够使用之前，全新的HDFS安装需要进行格式化。通过创建存储目录和初始版本的namenode持久数据结构，格式化进程将创建一个空的文件系统。格式化HDFS是一个快速操作，以hdfs用户身份运行命令：hadoop namenode -format</p><h3 id="4-1-2-启动和停止hadoop集群">4.1.2 启动和停止Hadoop集群</h3><p>Hadoop自带脚本，可以运行脚本命令，启动或者停止如hdfs、yarn或者日志聚合等服务进程。为了使用这些脚本，需要告诉Hadoop集群中有哪些机器。文件slaves用于此目的，该文件包含了机器主机名或IP地址的列表，每行代表一个机器信息。文件slaves列举了可以运行datanode和节点管理器的机器。</p><p>1）启动HDFS守护进程<br><a href="http://xn--elonstart-dfs-lm3uka20b011ffp0dkh7dc9zdt71ahjf.sh" target="_blank" rel="noopener">以elon用户身份运行命令start-dfs.sh</a>，可以启动HDFS守护进程。默认情况下，该命令从core-site.xml配置项fs.defaultFS中找到namenode的主机名。更具体一些，start-dfs.sh脚本所做的事情如下：<br>1)在每台机器上启动一个namenode。<br>2)在slaves文件列举的每台机器上启动一个datanode<br>3)在每台机器上启动一个辅助namenode。</p><p>2）启动YARN守护进程<br>YARN守护进程以相同的方式启动，通过以yarn用户身份在托管资源管理器的机器上运行命令：<a href="http://start-yarn.sh" target="_blank" rel="noopener">start-yarn.sh</a>。默认情况下，资源管理器总是和start-yarn.sh脚本运行在同一机器上。脚本明确完成以下事情。<br>1)在本地机器上启动一个资源管理器。<br>2)在slaves文件列举的每台机器上启动一个节点管理器。</p><p>同样，还提供了stop-dfs.sh和stop-yarn.sh脚本用于停止由相应的启动脚本启动的守护进程。下面是在我的集群环境中开启集群环境的实例：</p><pre><code>elon@longsl:~$ start-dfs.sh &amp;&amp; start-yarn.shStarting namenodes on [longsl]longsl: starting namenode, logging to /home/elon/hadoop/logs/hadoop-elon-namenode-longsl.outlocalhost: starting datanode, logging to /home/elon/hadoop/logs/hadoop-elon-datanode-longsl.outStarting secondary namenodes [0.0.0.0]0.0.0.0: starting secondarynamenode, logging to /home/elon/hadoop/logs/hadoop-elon-secondarynamenode-longsl.outstarting yarn daemonsstarting resourcemanager, logging to /home/elon/hadoop/logs/yarn-elon-resourcemanager-longsl.outlocalhost: starting nodemanager, logging to /home/elon/hadoop/logs/yarn-elon-nodemanager-longsl.out</code></pre><h2 id="4-2-伪分布式环境的mapreduce作业构建">4.2 伪分布式环境的MapReduce作业构建</h2><p><img src="https://i.imgur.com/NvL3uNw.png" alt="图4-2 伪分布式的MapReduce任务流程"></p><p>伪分布式的MapReduce任务执行图如图4-2所示，MapReduce框架中共分为Mapper阶段和Reducer阶段，本节会主要研究Mapper和Reducer的流程构造。在伪分布式环境中，Map任务和Reduce任务是串行执行下去的，其中先执行完所有Map任务再执行Reduce任务，另外Map任务和Reduce任务都会在本地执行器中执行。</p><h3 id="4-2-1-mapper流程构造">4.2.1 Mapper流程构造</h3><p>在Mapper阶段中，重点关注单样本的基因测序流程，从而得到变异检测的中间gVCF文件，基因测序Mapper阶段的流程如图4-3所示。</p><p><img src="https://i.imgur.com/BRr8fqM.png" alt="图4-3 基因测序Mapper阶段的流程图"></p><p>在上图中，主要是对Mapper阶段从输入sample.txt文本文件开始，一直到输出端得到output输出文件并把得到的gVCF文件上传到HDFS上的展示。其中在输入的文本文件中保存的是本次测序中样本组中各样本的名称信息，作为测序对象传入模版文件中，在模版引擎的调用下生成测序可执行脚本，然后在Shell脚本执行引擎中调用该脚本，以脚本命令的模式执行基因测序分析流程。<br>在脚本执行过程中，需要访问HDFS系统，获取该测序样本的数据文件，最后生成gVCF文件并上传至HDFS上存储。另外对于Mapper的输入端的输出文本，设计是将key设置为同一个，这样在reduce程序调用时，可以在同一个reduce程序中读取到，这样样本就可以在同一个测序分析流程中被调用，形成最终的VCF文件。</p><h3 id="4-2-2-reducer流程构造">4.2.2 Reducer流程构造</h3><p>在Reduer阶段，主要侧重的是基因测序的单样本变异检测结果的合并，得到最终的VCF文件的过程，基因测序Reduce阶段流程图如图4-4所示。</p><p>在该阶段的分析流程中，主要是将上一步Mapper产生的输出文件作为此阶段的输入文件，而reduce程序对于键相同的元素和经过shuffle混洗之后在同一个reduce对象中处理，这样就可以将这一组样本生成的gVCF文件统一传递到reduce程序的shell分析流程脚本中处理，再调用FreeMarker模板引擎来生成合并gVCF文件的脚本文件，最后调用shell脚本执行引擎来调用该脚本文件，得到该组样本统一的变异检测文件。</p><p><img src="https://i.imgur.com/Oa91nGQ.png" alt="图4-4 基因测序Reduce阶段流程图"></p><p>同样，在最后需要将得到的VCF文件上传至HDFS上存储并同意管理，这样就完成了基因测序的完整流程，从单个样本的测序分析得到变异位点信息，到最后合并各个样本的变异位点信息得到最终能反映该生物物种的全基因组变异位点信息集合。<br>##4.3 基于Hadoop分布式环境搭建<br>在对Hadoop平台的分布式环境的搭建过程，其中的Java环境配置、用户创建、Hadoop二进制包的安装等步骤都和伪分布式的搭建方式一致，主要的不同之处在于其对Hadoop配置文件的配置不同。<br>###4.3.1 Hadoop分布式架构<br>在我的Hadoop分布式环境配置中，我利用了三台虚拟机来模拟真实主机，三台主机的主机名分别是node1、node2和node3，其中一台作为Master主机，另外两台作为slaves从节点。<br>Hadoop完全分布式架构图如图4-5所示，在该图中，主要通过配置集群中各个机器的Java环境变量和SSH免密登录，并在各个机器上配置Hadoop可执行包和修改Hadoop配置文件，搭建Hadoop分布式集群环境。</p><p><img src="https://i.imgur.com/aLtO039.png" alt="图4-5 Hadoop完全分布式架构图"></p><h3 id="4-3-2-hadoop完全分布式配置">4.3.2 Hadoop完全分布式配置</h3><p>首先在node1上进行下面各项的配置，最后再将各个配置项同步复制到node2和node3节点上。</p><pre><code>scp /home/node1/hadoop/etc/hadoop/ root@node2:/home/node2/hadoop/etc/Hadoopscp /home/node1/hadoop/etc/hadoop/ root@node3:/home/node2/hadoop/etc/hadoop</code></pre><p>(1) 配置slaves文件<br>$HADOOP_HOME/etc/Hadoop/slaves文件是用来配置Hadoop集群中的从节点的主机，将集群中所有的从节点都在slaves中进行记录，通常这些从节点就是承担计算任务的节点。在我的完全分布式环境中，我配置了两个从节点，一个主节点。因此需将从节点的主机名node2和node3写入slaves文件中。进行如下配置：</p><pre><code>node2node3</code></pre><p>(2) 配置core-site.xml文件<br>在对core-site.xml文件进行配置时，指定node1为Master主节点，因此NameNode服务就指定在node1主机上。进行如下配置：</p><pre><code class="language-xml">&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://node1:8080&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&lt;value&gt;/root/hadoop/tmp&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>(3) 配置hdfs-site.xml文件<br>在对hdfs-site.xml文件进行配置时，主要和伪分布式不同的地方在于可以指定多个副本数了，其副本数的多少代表这个文件系统的可靠程度，副本数越高越可靠，但为了兼顾存储资源和高可靠性也不能设置太高，官方默认的副本数是3。另外我们可以对namenode和datanode的存储地址进行自定义，最后指定NameNode的辅助进程的运行主机。具体配置如下：</p><pre><code class="language-xml">&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;dfs.replication&lt;/name&gt;    &lt;value&gt;3&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;    &lt;value&gt;/root/hadoop/tmp/name&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;    &lt;value&gt;/root/hadoop/tmp/data&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;        &lt;value&gt;node1:8081&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>(4) 配置mapred-site.xml文件<br>在mapred-site.xml文件中，主要是与MapReduce任务的相关配置。其中要配置MapReduce使用的资源调度框架，这里默认是yarn。另外还要对map任务和reduce任务执行时的可用资源和java虚拟机的资源进行配置。具体配置如下：</p><pre><code class="language-xml">&lt;configuration&gt;&lt;property&gt;&lt;name&gt;mapreduce.framework.name&lt;/name&gt;&lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.map.memory.mb&lt;/name&gt;&lt;value&gt;1600&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.reduce.memory.mb&lt;/name&gt;&lt;value&gt;1600&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;mapreduce.map.java.opts&lt;/name&gt;&lt;value&gt;-Xmx1300m&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;mapreduce.reduce.java.opts&lt;/name&gt;&lt;value&gt;-Xmx1300m&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>(5) 配置yarn-site.xml文件<br>在yarn-site.xml文件中，可以对resourcemanager运行的主机进行指定，这里我将其放在Master节点node1上运行，用于对集群中的作业进行任务调度和资源分配。由于我所创建的三个虚拟机上在我的单个真实主机上的，因此可用资源是非常紧张的，这要求我不同直接使用默认配置，而必须对yarn上的资源进行更为细致化的重新分配。</p><p>首先需要用户配置每个节点上可用的物理内存资源和CPU核数，因为一个node计算节点除了跑相关作业外，还可能运行着其他应用和服务等。下一步需要对yarn中可调度的单个容器资源进行配置，如配置调度的最小分配内存和最大分配内存，其中最小分配内存决定着该节点上最多可部署的容器个数，可通过yarn可用的物理内存除以每个容器最小可分配的内存来得到容器个数，同理CPU核数也是这样来指定。</p><p>接着还需要定义每个Map和Reduce任务需要的最大内存量。由于每个Map和每个Reduce都将在单独的Container中运行，因此这些最大内存设置应至少等于或大于YARN最小Container容量分配。最后，每个Map和Reduce任务的虚拟内存（物理+分页内存）上限由每个允许YARN容器的虚拟内存比决定，默认值为2.1。具体的配置细节如下：</p><pre><code class="language-xml">&lt;configuration&gt;&lt;property&gt;&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;node1&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;&lt;value&gt;2500&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.nodemanager.resource.vcores&lt;/name&gt;        &lt;value&gt;4&lt;/value&gt;    &lt;/property&gt;&lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt; &lt;value&gt;2000&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;&lt;value&gt;2500&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.scheduler.minimum-allocation-vcores&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;property&gt;        &lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;/name&gt;        &lt;value&gt;4&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.scheduler.increment-allocation-mb&lt;/name&gt;        &lt;value&gt;100&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.scheduler.increment-allocation-vcores&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.app.mapreduce.am.resource.mb&lt;/name&gt;        &lt;value&gt;300&lt;/value&gt;    &lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;&lt;value&gt;4&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>(6) SSH免密登陆配置<br>在配置SSH免密登陆时，主要对针对Master能免密登陆到各个slave节点上，保证NameNode和ResourceManager服务能在集群的各个节点上进行便携访问。在我的分布式环境中，由于NN和RM都是运行在主节点node1上，因此我需要配置node1到node2和node3的免密登陆。具体操作：在node1上使用命令“ssh-keygen –t rsa”生成node1的密钥对，并将node1的公钥分别发送到node2和node3的~/.ssh/authorized文件中，即可实现SSH免密登陆。</p><h3 id="4-3-3-启动和停止hadoop集群">4.3.3 启动和停止Hadoop集群</h3><p>完全分布式和伪分布式一样，<a href="http://xn--start-dfs-zo31ac0a.sh" target="_blank" rel="noopener">通过start-dfs.sh</a>、<a href="http://start-yarn.xn--shstop-dfs-ih7q.sh" target="_blank" rel="noopener">start-yarn.sh和stop-dfs.sh</a>、stop-yarn.sh脚本，启动或者停止如hdfs、yarn或者日志聚合等服务进程。下面是在我的完全分布式集群中的启动实例：</p><pre><code class="language-shell">root@node1:~# start-dfs.sh &amp;&amp; start-yarn.shStarting namenodes on [node1]node1: starting namenode, logging to /root/hadoop/logs/hadoop-root-namenode-node1.outnode2: starting datanode, logging to /root/hadoop/logs/hadoop-root-datanode-node2.outnode3: starting datanode, logging to /root/hadoop/logs/hadoop-root-datanode-node3.outnode1: starting datanode, logging to /root/hadoop/logs/hadoop-root-datanode-node1.outStarting secondary namenodes [node1]node1: starting secondarynamenode, logging to /root/hadoop/logs/hadoop-root-secondarynamenode-node1.outstarting yarn daemonsstarting resourcemanager, logging to /root/hadoop/logs/yarn-root-resourcemanager-node1.outnode3: starting nodemanager, logging to /root/hadoop/logs/yarn-root-nodemanager-node3.outnode2: starting nodemanager, logging to /root/hadoop/logs/yarn-root-nodemanager-node2.outnode1: starting nodemanager, logging to /root/hadoop/logs/yarn-root-nodemanager-node1.out</code></pre><p>从上面打印的信息可以看出，NameNode是运行在node1主节点上的，在集群中的三个节点都作为计算节点运行这DataNode进程和NodeManager进程。</p><h2 id="4-4-分布式环境下mapreduce作业构建">4.4 分布式环境下MapReduce作业构建</h2><p><img src="https://i.imgur.com/SdyGul2.png" alt="图4-6 分布式环境下的MapReduce的流程"></p><p>在分布式环境中，与伪分布式不同的地方在于，多个slave节点可以提供多个container容器供MapReduce任务来运行，分布式环境下的MapReduce的流程构造如图4-6所示。</p><p>从图中可以看出，在完全分布式环境中总共有多个计算节点，其中包含多个container容器，而我们提交的Map作业和Reduce作业就是在多个容器中分别进行运算，最后再将Map作业运行的结果通过一个Reduce作业进行规约计算。整个MapReduce运行流程，由原来的伪分布式中串行运算Map作业和Reduce作业，到现在分布式环境中并行运算Map作业，最后将Map的中间结果用一个Reduce作业来处理。</p><h2 id="4-5-shell脚本执行引擎的构建">4.5 Shell脚本执行引擎的构建</h2><p>在得到最终的执行脚本后，还需要通过特定的方法来调用执行该脚本文件。通过编写ShellScriptUtil工具类，执行指定的脚本并打印执行过程中出现的日志，并存放在指定的路径下，下面是shell脚本执行工具类的代码：</p><pre><code class="language-java">/** * shell脚本工具包* 用于将一个指定的可执行脚本进行执行的Java程序*/public class ShellScriptUtil {    // 日志记录    private static Logger theLogger = Logger.getLogger(TemplateEngine.class.getName());    /**     * 调用Shell脚本执行的方法     * @param paths 指定多个路径参数     *              第一个指定的是shell模版     *              第二个参数指定的是脚本执行结果存放路径     *              第三个参数指定的是执行脚本中日志存放路径，是可选参数，未给出此参数则默认为无日志输出     */    public static void callProcess(String... paths) {        File outputFile;        File logFile;        Process process;        String scriptPath = paths[0];        String chmod = &quot;chmod u+x &quot; + scriptPath;        try {            // 为shell脚本增加可执行权限            Runtime.getRuntime().exec(chmod).waitFor();        } catch (Exception e) {            e.printStackTrace();        }        System.out.println(&quot;执行脚本：&quot; + scriptPath);        ProcessBuilder pb = new ProcessBuilder(&quot;./&quot; + scriptPath);        pb.inheritIO();        // 指定shell脚本执行的结果输出路径和执行时日志文件的输出路径        if (paths.length == 3) {            outputFile = new File(paths[1]);            pb.redirectOutput(outputFile);            logFile = new File(paths[2]);            pb.redirectError(logFile);        }        // 指定shell脚本执行的日志输出路径        if (paths.length == 2) {            logFile = new File(paths[1]);            if (logFile.exists()) {                logFile.delete();            }            pb.redirectError(logFile);        }        try {            process = pb.start();            process.waitFor();        } catch (IOException e) {            theLogger.error(&quot;发生I/O错误...&quot;);        } catch (InterruptedException e) {            theLogger.error(&quot;当前线程在等待时被另一个线程中断...&quot;);        }    }}</code></pre><h2 id="4-6-mapreduce作业编写与整体调度">4.6 MapReduce作业编写与整体调度</h2><p>在MapReduce计算框架中，通过Mapper和Reducer来整体调度整个WGS分析流程，这里需要自定义map()函数和reduce()函数。其中map()函数是用来传入要分析的样本名称，并通过样本名称对不同的样本分多个map任务来并行执行，从而调用模板类，并执行最终的WGS分析脚本。下面是wgsMapper类的代码：</p><pre><code class="language-java">/*    编写全基因组测序的Mapper类 */public class wgsMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt; {    private static String LOG_DIRECTORY = &quot;./wgs-logs&quot;;    private static String SCRIPT_DIRECTORY = &quot;./wgs-scripts&quot;;    @Override    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {        String sample_name = value.toString();        wgs(sample_name);        context.write(new Text(&quot;1&quot;),new Text(sample_name));    }    private static void wgs(String sampleName) {        HashMap&lt;String, String&gt; templateMap = new HashMap&lt;&gt;();        templateMap.put(&quot;sample_name&quot;, sampleName);        String template = &quot;wgsMapper.template&quot;;        String scriptPath = SCRIPT_DIRECTORY + &quot;/wgs_mapper_&quot; + templateMap.get(&quot;sample_name&quot;) + &quot;.sh&quot;;        String logPath = LOG_DIRECTORY + &quot;/wgs_mapper_&quot; + templateMap.get(&quot;sample_name&quot;) + &quot;.log&quot;;        // 从模板创建具体脚本        File scriptFile = TemplateEngine.createDynamicContentAsFile(template, templateMap, scriptPath);        if (scriptFile != null) {            ShellScriptUtil.callProcess(scriptPath, logPath);        }    }}</code></pre><p>而在reduce()函数中，通过传递的样本名称到Reducer脚本模版中，对指定的gvcf文件作合并处理，从而得到最终的VCF文件。下面是wgsReducer类的代码：</p><pre><code class="language-java">/*    编写全基因组测序的Reducer类 */public class wgsReducer extends Reducer&lt;Text, Text, Text, Text&gt; {    private static String LOG_DIRECTORY = &quot;./wgs-logs&quot;;    private static String SCRIPT_DIRECTORY = &quot;./wgs-scripts&quot;;    @Override    protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException {        HashMap&lt;String, String&gt; templateMap = new HashMap&lt;&gt;();        Iterator&lt;Text&gt; value = values.iterator();        int count = 0;        String str = &quot;&quot;;        while (value.hasNext()) {            str = value.next().toString();            templateMap.put(&quot;sample_name&quot; + (++count), str);        }        mergeGVCF(templateMap);        context.write(new Text(&quot;1&quot;), new Text(str));    }    private static void mergeGVCF(HashMap&lt;String, String&gt; templateMap) {        String template = &quot;wgsReducer.template&quot;;        String scriptPath = SCRIPT_DIRECTORY + &quot;/wgs_reducer_&quot; + &quot;.sh&quot;;        String logPath = LOG_DIRECTORY + &quot;/wgs_reducer_&quot; + &quot;.log&quot;;        // 从模板创建具体脚本        File scriptFile = TemplateEngine.createDynamicContentAsFile(template, templateMap, scriptPath);        if (scriptFile != null) {            ShellScriptUtil.callProcess(scriptPath, logPath);        }    }}</code></pre><h2 id="4-7-本章小结">4.7 本章小结</h2><p>在本章中，主要介绍了Hadoop伪分布式环境及分布式环境进行搭建，还对WGS分析流程与MapReduce计算框架如何结合起来，其中就涉及到如何分多个map任务并行执行分析流程，对于WGS测序过程在linux环境中运行的情况，引入FreeMarker第三方库，通过编写脚本模板，并结合map和reduce作业，使得不同的map或者reduce任务在执行过程中，以不同的样本数据来执行不同的WGS脚本，达到高效并行化的全基因组测序的目的，最后再通过调用Driver驱动类执行整个MapReduce程序。</p><p>下一章主要对构建的测序平台做一个多样本数据的测试，并进行优化和系统扩展。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Tom White. Hadoop权威指南[M]. 王海,华东,刘喻,吕粤海译. 清华大学出版社 第四版 2017. <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3 基于Hadoop基因测序数据处理关键技术的研究</title>
      <link href="/blog/34f6c0b5.html"/>
      <url>/blog/34f6c0b5.html</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-测序处理流程与mapreduce结合">3.1 测序处理流程与MapReduce结合</h2><p>基因测序处理流程中有gVCF和VCF文件生成两个阶段，而MapReduce恰好是一种分阶段处理的编程模型，它拥有Mapper和Reducer两个处理阶段，因此将MapReduce框架和测序流程结合在一起，既能保证测序流程的有序进行，又能在MapReduce框架中进行并行调度，提升测序数据处理的效率。</p><h3 id="3-1-1-测序流程与mapreduce结合的可行性分析">3.1.1 测序流程与MapReduce结合的可行性分析</h3><p>MapReduce是一种可用于数据处理的编程模型，可以将数据分析处理流程分为映射阶段和归约阶段<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。在映射阶段，各个Map程序在不同的Container中运行彼此互不干扰，即各个Mapper阶段的程序本质上是并行运行的；而到了Reducer规约阶段，将各个Mapper阶段产生的中间结果做规约整合得到最终的处理结果。因此可以将大规模的数据分析任务分发给任何一个拥有足够多机器的数据中心，也正是因为其强劲的数据分析和并行处理能力，所以选择其和测序处理流程作整合。</p><a id="more"></a><p>在原本传统的基因测序流程中，是将多个样本放在一台高性能服务器中，通过编写的测序分析脚本串行处理每一个样本数据，最终得到变异检测的结果。虽然这个过程能得到最终的结果，但需要配置高性能服务器，而且往往需要耗费大量的处理时间，这其中大部分时间花在测序比对上面。后期要想提升测序效率的话，需要进一步配置性能更高的服务器，这样一个高时间花费和昂贵开销，不利于基因测序的低成本普及和个性化医疗的推广应用。</p><p>因此，我们需要一种高效并行的处理平台，达到使原本串行处理多个样本的测序过程，能够以一个样本为测序处理单位细分为多个Map任务达到并行处理分析，再通过Reduce任务的到最终的结果。</p><h3 id="3-1-2-测序流程与mapreduce框架的结合">3.1.2 测序流程与MapReduce框架的结合</h3><p>要想将测序处理流程与MapReduce框架结合，首先要将对多个样本的测序切分为多个Map任务，在运行MapReduce任务的时候，将基因测序的各个流程封装在shell脚本中，而这个shell脚本是以脚本模版的形式呈现。另一方面，主要的测序分析流程是固定的，而只有分析样本对象的信息是动态传入的。这样可以通过编写一个特定的Map程序，再通过调用MapReduce驱动程序来运行作业，对于传入的不同样本名生成不同的Map任务，即各个基因测序脚本，达到基因测序的并行化处理。</p><p>在得到以样本为单位的单变异检测的文件后，通过一个Reduce任务合并所有的gVCF变异文件，从而得到最总对于整个样本数据的变异检测VCF文件。</p><p>一个集群中有三台机器，总共有九个样本数据，那么可以并行三次可以分析完所有的数据，但是若是通过传统的流程分析过程的话，需要串行分析九次才能完成整体的测序处理流程。因此，通过流程处理逻辑的MapReduce化，可以成倍的提升样本测序的处理效率，使基因测序更加高效。</p><h2 id="3-2-不同格式数据的访问与存储">3.2 不同格式数据的访问与存储</h2><h3 id="3-2-1-数据访问于存储面临的问题">3.2.1 数据访问于存储面临的问题</h3><p>在进行MapReduce处理程序时，通过shell脚本的方式处理数据，由于不同样本的处理流程需要拉取不同的数据源，并且输出的中间结果也是不同的。这个时候，我们需要一个统一的数据存储和访问规则来统一管理这些数据源以及中间结果等。<br>###3.2.2 数据的存储与访问分析<br>首先，对于参考序列这一部分数据源，因为其涉及的处理流程比较固定，可以事先在机器的本地环境先搭建好。而MapReuce程序是在集群中的不同机器上运行的，因此数据是在MapReduce程序中动态获取的，我们需要事先上传到HDFS上，这也是MapReduce计算框架常用来获取数据源的方式，其他方式还包括通过访问Amason S3等。</p><p>将所有的样本数据存储在HDFS上之后，通过在Map程序的输入数据中指定样本名称和存储的位置信息，可以轻松访问到指定的样本数据，从而实现不同的Map程序访问并处理不同的样本数据。而对于中间其他剩余几个测序流程，如排序、标记重复、创建索引以及变异检测这几步，上一步的结果是下一步处理流程的输入数据，这些处理流程所得到的中间数据都可以本地化存储，既能节省网络传输的开销，也能最大程度保证数据的完整性，不会由于网络中断导致数据不完整存储。</p><p>在所有的样本并行化处理完成之后，每个Map程序最终得到的是该样本数据的gVCF变异检测文件，对每个样本变异检测数据作一个合并得到最终VCF格式文件，这时需要用到Reduce归约操作，因此需要对Map程序最终得到的结果再上传到HDFS上，供接下来的Reduce程序使用。<br>而最终得到的VCF文件，也是需要上传到HDFS上存储，保证结果文件的容错性和完整性。</p><h2 id="3-3-分析流程的完整性">3.3 分析流程的完整性</h2><h3 id="3-3-1-分析流程面临的问题">3.3.1 分析流程面临的问题</h3><p>WGS分析处理流程中主要的问题是如何判定并以一个样本数据作为切分标准，对整体的多样本数据以样本为单位进行切分处理。因为只有以单样本为数据测序分析的单位，才能既保证数据处理流程完整性的同时，又能最大程度上保证并行化处理，从而提升整体的测序效率。</p><p>理论上对于不同样本的分析流程其实都是一样的，因此需要引入一套流程分析机制，保证分析流程的统一性，便于分析流程的统一操作和中间结果管理。</p><h3 id="3-3-2-整体流程设计分析">3.3.2 整体流程设计分析</h3><p>在MapReduce框架中，其Mapper阶段和Reducer阶段的输入文件都是文本格式的文件，在我的整体流程搭建中，将测序的样本文件存于HDFS上，map和reduce的输入文件只是保存样本文件的列表，达到能够将不同的样本处理流程进行隔离和分批处理的目的。</p><p>具体是在Map任务的输入数据文本中，每一行指定一对R1和R2样本数据名称，在驱动程序中设置输入文件中的每一行数据用一个Mapper来处理，这样能够将每一个样本数据处理分到不同的Map任务中执行，从而达到流程设计的完整性以及流程处理的并行化。</p><p>考虑到基因测序的分析流程，像完成比对、重复标记和变异检测的大多数开源工具（如BWA、SAMtools和GATK）都提供了Linux命令行界面，所有各个MapReduce阶段中的map()和Reduce()函数将调用Linux Shell脚本，并提供适当的参数。要执行这些shell脚本，将使用FreeMarker模版语言。</p><h2 id="3-4-freemarker引擎与测序流程的模版化">3.4 FreeMarker引擎与测序流程的模版化</h2><p>Apache FreeMarker<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>是一种模板引擎，目前是Apache基金会的一个孵化项目，模板是用FreeMarker模板语言（FTL）编写的，它是一种简单的专用语言。通常，使用通用编程语言（如Java）来准备数据（发布数据库查询，进行业务计算）。然后，FreeMarker使用模板显示准备好的数据。</p><p>在我们基因测序流程搭建中，先编写shell分析流程的脚本模板，其中分析对象用参数代替，再通过FreeMarker API将参数传入分析流程模版中，得到最终可执行的shell脚本文件。FreeMarker模版引擎如图3-1所示。</p><p><img src="https://i.imgur.com/p3Ki9jT.png" alt="图3-1 FreeMarker模版引擎"></p><h3 id="3-4-1-构建freemarker模版引擎">3.4.1 构建FreeMarker模版引擎</h3><p>在我们最终的处理流程中，通过FreeMarker模版引擎类把脚本模版转换为可执行的shell脚本后，最终通过调用shell脚本工具类执行该脚本<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。在本节中，会分别对这两个工具类作出说明。</p><p>其中模版引擎类需要引入org.freemarker包来调用FreeMarker API方法，其中最主要的方法是createDynamicContentAsFile，它需要传入一个模版文件、一个存储着键值对的map对象和最终生成的shell脚本文件路径，通过map传入的对象信息映射到模版中，生成最终的WGS测序流程的分析脚本。下面是具体的模版引擎类方法：</p><pre><code class="language-java">/** * 这个类使用FreeMarker(http://freemarker.apache.org) FreeMarker是一个模板引擎，这是一个根据模板生成文本输出的通用工具 * (从shell脚本到自动生成的源代码都是文本输出) */public class TemplateEngine {    // 日志记录    private static Logger theLogger = Logger.getLogger(TemplateEngine.class.getName());    // 通常在整个应用生命周期中只执行一次    private static Configuration TEMPLATE_CONFIGURATION = null;    private static AtomicBoolean initialized = new AtomicBoolean(false);    // freemarker templates 存放目录    protected static String TEMPLATE_DIRECTORY = &quot;./wgs-templates&quot;;    public static void init() throws Exception {        if (initialized.get()) {            return;        }        initConfiguration();        initialized.compareAndSet(false, true);    }    static {        if (!initialized.get()) {            try {                init();            } catch (Exception e) {                theLogger.error(&quot;在初始化阶段，模版引擎初始化错误...&quot;, e);            }        }    }    // 初始化配置    private static void initConfiguration() throws Exception {        TEMPLATE_CONFIGURATION = new Configuration();        TEMPLATE_CONFIGURATION.setDirectoryForTemplateLoading(new File(TEMPLATE_DIRECTORY));        TEMPLATE_CONFIGURATION.setObjectWrapper(new DefaultObjectWrapper());        TEMPLATE_CONFIGURATION.setWhitespaceStripping(true);        TEMPLATE_CONFIGURATION.setClassicCompatible(true);    }    /**     * 通过模板和keyValuePairs动态创建shell脚本     *     * @param templateFileName 一个模板文件名，如：script.sh.template，其模板目录已在configuration中指定     * @param keyValuePairs 存储数据模型的&lt;K,V&gt;Map     * @param outputScriptFilePath 生成的脚本文件路径     * @return 一个可执行的Shell脚本文件     */    public static File createDynamicContentAsFile(String templateFileName,        Map&lt;String, String&gt; keyValuePairs, String outputScriptFilePath) {        if ((templateFileName == null) || (templateFileName.length() == 0)) {            return null;        }        Writer writer = null;        File outputFile = null;        try {            Template template = TEMPLATE_CONFIGURATION.getTemplate(templateFileName);            // 合并数据模型和模板，生成shell脚本            outputFile = new File(outputScriptFilePath);            writer = new BufferedWriter(new FileWriter(outputFile));            template.process(keyValuePairs, writer);            writer.flush();        } catch (IOException e) {            theLogger.error(&quot;创建文件失败...&quot;, e);        } catch (TemplateException e) {            theLogger.error(&quot;freeMarker动态创建shell脚本失败...&quot;, e);        } finally {            if (writer != null) {                try {                    writer.close();                } catch (IOException e) {                    theLogger.error(&quot;创建shell脚本，写入文件时出现IO异常...&quot;);                }            }        }        return outputFile;    }}</code></pre><h3 id="3-4-2-基因测序分析流程模版设计">3.4.2 基因测序分析流程模版设计</h3><p>用模版化的思想来构建全基因组分析流程，对要分析的样本对象用参数来代替，将整个分析流程分为Mapper阶段和Reduce阶段两个模版，在Mapper阶段模版主要完成基因测序的样本下载到本地机器、以及测序阶段中的比对、排序、标记重复、创建比对索引文件和对单个样本的变异检测生成中间阶段的变异检测gVCF文件，最后，将每个脚本生成的gVCF文件上传到上传到HDFS上，供Reduce阶段的分析流程使用。下面是Mapper阶段的分析模版：</p><pre><code class="language-shell">#!/bin/bash# 脚本所需的环境变量定义export BWA=~/biosoft/bwa/0.7.12export SAMTOOLS=~/biosoft/samtools/1.0/binexport GATK=~/biosoft/gatk/3.6/GenomeAnalysisTK.jarexport PICARD=~/biosoft/picard/2.18.2/picard.jarexport HADOOP=~/hadoop/bin# 定义参考序列export REF=~/wgs/input/fasta/E.coli_K12_MG1655.fa# 定义单个节点可利用的线程数THREAD=4# 定义单个节点可利用的内存资源MEMORY=4G# 定义RG INFOINFO_RG='@RG\tID:${sample_name}\tPL:illumina\tSM:E.coli_K12_${sample_name}'echo &quot;############&quot; `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &quot;############&quot;echo &quot;--- 开始处理样本 ${sample_name} ---&quot;# 定义模板变量INPUT_FILE_R1=${sample_name}_1.fastq.gzINPUT_FILE_R2=${sample_name}_2.fastq.gzcd /tmp# 从HDFS上下载测序样本Block块echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;$HADOOP/hadoop fs -get /wgsv2/input/fastq/$INPUT_FILE_R1&quot; &gt;&amp;2time $HADOOP/hadoop fs -get /wgsv2/input/fastq/$INPUT_FILE_R1 &amp;&amp; echo &quot;&quot; &gt;&amp;2echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;$HADOOP/hadoop fs -get /wgsv2/input/fastq/$INPUT_FILE_R2&quot; &gt;&amp;2time $HADOOP/hadoop fs -get /wgsv2/input/fastq/$INPUT_FILE_R2echo &quot;*** 从HDFS上下载样本数据块&quot; &amp;&amp; echo &quot;&quot; &gt;&amp;2# ××××××  基因测序 ×××××××# 步骤一 比对echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;$BWA/bwa mem -t $THREAD -R $INFO_RG $REF $INPUT_FILE_R1 $INPUT_FILE_R2 | $SAMTOOLS/samtools view -Sb - &gt; ${sample_name}.bam&quot; &gt;&amp;2time $BWA/bwa mem -t $THREAD -R $INFO_RG $REF $INPUT_FILE_R1 $INPUT_FILE_R2 | $SAMTOOLS/samtools view -Sb - &gt; ${sample_name}.bam &amp;&amp; echo &quot;*** 基因比对操作完成&quot; &amp;&amp; echo &quot;&quot; &gt;&amp;2# 步骤二 排序echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;$SAMTOOLS/samtools sort -@ $THREAD -m $MEMORY -O bam -o ${sample_name}.sorted.bam ${sample_name}.bam -T PREFIX.bam&quot; &gt;&amp;2time $SAMTOOLS/samtools sort -@ $THREAD -m $MEMORY -O bam -o ${sample_name}.sorted.bam ${sample_name}.bam -T PREFIX.bam &amp;&amp; echo &quot;*** 基因数据排序完成&quot; &amp;&amp; echo &quot;&quot; &gt;&amp;2#rm -f ${sample_name}.bam# 步骤三 标记重复echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;java -jar $PICARD MarkDuplicates I=${sample_name}.sorted.bam O=${sample_name}.sorted.markdup.bam M=${sample_name}.sorted.markdup_metrics.txt&quot; &gt;&amp;2time java -jar $PICARD MarkDuplicates I=${sample_name}.sorted.bam O=${sample_name}.sorted.markdup.bam M=${sample_name}.sorted.markdup_metrics.txt 1&gt;&amp;2 &amp;&amp; echo &quot;*** 对BAM文件进行重复标记&quot; &amp;&amp; echo &quot;&quot; &gt;&amp;2# 步骤四 创建比对索引文件echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;time $SAMTOOLS/samtools index ${sample_name}.sorted.markdup.bam&quot; &gt;&amp;2time $SAMTOOLS/samtools index ${sample_name}.sorted.markdup.bam &amp;&amp; echo &quot;*** 对BAM文件创建比对索引&quot; &amp;&amp; echo &quot;&quot; &gt;&amp;2# 步骤五 变异检测 | 生成各个样本的中间变异检测文件gvcfecho &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;java -jar $GATK -T HaplotypeCaller -R $REF --emitRefConfidence GVCF -I ${sample_name}.sorted.markdup.bam -o ${sample_name}.g.vcf&quot; &gt;&amp;2time java -jar $GATK -T HaplotypeCaller -R $REF --emitRefConfidence GVCF -I ${sample_name}.sorted.markdup.bam -o ${sample_name}.g.vcf 1&gt;&amp;2 &amp;&amp; echo &quot;*** 生成样本${sample_name}的中间变异检测文件gvcf&quot; &amp;&amp; echo &quot;&quot; &gt;&amp;2# 将各个样本分区的变异检测gvcf文件上传到HDFS上echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;$HADOOP/hadoop fs -put -f ${sample_name}.g.vcf /wgsv2/output/gvcf&quot; &gt;&amp;2time $HADOOP/hadoop fs -put -f ${sample_name}.g.vcf /wgsv2/output/gvcf &amp;&amp; echo &quot;*** 变异检测结果gvcf文件上传到HDFS上&quot; &amp;&amp; echo &quot;&quot;&gt;&amp;2rm -f rm -f $INPUT_FILE_R1 $INPUT_FILE_R2 ${sample_name}*echo &quot;--- 结束处理样本 ${sample_name} ---&quot;echo &quot;############&quot; `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &quot;############&quot; &amp;&amp; echo &quot;&quot;</code></pre><p>对于Reduce阶段的分析模版，主要是对各个Mapper阶段产生的gVCF变异文件的合并，得到最终总的VCF文件，并将其创建tabix索引后上传至HDFS上存储。下面是具体的Reduce阶段分析模版：</p><pre><code class="language-shell">#!/bin/bash# Author: elon# Description: 合并所有样本的GVCF文件的模板# Time: 2018-4-5# 该脚本需要完成的是对各个样本分区的VCGF文件做一个merge操作export SAMTOOLS=~/biosoft/samtools/1.0/binexport GATK=~/biosoft/gatk/3.6/GenomeAnalysisTK.jarexport HADOOP=~/hadoop/bin# 定义参考序列export REF=~/wgs/input/fasta/E.coli_K12_MG1655.faecho &quot;############&quot; `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &quot;############&quot;echo &quot;--- 开始合并处理样本 ${sample_name1} ${sample_name2} ${sample_name3} ${sample_name4} ${sample_name4} ${sample_name5} ${sample_name6} ${sample_name7} ${sample_name8} ${sample_name9} ---&quot;# 定义模板变量INPUT_FILE1=${sample_name1}.g.vcfINPUT_FILE2=${sample_name2}.g.vcfINPUT_FILE3=${sample_name3}.g.vcfINPUT_FILE4=${sample_name4}.g.vcfINPUT_FILE5=${sample_name5}.g.vcfINPUT_FILE6=${sample_name6}.g.vcfINPUT_FILE7=${sample_name7}.g.vcfINPUT_FILE8=${sample_name8}.g.vcfINPUT_FILE9=${sample_name9}.g.vcfcd /tmp# 从HDFS上download所有的GVCF文件$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE1$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE2$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE3$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE4$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE5$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE6$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE7$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE8$HADOOP/hadoop fs -get /wgsv2/output/gvcf/$INPUT_FILE9echo &quot;*** 从HDFS上获取所有相关的gVCF文件&quot;# 合并所有的gVCF文件为VCF文件 -- E_coli_K12.vcfecho &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;java -jar $GATK -T GenotypeGVCFs -nt 4 -R $REF --variant $INPUT_FILE1 --variant $INPUT_FILE2 \--variant $INPUT_FILE3 --variant $INPUT_FILE4 --variant $INPUT_FILE5 --variant $INPUT_FILE6 \--variant $INPUT_FILE7 --variant $INPUT_FILE8 --variant $INPUT_FILE9 \-o E_coli_K12.vcf&quot; &gt;&amp;2time java -jar $GATK -T GenotypeGVCFs -nt 4 -R $REF --variant $INPUT_FILE1 --variant $INPUT_FILE2 \--variant $INPUT_FILE3 --variant $INPUT_FILE4 --variant $INPUT_FILE5 --variant $INPUT_FILE6 \--variant $INPUT_FILE7 --variant $INPUT_FILE8 --variant $INPUT_FILE9 \-o E_coli_K12.vcf 1&gt;&amp;2 &amp;&amp; echo &quot;*** 合并所有的gVCF文件为VCF文件&quot; &amp;&amp; echo &quot;&quot;&gt;&amp;2## 1.将vcf文件压缩echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;bgzip -f E_coli_K12.vcf&quot; &gt;&amp;2time bgzip -f E_coli_K12.vcf &amp;&amp; echo &quot;*** 将vcf文件进行压缩&quot; &amp;&amp; echo &quot;&quot;&gt;&amp;2## 2.构建tabix索引echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;$SAMTOOLS/tabix -p vcf E_coli_K12.vcf.gz&quot; &gt;&amp;2time $SAMTOOLS/tabix -p vcf E_coli_K12.vcf.gz \&amp;&amp; echo &quot;*** 给压缩文件构建tabix索引&quot; &amp;&amp; echo &quot;&quot;&gt;&amp;2## 3. 上传最终的VCF文件以及索引文件到HDFS上echo &quot;###COMMAND LINE###：&quot; &gt;&amp;2echo &quot;$HADOOP/hadoop fs -f -put E_coli_K12.vcf.gz* /wgsv2/output/vcf&quot; &gt;&amp;2time $HADOOP/hadoop fs -f -put E_coli_K12.vcf.gz* /wgsv2/output/vcf \&amp;&amp; echo &quot;*** 变异检测结果vcf文件上传到HDFS上&quot; &amp;&amp; echo &quot;&quot;&gt;&amp;2#rm -f E_coli_K12.vcf* *g.vcf*echo &quot;--- 结束合并处理样本 ${sample_name1} ${sample_name2} ${sample_name3} ${sample_name4} ${sample_name4} ${sample_name5} ${sample_name6} ${sample_name7} ${sample_name8} ${sample_name9} ---&quot;echo &quot;############&quot; `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &quot;############&quot; &amp;&amp; echo &quot;&quot;</code></pre><h3 id="3-4-3-基因测序与模板引擎的结合">3.4.3 基因测序与模板引擎的结合</h3><p>在我的项目框架中，对于不同的样本文件，都是采用同一套基因测序分析流程，而测序流程都是通过Linux命令行界面，因此需要通过一定的转换，将这一套分析流程提炼成一个Shell模版，对于不同的样本文件生成和它相应的分析脚本文件，这样就能达到不同的样本使用这同一套分析流程的目的，最后在不同的map任务中分别执行每个样本的分析脚本。测序流程与分析脚本的模版化如图3-2所示。</p><p><img src="https://i.imgur.com/Am9wU9Z.png" alt="图3-2 测序流程与分析脚本的模版化"></p><h2 id="3-5-本章小结">3.5 本章小结</h2><p>在本章中，主要对基于Hadoop基因测序数据处理的关键技术作了一个剖析和研究，解决了测序流程如何与MapReduce程序结合的问题，以及对于测序流程中各个步骤产生的数据结果如何存储，是存储在本地还是分布式存储系统中的问题，以及对分析流程的完整行作了简要分析，提出了通过设置驱动程序的参数达到对每一行数据分为一个Map程序处理的设计方案，以及通过引入第三方FreeMarker框架来保证分析流程的统一性和完整性问题，最后构建FreeMarker引擎以及对测序流程进行模板化的设计等。</p><p>在下一章节中，对基于Hadoop大数据的基因测序平台的流程搭建进行设计与实现。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Samy Ghoneimy, Samir Abou El-Seoud. A MapReduce Framework for DNA Sequencing Data Processing[D]. British University 2017. <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Apache. Apache FreeMarker™[EB/OL]. <a href="https://freemarker.apache.org/" target="_blank" rel="noopener">https://freemarker.apache.org/</a>, 2018. <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>Mahmoud Parsian. 数据算法（Hadoop/Spark大数据处理技巧）[M]. 苏金国,杨健康等译. 清华大学出版社 第四版 2016. <a href="#fnref3" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2 相关技术及原理</title>
      <link href="/blog/5290c12.html"/>
      <url>/blog/5290c12.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-hadoop相关技术和原理">2.1 Hadoop相关技术和原理</h2><p>本节主要对基于Hadoop平台的相关技术，如：HDFS、YARN和MapReduce三大模块进行原理介绍，为后续基因测序在Hadoop平台上的搭建作相应的准备。</p><h3 id="2-1-1-hdfs分布式存储系统">2.1.1 HDFS分布式存储系统</h3><p>Hadoop分布式存储系统，即Hadoop Dirstributed FileSystem，简称HDFS<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。由于Hadoop集群的基础架构设施，使得HDFS是一个能提供可扩展性和高可靠性的基于Java的文件系统，并且适用于大型商业服务器集群或是廉价服务器上，从而可以提供PB级的存储容量和上千个服务器的计算能力。</p><a id="more"></a><p>此外，HDFS还是一个高容错的分布式存储系统，理论上可以无限扩展集群的存储能力，并与YARN服务（主要负责Hadoop集群中的资源管理和任务调度工作）协调各种并发任务调度。通过在多台服务器节点之间分配存储资源和计算资源，使得存储资源可以随需求线性增长，并协调各个服务器之间的计算能力。</p><p>HDFS有以下特点来确保数据高效存储在Hadoop集群中，并具有高可用性：</p><ol><li>机架感知意识，在Hadoop集群中客户端进行数据访问时，会自动考虑节点的物理位置，将离作业节点最近的数据块传输过去。</li><li>保证最小的数据转移，Hadoop将计算任务移动到数据所在的节点上，这样能保证处理任务发生在数据所在的物理节点，从而显著减少机架之间的网络传输的I/O流。</li><li>动态诊断HDFS存储系统的运行状况，并重新平衡不同节点上的数据。</li><li>回滚操作，HDFS支持对某一状态的文件系统进行快照保存，这样允许操作员在升级后恢复以前的HDFS版本，以防止发生人为或系统错误。</li></ol><p>在高可用的集群中，在两台独立的机器分别配置NameNode。在任何时候，只有一个NameNode处理Active状态，另一个处理Standby状态，在必要时候可以提供快速故障转移。HDFS的联邦政策，允许在一个集群中部署多个子NameNode，可以扩展文件块的镜像文件的大小，并管理联合集群。</p><p>在Unix系统架构中，每次磁盘都有默认的数据块，文件都以块的形式存储的，同样，在HDFS也有块（block）的概念，但是比Unix的文件系统块大得多，默认为128MB。HDFS的架构图如图2-1所示：</p><p><img src="https://i.imgur.com/ta21xdv.png" alt="图2-1 HDFS架构图"></p><p>对分布式文件系统中的块进行HDFS抽象可以使得一个文件的大小可以大于网络中任意一个磁盘的容量。从本地文件系统将一个文件复制到HDFS，该命令调度Hadoop文件系统的fs命令，并提供一系列子命令，包括-copyFromLocal。在下面的命令中，本地文件local.txt会被上传到HDFS中，路径为<code>/user/elon/remote.txt</code>。</p><pre><code class="language-shell">% hadoop fs -copyFromLocal local.txt hdfs://localhost/user/elon/remote.txt</code></pre><h3 id="2-1-2-mapreduce并行计算框架与yarn资源调度器">2.1.2 MapReduce并行计算框架与Yarn资源调度器</h3><p>Hadoop MapReduce<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>是一个计算框架，在进行MapReduce编程时，要编写用于数据处理的map函数和reduce函数，并以可靠并容错的方式在数千个节点的大型群集的大型商业硬件上并行处理大量数据。</p><p>通常，计算节点和存储节点是相同的，允许框架在数据已经存在的节点上有效地调度任务，达到数据本地化的效果，从而在整个集群中具有非常高的执行效率。<br>在Hadoop2.0以后，Hadoop社区将资源管理和任务调度的功能从原来的MapReduce中分离出来，形成现在的YARN<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，Apache Hadoop YARN架构 如图2-2所示：</p><p><img src="https://i.imgur.com/lhCLV4Q.png" alt="图2 2 Apache Hadoop YARN架构图"></p><p>从上面的YARN的架构图可以得知，YARN[13]是由资源管理器和作业调度及各个节点的监控所组成的，包含一个全局的资源管理器（ResourceManager，简称RM）和每个应用程序的管理器（ApplicationMaster，简称AM），其中应用程序可以是单个的作业或者是一个DAG（有向无环图）的作业流水线。</p><p>MapReduce程序就是在YARN上进行资源分配和作业调度的，集群中的每个计算节点的主机都运行着一个节点管理器（NodeManager，简称NM），负责监视机器上各个容器的资源私使用情况，而作业是部署在每个容器（Container）中进行计算的，对于一个大型的任务，可能会被拆分为多个map任务而被部署在各个容器中来并行计算。</p><p>对于一个作业的完整运行流程的阐述如下：首先从客户端提交作业，随后被分配到各个计算节点的container容器中，并会在其中一个计算节点生成AM任务管理器，AM了解本次任务执行所需的资源，并会向RM进行资源请求，随后RM将命令NM资源管理器向该节点中的容器分配相应的计算资源。在整个任务的计算周期内，Container会定时向AM发送自己MapReduce程序的运行进展情况，NM对自己节点上的Container容器的资源使用情况进行监控，并将其报告给RM。</p><h2 id="2-2-全基因组测序相关技术和处理流程">2.2 全基因组测序相关技术和处理流程</h2><p>在进行全基因组测序相关处理流程的设计<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>时，主要涉及三个大的流程步骤（如下图），全基因组的测序分析步骤如图2-3所示。</p><p><img src="https://i.imgur.com/3GaOomZ.png" alt="图2-3 全基因组的测序分析步骤"></p><p>第一步是对测序仪中得到的原始基因组数据进行数据指控，只有在对需要进行测序的数据进行数据质控后并保证了数据源的有效性，后面测序的结果才是真实有效的。在第二步中，对测序数据进行预处理，而这其中主要包括三个步骤：read比对、排序以及标记重复序列，并对标记的重复序列建立索引，最终作为变异检测的输入数据。在第三步中，进行主要的变异检测操作，而这里又分为两种方式，第一种是对单样本数据直接进行变异检测处理，直接得到变异结果。第二种是对多个样本组数据进行分批变异检测处理，得到分离的gVCF文件，最后再合并成一个VCF变异文件，得到最终的基因变异集合。</p><h3 id="2-2-1-原始数据质控">2.2.1 原始数据质控</h3><p>在全基因组测序研究中，以illumina为首的测序流程大多数都是运用边合成边测序的技术，其中需要经历一系列的化学反应。在这个合成的过程中随着化学合成链的增长，DNA聚合酶的活性会不断下降。另外，由于测序仪在刚开始化学合成反应时不够稳定，同样会带来碱基质量值的波动。</p><p>测序数据的质量好坏会直接影响我们的基因测序的下游分析和最终的变异检测的结果。因此我们需要在进行下游分析之前进行数据的质量控制检测<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。但不同的测序平台其稳定性和测序的准确性也有差异，目前在数据指控方面使用较多的是FastQC这款软件。</p><p>FastQC<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>是一个Java程序，能够比较高效地来计算，并能以HTML的格式给出read的质量值和碱基测序错误率，形成最终的基因样本数据的测序报告。在给出的报告中，会包含几个重要的指标并以图谱的形式展现出来，指明原始数据可能还存在着哪些问题，并通过其质控结果作出相应的后续工作，比如是直接在后续分析流程中使用、或是进行部分切除后使用，亦或是将该原始数据直接丢弃不使用等。<br>在本次研究所使用的大肠杆菌的全基因组的测序样本中，对所有的样本都进行了数据质控的操作，并根据质控报告做了相应的处理。下面我选取SRR3226036_1号样本 进行数据质控的流程展示，基本的测序数据信息如图2-4所示。</p><p><img src="https://i.imgur.com/zW7EDJ1.png" alt="图2-4 基本的测序数据信息"></p><p>从上图中，我们不难得到该SRR3226036_1号样本数据的基本信息，其中就包括测序数据的文件名、文件类型，测序仪的编码类型等基本信息，后面还给出来本次质控的总测序read数是123万多条，测序read中被标记为低质量的测序读长为0，每条测序read的长度在32-76之间。</p><p><img src="https://i.imgur.com/Z0oBb5w.png" alt="图2-5 read的碱基质量值分布图"></p><p>read的碱基质量值分布如图2-5所示，展示的是该样本质控中read的碱基质量值分布图，其中横轴是read上碱基的位置分布，纵轴是碱基质量值。在该图中碱基质量值都大于35，而且各个read位置的碱基值波动很小，可以看到图中质量值的分布都在绿色背景（代表高质量）的区域，说明这个样本的碱基质量很稳定，这其实是一个非常高质量的样本质控结果。</p><p>各读长中碱基的含量占比如图2-6所示，展示的是该测序样本中各个碱基的含量占比情况，我们可以发现在读长为小于20以及读长大于75的区域，其碱基含量分布是波动较厉害的，说明在这两个区域的化学合成反应是不稳定所导致的，也就是在反应的开始阶段测序仪内部环境还处于不稳定的状态，以及在化学反应后期生物酶已逐渐失活所引起的，恰好应证了在本节最开始处提及的一般测序read不会太长的情况，这也是在数据质控的基本信息那张图片所展示的测序读长在32～76之间的缘故。因为只有这一块的碱基含量占比是稳定的，而且各个碱基之间的占比差距不大，表明这部分读长的数据是相对可靠的，适合拿来做基因测序的下游分析。</p><p><img src="https://i.imgur.com/5uuMmgE.png" alt="图2-6 各读长中碱基的含量占比图"></p><p>这一节主要对测序样本数据进行质量分析控制，将不适合进行下游分析的数据样本切除或丢弃。下一节会详细介绍基因测序处理流程的各个分析阶段，展现如何从一组样本数据得到最终的变异检测文件。</p><h3 id="2-2-2-数据预处理">2.2.2 数据预处理</h3><p>(1) 第一步：序列比对<br>全基因组测序的短序列（read）存储于FASTQ文件里面，在我的测序样本数据中是用fastq.gz的压缩格式表示的，这样的gz格式文件，在序列比对时也是被支持的。它会先进行解压再开始比对。虽然这些短序列在测序仪中进行化学反应时是在一起的，原本都来自于有序的基因组库中，但在经过化学合成和碱基提取之后，原本的read序列的前后顺序关系就已经不存在了。所以，FASTQ文件中紧挨着的两条read之间都是随机来自于原本基因组样本中某个位置的短序列而已。</p><p>因此，我们需要先把这一大堆的短序列捋顺，将这些短序列与该物种的参考基因组 作比对，通过一个read一个read的比对，找到每一个read在参考基因组上的位置，并在文件中标记好每个读长的位点信息，从而得到比对后的数据文件，这个过程就称为测序数据的序列比对。</p><p>测序数据的序列比对本质上是一个按照参考基因组来寻找最大公共子字符串的过程。而目前用的比较广泛的是BWA 软件，它将使用BWA-MEM算法[17]进行序列比对。下面是BWA的官方文档[18]说明，其中指出了用于序列比对的API：<br><code>Usage: bwa mem [options] &lt;idxbase&gt; &lt;in1.fq&gt; [in2.fq]</code></p><p>其中第一个参数[option]是可选参数，包括程序处理时所分配的线程数，最小的seed长度以及read的类型等信息。第二个参数<idxbase>是指代参考基因组的BW索引文件。第三个和第四个参数指代的是输入测序数据，包括R1.fastq和R2.fastq文件。输出数据包含各read序列的位点信息，可以采用重定向的方式输出到其他文件中。具体的示例如下：</idxbase></p><p>在上面的示例中，需要补充的是samtools软件的使用，这个在下面排序阶段会有提及，这里对其进行简单说明，最后将比对的文件进行重定向到管道中，并交由samtools的view方法进行自动检测数据格式，并最终输出BAM格式的文件并保存在SRR3226036.bam中。</p><p>(2) 第二步：排序<br>由于在上一步中只是将原始短序列读长与参考基因组进行序列比对，并记录各个序列的位点信息随即就输出了，而对原始序列未进行移动，它们还是随机分布于BAM文件中的。在这一步排序中，就是通过第一步中保存的各个序列的位点信息，需要将比对记录按照顺序从小到大排序下来，才能进行后续的去重复等操作。</p><p>这里，我们将会用到另外一款流行的基因测序的软件Samtools 。这里通过其官方API文档对Samtools的一个简单介绍。samtools一共有五个模块的功能，其中包括indexing（建立索引）、editing（对读长序列进行处理，包括替换BAM头、去除重复以及修复元数据信息等）、file operations（对测序样本文件操作，包括切分、合并、排序以及转换文件格式等）、stats（读取文件的状态信息等，包括BAM索引信息、计算测序深度以及生成状态信息等）和viewing（对BAM标记进行解释，以及将SAM、BAM和CRAM三种格式进行转换）。在本次测序流程中，主要使用这款软件完成排序和建立索引的操作，因此还会再后面的建立索引的流程中使用到它。在Samtools[19]官方文档中，比对命令如下：<br><code>Usage: samtools sort [options...] [in.bam]</code></p><p>其中第一个参数[options…]是可选参数，在本次排序处理中，会用到的有-@ 整数，设置用于排序和压缩的线程数；-m 整数，设置分配给每个线程的最大内存资源；-O 格式类型，指定输出的格式类型，这里包括sam、bam和cram三种格式，我们需要的是bam格式，用于下一步的标记重复操作；-o 文件，指定最终输出到一个文件中保存，而不是将其直接输出到屏幕上的这种标准输出形式；以及-T PREFIX，指定临时文件的文件命名中的首字母，最后这些临时文件会在排序结束后删除。第二个参数[in.bam]指代的就是已包含各个测序序列的参考位点信息的比对文件。具体的示例如下：</p><pre><code class="language-shell">$SAMTOOLS/samtools sort \-@ 4 \-m 4G \-O bam \-o SRR3226036.sorted.bam \SRR3226036.bam \-T PREFIX.bam \&amp;&amp; echo &quot;*** BAM文件排序完成&quot;</code></pre><p>(3) 第三步：标记重复序列<br>在基因测序的处理流程中，我们通过化学反应得到DNA液，并放到测序仪中将其测序并切分为每个短读长序列，分离成每个碱基对的形式，得到我们所需的原始基因组数据。这样一系列操作需要通过物理（超声）打断或者化学试剂（酶切）的方式来打断原始的DNA序列，其中就存在DNA的降解的问题，再加上有些基因数据在原本的基因组中含量就相对稀少，会存在局部DNA浓度过低的问题，因此需保证每种DNA片段在原来的基因组中的相对含量。</p><p>因此，我们需要选择适合实验的特定长度范围的序列来进行PCR扩增，并加入到测序仪中测序保证数据的完整性问题。而基因组中重复序列的来源，实际上就是PCR扩增过程所导致的。PCR扩增本质上就是通过化学反应的方式将原始的某一段DNA序列复制多次。</p><p>但是要注意的是，PCR技术是为了增大微量的DNA片段的浓度含量，但由于整个化学反应都在同一个试管中进行，因此其他一些密度并不低的DNA片段同时也会被放大好多倍，这时再取样去测序仪上测序的时候，这些浓度并不低的DNA片段就很可能会被重复取到相同的多条，并通过测序仪中的测序得到样本数据。因此我们需要对上一步中有重复的读长数据进行标记或者去除操作。</p><p>事实上，目前用的比较多的工具有Samtools和Picard，它们都可以去除重复序列，只是一个是直接删除重复序列，另一个可以仅标记但可保留重复序列，在最后的变异检测期间将其忽略。下面分别对这两种去除重复的方式进行介绍：<br>第一中，Samtools的方式：<br><code>Usage: samtools rmdup [-sS] &lt;input.srt.bam&gt; &lt;output.bam&gt;</code></p><p>在这个API中，可选参数-s指代的是仅对SE读长序列去除重复序列，-S指代的是对待PE读长和SE读长一样，都进行去除重复序列操作；第二个参数&lt;input.srt.bam&gt;指代的是输入数据源，第三个参数&lt;output.bam&gt;指代的是输出数据源，注意这两个数据源都是bam格式的文件。</p><p>第二种，Picard的方式，下面给出了我的测序流程中的处理命令：</p><pre><code class="language-shell">java -jar picard.jar MarkDuplicates \I= SRR3226036.sorted.bam \O= SRR3226036.sorted.markdup.bam \M= SRR3226036.sorted.markup_metrics.txt \&amp;&amp; echo &quot;*** 对BAM文件进行重复标记&quot;</code></pre><p>这里总共需要三个参数，第一个是输入上一步已排序好的数据源BAM文件，第二个是输出的带有重复序列位点信息标记的BAM文件，第三个是对重复序列的位点信息进行标记的文件。这里还可以在第一个参数前使用REMOVE_DUPLICATE=true或REMOVE_SEQUENCING_DUPLICATES=true选项，表示在此操作中重复序列片段会从原BAM文件中直接删除掉。</p><p>这一步完成之后，我们需要为重复序列比对阶段得到的文件创建索引。创建索引的好处是它能够让我们可以随机访问这个文件中的任意位置并提供灵活性。通过在前面提及的Samtools软件来建立索引，命令如下：<br><code>Usage: samtools index [-bc] [-m INT] &lt;in.bam&gt; [out.index]</code></p><p>其中，第一个可选参数[-bc]分别是对BAI-format和CSI-format的序列格式转换为BAM格式的文件，第二个参数-m 整数是为CSI指数设置最小的区间大小。在我的处理测序流程中具体的示例如下：</p><h3 id="2-2-3-变异检测">2.2.3 变异检测</h3><p>到目前为止，我们已经完成了基因测序的前两大模块，数据质控和数据预处理，接下来就到了对样本数据进行变异检测的阶段了。这是本次全基因组分析流程创建的最终目标——得到样本集合的变异集合，可以为后续基因组学的科研提供有力的数据支撑。</p><p>变异检测的内容一般会包括：SNPs、indels、CNV和SV等。在这次的基因变异检测流程搭建中，主要涉及的是前两个SNPs和indels的变异检测。我们采用的生物信息学的分析工具The Genome Analysis Toolkit ，简称GATK。它是由The Broad Institute公司开发的用于二代重测序数据分析的一款软件。GATK是鉴定种系DNA和RNAseq数据中SNP和indels的行业标准，也是目前行业使用率最高的基因数据变异检测工具。GATK4.0的范围现在扩大到包括体细胞短变异调用，并且能够处理拷贝数（CNV）和结构变异（SV）。除了不同的调用者本身之外，GATK还包括许多实用工具，用于执行相关任务，如高通量测序数据的处理和质量控制，并捆绑了流行的Picard工具包。</p><p>通过GATK的官方API文档[20]中查看，可以得知和变异检测有关的方法有两个，它们分别是UnifiedGenotyper 和HaplotypeCaller 。<br>UnifiedGenotyper是根据每个基因组来调用SNPs[21]和indels[22]。该工具使用贝叶斯基因型似然性模型来同时估计N个样品群体中最可能的基因型和等位基因频率，为每个样品产生一种基因型。其输入数据可以是产生多种不同调用的read数据，输出则是一行未筛选高敏感性的VCF格式的文件。对于大量的样本组文件SNP调用，其分析示例如下：</p><pre><code class="language-shell">java -jar GenomeAnalysisTK.jar \    -T UnifiedGenotyper \    -R reference.fasta \    -I sample1.bam [-I sample2.bam ...] \    --dbsnp dbSNP.vcf \    -o snps.raw.vcf \    -stand_call_conf [50.0] \[-L targets.interval_list]</code></pre><p>其中，-T指代的是调用的方法类型；-R指代的是参考基因组；-I指代的是输入的样本数据，如果有多个则输入多个样本名；–dbsnp表示目前已知的某物种基因变异位点文件，一般会由大型的研究机构发布出来；-o是指代vcf格式的输出文件；-stand_call_conf 指代应该调用变体的最小phred-scaled置信度阈值，默认值是50.0；可选参数-L指代的是一个或多个要运行的基因组区间。</p><p>而对于另外一种基因变异检测的方法是通过HaplotypeCaller来实现，除了可以像UnifiedGenotyper一样，对变体的数据进行整体调用，得到变异检测的VCF文件，它和上一种方式的不同之处在于，它还可以通过局部重新组装haplotypes来调用SNPs和indels，侧重点在于对局部的样本文件进行变异检测，换句话说，只要程序遇到显示变化迹象的区域，它就会丢弃现有的映射信息，并完全重新组合该区域中的读取。</p><p>这一特性对于多样本数据的基因检测尤为有效，因为在对多样本进行变异检测时，可能刚开始的数据并不多，在测序流程进行到一部分的时候，该项目研究中需要再新增一部分新的样本数据，当使用原来UnifiedGenotyper的方式来进行变异检测生成VCF数据时，需要对全量数据重新进行分析计算。但是在这里，有了HaplotypeCaller的分析方式，就不存在全量数据的概念了。因为每个样本数据都视为整体的一部分，而对于每部分的样本变异检测都会生成gVCF文件，每个gVCF文件之间是隔离的，在有新的样本数据加入时，只需生成增量样本数据的gVCF文件即可。在我的测序处理流程中就是采用的这种先生成gVCF文件的方式。在我实际的测序流程中，具体的示例如下：</p><p>同样，这个HaplotypeCaller相关的分析命令和第一种UnifiedGenotyper方法的分析命令相似，唯一的不同之处在于新增了一项参数–emitRefConfidence GVCF，这项参数是固定的，指明本次命令变异检测的是单样本数据，产生的是gVCF文件格式。最后对于该样本组下的所有gVCF文件，通过GATK的另一个方法GenotypeGVCFs来进行合并处理，具体的使用示例如下。</p><pre><code class="language-java">java -jar GenomeAnalysisTK.jar \   -T GenotypeGVCFs \   -nt 4   -R reference.fasta \   --variant SRR3226034.g.vcf \   --variant SRR3226035.g.vcf \…   --variant SRR3226042.g.vcf \   -o E_coli_K12.vcf \&amp;&amp; echo &quot;*** 合并所有的gVCF文件为VCF文件&quot;</code></pre><p>该方法是专门对HaplotypeCaller生成的gVCF文件进行genotyping联合，输入参数是一个或多个HaplotypeCaller gVCF进行genotype，输出参数是一个已经组合的genotyped的VCF。最终生成的E_coli_K12.vcf文件，即是E_coli_K12物种来自样本组中的全基因组变异检测结果。</p><h3 id="2-2-4-相关文件格式概述">2.2.4 相关文件格式概述</h3><p><strong>(1) FASTA文件格式</strong><br>FASTA[23]作为存储有顺序的序列数据的文件后缀，这里的序列数据指的其实就是能表示DNA或者蛋白质的一条字符串。FASTA文件表示的序列是有顺序的，我们可以通过各个read中碱基位点序列数，就可以知道某个DNA碱基在某个基因组上的准确位置，这个位置会用所在序列的名字和所在位置来表达，比如基因数据比对的结果等。</p><p>FASTA文件主要由两个部分构成：序列头信息（有时包括一些其它的描述信息）和第二行具体的基因序列数据。头信息独占一行，以大于号（&gt;）开头作为识别标记，包括染色体的名称信息和一些其他信息。</p><pre><code>&gt;NC_000913.3 Escherichia coli str. K-12 substr. MG1655, complete genomeAGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGCTTCTGAACTGGTTACCTGCCGTGAGTAAATTAAAATTTTATTGACTTAGGTCACTAAATACTTTAACCAATATAGGCATAGCGCACAGACAGATAAAAATTACAGAGTACACAACATCCATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGACGCGTACAGGAAACACAGAAAAAAGCCCGCACCTGACAGTGCGGGCTTTTTTTTTCGACCAAAGG</code></pre><p>上面是一个FASTA文件的例子，这是大肠杆菌K12.coli微生物基因的部分序列。在序列头信息中标注的是这个基因文件来自NC_000913.3号染色体，来自大肠杆菌K-12的全基因组数据。</p><p><strong>(2) FASTQ文件格式</strong><br>FASTQ[24]文件格式是目前存储测序数据最普遍、最公认的一个数据格式。前面FASTA文件存储的是来自该生物已排序已知的参考基因组的序列信息，而FASTQ存储的是来自测序仪得到的原始测序数据。这些原始数据是通过测序仪生成的图像数据转换过来，也是文本文件。文件大小依照测序量（或测序深度）的不同而存在较大差异，小的可能只有几M，如微生物的基因组，而大的则有几十甚至上百G，文件后缀通常都是.fastq.fq或者.fq.gz（gz压缩格式）。</p><pre><code>@SRR3226034.1 1/1TCCACGTTGCGACCGACAGCGCCACACGCTTCTGGTGGCGAGGCGACAACTCATTCCAGTTCAGCACATAGCGCT+@&lt;@6@=6C@@FFDGGEGGGGGGGGGGGEDGGGGG8EFFGD&gt;FGCEGCEDEEEFGG&lt;FFDGGAFFF,9&lt;,C+&gt;,@SRR3226034.2 2/1CCTTGCCGAGGGCCCGGCCCTCGACGCCCACGCGCCAGCCGCCGCTGGGCTGCCAGGCCAGCGCGCCGTACAGCG+AACCCC+@8::FGGGCGGGGGC7FEGGGGGGGFGGDGGGEGG7FF7=7C=:=E8C,DC87C+@+@F7@+B+,:+</code></pre><p>上面是从NCBI上下载的K12.coli物种的基因组测序样本SRR3226034的部分数据，从这个例子可以看出，FASTQ数据有着自己独特的格式：每四行成为一个独立的单元，我们称之为一个读长，简称为read，这是测序的最小单位。具体格式如下：</p><ol><li>第一行：以‘@’开头，是这一条read的名字，根据测序仪测序时的状态信息转换生成的，它是每一条read的唯一标识符，同一份FASTQ文件中不会重复出现；</li><li>第二行：测序read的序列，由A，C，G，T和N这五种字母构成，这是真正的DNA序列信息，其中N字符代表的是测序时那些无法被识别出来的碱基；</li><li>第三行：以‘+’开头，一般会空着；</li><li>第四行：用ASCII码标明测序read的质量值，表示的是每个测序碱基的可靠程度。<br>在后面的全基因组测序中要用到这两种数据格式，其中FASTA是参考基因组的存放格式，FASTQ是基因样本数据的存放格式。</li></ol><p><strong>(3) gVCF文件格式</strong><br>对单个样本Pair对数据进行基因测序时，最终得到Genome Variant调用格式文件,缩写为gVCF。它是一种文本文件格式，存储变体和非变体位置的测序信息，以一种紧凑的格式表示基因组中所有位点的基因型、注释和其他信息 。</p><p>gVCF是一种轻量的变体存储格式，可以将其压缩成gzip文件（<em>.genome.vcf.gz）。随后可以将得到的gCVF文件进行索引，创建一个</em>.tbi格式的文件，并与现有的VCF工具（如tabix和IGV）一起使用，使其既可以直接解释也可以作为三次分析的起点。</p><p>(1) 注释说明<br>gVCF文件的注释包含以下部分：</p><ol><li><p>元信息行以##开头，包含元数据，配置信息，并定义INFO，FILTER和FORMAT字段的值。</p></li><li><p>标题行以#开头，并命名数据行使用的字段。这些字段是#CHROM，POS，ID，REF，ALT，QUAL，FILTER，INFO，FORMAT，后跟一个或多个样本列。</p></li><li><p>数据行包含关于基因组中一个或多个位置的信息。</p></li></ol><p>(2) 字段说明<br>固定字段#CHROM，POS，ID，REF，ALT，QUAL在1000 Genomes Project提供的VCF4.2标准中定义，元信息中描述了字段ID，INFO，FORMAT和样本。</p><ul><li><ol><li>CHAROM：染色体：来自参考基因组的标识符。</li></ol></li><li><ol start="2"><li>POS：位置：参考位置，在每个参考序列CHROM中的第一个匹配的起始位置，位置按照递增顺序的数字排序，可以在一个POS中有多个记录。</li></ol></li><li><ol start="3"><li>ID：可用的唯一标识符。如果没有可用标识符，则使用默认值。</li></ol></li><li><ol start="4"><li>REF：参考碱基：A，C，G，T，N；可以有多个碱基。POS字段中的值指的是字符串中第一个碱基的位置。</li></ol></li><li><ol start="5"><li>ALT：逗号分隔的非等位基因列表，选项是：</li></ol></li><li><p>a) 由碱基A，C，G，T，N组成的碱基串。</p></li><li><p>b) ID字符串（“<id>”）</id></p></li><li><p>c) 或者是关于break-edns的部分中断替换字符串。</p></li></ul><p>如果没有其他等位基因，则使用缺失值。</p><ul><li><ol start="6"><li>QUAL：用于ALT中断的Phred-scale质量分数。即-10log_10概率。如果未知，则使用默认值。</li></ol></li><li><ol start="7"><li>FILTER：如果该位置已通过所有过滤器，即在该位置进行call并通过。否则，如果该位置未通过所有过滤器，则以分号分隔的过滤器代码列表表示。</li></ol></li><li><ol start="8"><li>INFO：其他信息。INFO字段被编码为分号分隔的一些列短键，其中可选值的格式如下：<key>=<data>[, data]。gVCF文件使用以下值：</data></key></li></ol></li><li><p>a) END：该记录中描述的区域的结束位置。</p></li><li><p>b) BLOCKAVG_min30p3a：非变量block块。</p></li><li><p>c) SNVSB：SNV位点链偏移</p></li><li><ol start="9"><li>FORMAT：实例字段的格式。FORMAT指定子字段的数据类型和顺序。gVCF文件使用以下值：</li></ol></li><li><p>a) GT：基因型</p></li><li><p>b) GQ：基因型质量</p></li><li><p>c) GQX：{基因型质量假设变异位置，基因型质量假定非变异位置}</p></li><li><p>d) DP：用于基因分型的过滤call深度。</p></li><li><p>e) DPF：在基因分型之前从输入中过滤掉基础调用。</p></li><li><p>f) AD：列出顺序中ref和alt等位基因的等位基因深度。对于indels，这个值只包括每个等位基因的读段。</p></li><li><p>g) DPI：读取与indel相关的深度，取自indel之前的集合。</p></li><li><ol start="10"><li>SAMPLE：样本实例在FORMAT中各个实例字段对应的值。</li></ol><pre><code>##fileformat=VCFv4.2##ALT=&lt;ID=NON_REF,Description=&quot;Represents any possible alternative allele at this location&quot;&gt;##FILTER=&lt;ID=LowQual,Description=&quot;Low quality&quot;&gt;##FORMAT=&lt;ID=AD,Number=R,Type=Integer,Description=&quot;Allelic depths for the ref and alt alleles in the order listed&quot;&gt;##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description=&quot;Approximate read depth (reads with MQ=255 or with bad mates are filtered)&quot;&gt;##FORMAT=&lt;ID=GQ,Number=1,Type=Integer,Description=&quot;Genotype Quality&quot;&gt;##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&gt;##INFO=&lt;ID=MQ,Number=1,Type=Float,Description=&quot;RMS Mapping Quality&quot;&gt;##INFO=&lt;ID=MQRankSum,Number=1,Type=Float,Description=&quot;Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities&quot;&gt;##INFO=&lt;ID=RAW_MQ,Number=1,Type=Float,Description=&quot;Raw data for RMS Mapping Quality&quot;&gt;##INFO=&lt;ID=ReadPosRankSum,Number=1,Type=Float,Description=&quot;Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias&quot;&gt;##contig=&lt;ID=NC_000913.3,length=1769345&gt;##reference=file:///home/elon/wgs/input/fasta/E.coli_K12_MG1655.fa#CHROM   POS    ID    REF   ALT   QUAL   FILTER   INFO   FORMAT    E.coli_K12_SRR3226034NC_000913.3   1.   A   &lt;NON_REF&gt; .   .   END=1    GT:DP:GQ:MIN_DP:PL   0/0:8:24:8:0,24,334NC_000913.3   2.   G   &lt;NON_REF&gt;  ..END=2GT:DP:GQ:MIN_DP:PL0/0:8:0:8:0,0,174… …NC_000913.3   41   .   T   C,&lt;NON_REF&gt;   112.77   .BaseQRankSum=1.309;ClippingRankSum=0.000;DP=9;ExcessHet=3.0103;MLEAC=1,0;MLEAF=0.500,0.00;MQRankSum=-0.589;RAW_MQ=32164.00;ReadPosRankSum=-0.100   GT:AD:DP:GQ:PL:SB0/1:4,5,0:9:57:141,0,57,152,71,223:1,3,5,0NC_000913.3   46   .   T   TAA,&lt;NON_REF&gt;   135.73   .BaseQRankSum=0.566;ClippingRankSum=0.000;DP=8;ExcessHet=3.0103;MLEAC=1,0;MLEAF=0.500,0.00;MQRankSum=-0.489;RAW_MQ=28564.00;ReadPosRankSum=1.292   GT:AD:DP:GQ:PL:SB0/1:3,5,0:8:98:173,0,98,183,113,296:2,1,3,2</code></pre></li></ul><p>上面是对样本SRR3226034的基因测序产生的gVCF文件的简化部分，从注释信息中可以看到文件格式是VCFv4.2 ，基因组用##contig注释信息表明，这里是指ID号为NC_000913.3的染色体，长度为1769345。参考基因组文件通过##reference注释信息标明，这里指的是路径为<code>file:///home/elon/wgs/input/fasta/E.coli_K12_MG1655.fa</code>下的文件。在最后给出的几条样例中，描述了在该物种的NC_000913.3染色体上第1号位点和第2号位点上的两段非变异性调用（分别以A和G开头）。另外最后两个是该物种的NC_000913.3染色体上第41号位点的变异信息和第46号位点的变异信息，这两条信息串的结束位点都是缺失的，因此说明变异信息只包含在该开始位点上。</p><p><strong>(4) VCF文件格式</strong><br>VCF是一种文本文件格式，通常会以“.gz”的压缩方式存储。它包含一个元信息行，一个标题行，然后数据行是包含基因组中一个位点的信息。这个格式也能包含样本组各个位点的基因型信息。</p><ol><li><p>样本组VCF文件<br>下面给出的VCF文件就是通过九组样本文件分别的变异检测得到的gVCF文件合并得到的，里面包含了该物种的这九组样本所检测到的基因变异位点的信息。VCF文件的格式大致上和gVCF相同，因为它们都是按照The Variant Call Format（VCF）Version 4.2 Specification规范来执行的，唯一不同之处是最后一列样本实例信息列，在单个gVCF文件中都只是包含单个样本文件的信息。而在VCF文件中，由于此处是通过九个gVCF文件合并得到的，因此样本列包含九个样本的所有位点信息。</p><p>##fileformat=VCFv4.2<br>##ALT=&lt;ID=NON_REF,Description=“Represents any possible alternative allele at this location”&gt;<br>##FILTER=&lt;ID=LowQual,Description=“Low quality”&gt;<br>##FORMAT=&lt;ID=AD,Number=R,Type=Integer,Description=“Allelic depths for the ref and alt alleles in the order listed”&gt;<br>##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description=“Approximate read depth (reads with MQ=255 or with bad mates are filtered)”&gt;<br>##FORMAT=&lt;ID=GQ,Number=1,Type=Integer,Description=“Genotype Quality”&gt;<br>##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=“Genotype”&gt;<br>##INFO=&lt;ID=MQ,Number=1,Type=Float,Description=“RMS Mapping Quality”&gt;<br>##INFO=&lt;ID=MQRankSum,Number=1,Type=Float,Description=“Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities”&gt;<br>##INFO=&lt;ID=QD,Number=1,Type=Float,Description=“Variant Confidence/Quality by Depth”&gt;<br>##INFO=&lt;ID=RAW_MQ,Number=1,Type=Float,Description=“Raw data for RMS Mapping Quality”&gt;<br>##INFO=&lt;ID=ReadPosRankSum,Number=1,Type=Float,Description=“Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias”&gt;<br>##INFO=&lt;ID=SOR,Number=1,Type=Float,Description=“Symmetric Odds Ratio of 2x2 contingency table to detect strand bias”&gt;<br>##contig=&lt;ID=NC_000913.3,length=1769345&gt;<br>##reference=file:///home/elon/wgs/input/fasta/E.coli_K12_MG1655.fa<br>#CHROM   POS   ID   REF   ALT   QUAL   FILTER   INFO   FORMAT    E.coli_K12_SRR3226034E.coli_K12_SRR3226035   E.coli_K12_SRR3226036   E.coli_K12_SRR3226037   E.coli_K12_SRR3226038E.coli_K12_SRR3226039    E.coli_K12_SRR3226040   E.coli_K12_SRR3226041    E.coli_K12_SRR3226042<br>NC_000913.341.TC108.AC=1;AF=0.071;AN=14;BaseQRankSum=1.31;ClippingRankSum=0.00;DP=234;ExcessHet=3.0103;FS=13.222;MLEAC=1;MLEAF=0.071;MQ=59.78;MQRankSum=-5.890e-01;QD=12.00;ReadPosRankSum=-1.000e-01;SOR=3.590GT:AD:DP:GQ:PL0/1:4,5:9:57:141,0,570/0:42,0:42:99:0,114,17100/0:26,0:26:72:0,72,10800/0:33,0:33:99:0,99,1345./.:0,0:0:.:0,0,0./.:0,0:0:.:0,0,00/0:41,0:41:90:0,90,13500/0:44,0:44:99:0,105,15750/0:39,0:39:99:0,102,1530<br>NC_000913.346.TTA,TAA398.53.AC=2,1;AF=0.143,0.071;AN=14;BaseQRankSum=0.566;ClippingRankSum=0.00;DP=242;ExcessHet=4.1497;FS=0.920;MLEAC=2,1;MLEAF=0.143,0.071;MQ=59.63;MQRankSum=0.00;QD=4.43;ReadPosRankSum=1.29;SOR=0.527GT:AD:DP:GQ:PL0/2:3,0,5:8:98:173,183,296,0,113,980/1:34,9,0:43:99:166,0,941,268,976,12440/0:26,0,0:26:35:0,35,939,35,939,9390/0:33,0,0:33:99:0,99,1345,99,1345,1345./.:0,0,0:0:.:0,0,0,0,0,0./.:0,0,0:0:.:0,0,0,0,0,00/1:30,5,4:39:41:105,0,798,41,791,11070/0:44,0,0:44:99:0,105,1575,105,1575,15750/0:39,0,0:39:99:0,102,1530,102,1530,1530</p></li><li><p>基因变异位点信息<br>通过一系列的基因测序流程以及和参考基因组的比对，最终得到的VCF文件包含了这九组样本的所有基因变异位点信息。在每个样本得到的gVCF文件，其中包含非变异性调用信息和变异性调用信息，因此整个文件大小在30M左右。而真正的变异位点的片段占很少一部分，因此将九个gVCF文件中变异性调用位点信息合并到一起就小很多，只有3M左右，里面包含的全部是变异调用位点。由于样本的随机性和基因变异的不确定性，可能某位点的变异性只存在与某些样本中，因此在VCF文件中就会看到某些变异片段仅在某些样本列下存在变异信息的情况</p></li></ol><h2 id="2-3-本章小结">2.3 本章小结</h2><p>这一章主要对构建基于Hadoop的全基因组测序平台所涉及的多方面作了介绍，其中包括Hadoop框架中的HDFS原理、MapReduce框架和YARN框架的介绍；介绍了一个作业在Hadoop集群中运行和调度的全过程；接着对全基因组测序流程的设计作了一个详细的剖析，然后介绍了测序中涉及比较多的两种数据格式FASTA和FASTQ，以及对基因测序得到的中间流程的变异检测结果文件gVCF和最终的变异检测文件VCF作了简要说明。</p><p>在接下来的一章中，将会对测序平台中MapReduce程序和测序处理脚本的关键技术做一个更为详细的剖析，例如测序流程是如何与MapReduce框架结合起来的，不同的数据格式是如何进行访问和存储，以及FreeMarker模板引擎的引入和分析流程模板的编写等。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>蔡斌, 陈湘萍. Hadoop 技术内幕：深入解析Hadoop Common 和HDFS 架构设计与实现原理[M]. 机械工业出版社, 2013. <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>董西成. Hadoop技术内幕：深入解析MapReduce架构设计与实现原理[M]. 机械工业出版社, 2013 <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>董西成. Hadoop技术内幕：深入解析YARN架构设计与实现原理[M]. 机械工业出版社, 2013. <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p>陈浩锋. 新一代基因组测序技术[M]. 科学出版社, 2017. <a href="#fnref4" class="footnote-backref">↩</a></p></li><li id="fn5" class="footnote-item"><p>Richard M, Leggett. Sequencing quality assessment tools to enable data-driven informatics for high throughput genomics[R]. US National Library of Medicine, 2013. 4-28. <a href="#fnref5" class="footnote-backref">↩</a></p></li><li id="fn6" class="footnote-item"><p>FastQC. The FastQC Toolkit[EB/OL]. <a href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/" target="_blank" rel="noopener">https://www.bioinformatics.babraham.ac.uk/projects/fastqc/</a>, 2018. <a href="#fnref6" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1 绪论</title>
      <link href="/blog/11b914a5.html"/>
      <url>/blog/11b914a5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：<strong>基于Hadoop的基因组测序大数据分析平台研究</strong>是本人2018年的本科毕业设计课题，根据网络资源和自己的专业知识，独立完成整个流程设计、平台搭建和单元测试等工作。<strong>本系列文章是对该项目的一个整理总结和分享记录。该目录提及的系列文章可供转载，并无需通知作者，但需要在明显地方标注文章出处</strong></p></blockquote><a id="more"></a><p><strong>项目源码GitHub托管：<a href="https://github.com/longshilin/wgs" target="_blank" rel="noopener">https://github.com/longshilin/wgs</a></strong></p><blockquote><p>开发环境介绍：通过个人便携式笔记本ThinkPad开发，内存是8GB。</p><ul><li>操作系统：Ubuntu16</li><li>开发平台：IDEA</li><li>开发时间：2018年2月~5月</li></ul></blockquote><h2 id="1-1-论文的研究背景及意义">1.1 论文的研究背景及意义</h2><p>全基因组测序的英文是 Whole Genome Sequencing，简称WGS。它是将物种细胞里从第一个DNA开始一直到最后一个DNA的完整基因组序列，通过相关仪器和技术手段检测出来并排序好得到一种文本格式的文件，最后再将其和参考基因组做比对，鉴定出基因组上任何类型的突变。对于人类来说，全基因组测序能帮助我们更好的了解我们自身的基因位点信息，检测变异基因并应用在遗传病方面等。</p><h3 id="1-1-1-全基因组测序原理及发展历程">1.1.1 全基因组测序原理及发展历程</h3><p>基因测序技术经过四十多年的发展，作为二十一世纪的朝阳行业，已是时下热门。测序技术发展简史如图1-1所示，从图中可以看出，基因测序技术的开端在20世纪70年代中期，以当时英国生物化学家弗雷德里克·桑格（Sanger）开创的双脱氧链终止法<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>为开端。这是一种常用的核酸测序技术，主要用于DNA的测序分析。正因为此次的研究成果，将双脱氧链终止法与化学降解法以及其衍生方法统称为第一代DNA测序技术。</p><p><img src="https://i.imgur.com/QufdMAd.png" alt="图1-1 测序技术发展简史"></p><p>经过不断的技术开发和改进，在二十世纪初期随着人类基因组计划的完成，第二代测序技术诞生了。主要是以Illumina的Solexa/Hiseq技术和ABI的SOLID技术为代表，能够对一个物种的转录组或基因组进行深度测序<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。第二代测序技术也使得DNA测序进入了高通量、低成本的功能基因组时代<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。再后来，以PacBio的SMRT和ONT的纳米孔单分子测序技术为标志的第三代测序技术<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。与之前的第一代和第二代测序技术相比，最大的不同点在于单分子测序技术的引入，测序过程不采用PCR扩增技术，并且可以进行超长读长，使得测序技术又有了进一步的提升。</p><p>对于人类的全基因组测序来说，人类的全基因组一共有23对染色体，包含超过30亿个碱基<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，而目前仅有3%的碱基信息能从临床医学上给予解释，因此还有大量的测序工作值得我们去发掘。由测序服务公司提供的原始测序序列文件在经过系统地分析处理前，无法提供任何有效的信息进行疾病的分析和预测.因此要想能够解密人类基因组的奥秘，就必须建立更加高效快速的数据分析平台，并结合生物测序仪器，将生物的蛋白质物质提取并转换为文本序列格式的数据，对其进行质量剔除、序列比对和基因测序等一系列测序分析工作<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。</p><p>纵观我国的基因组测序行业的状况，在2017年底，我国启动“中国十万人基因组计划”<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>，这是我国在人类全基因组测序领域的一个重大战略举措，也是目前世界最大规模的人类基因组计划，对我国的基因测序行业的发展有着深远的意义。</p><h3 id="1-1-2-hadoop分布式平台">1.1.2 Hadoop分布式平台</h3><p><a href="http://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop</a> 是Apache基金会下的一个顶级项目，主要用于在商业硬件网络上进行大规模计算和数据处理，该项目发展到目前已有超过十年的时间。这个分布式计算平台是用Java编写，最初是由Doug Cutting创建的，可以通过一个简单的MapReduce编程模型<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>，跨集群地对大型数据集进行分布式存储和计算处理等，Hadoop1.x与2.x的比较如图1-2所示。</p><p><img src="https://i.imgur.com/JdQOoUO.png" alt="图1 2 Hadoop1.x与2.x的比较"></p><p>如今Hadoop项目已经发展为了一个大数据处理的应用框架体系，但其中主要应用在数据处理模块的仍然是HDFS分布式存储系统和MapReduce计算框架。在Hadoop2.0<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>之后，将集群的资源管理和任务调度的功能分离成了一个YARN服务模块。在其1.0版本中，原本计算、资源管理及调度是统一管理的，但由于调度任务的增多导致集群资源调度的性能瓶颈问题，为了打破原来的性能瓶颈，将任务调度和资源管理从原来的模块中分离出来。也正是因为这种改进，使得一些其他的计算框架如<a href="http://spark.apache.org/" target="_blank" rel="noopener">Spark</a> 、<a href="http://hbase.apache.org/" target="_blank" rel="noopener">HBase</a> 等能够轻松应用在Hadoop集群中。</p><h2 id="1-2-国内外研究现状">1.2 国内外研究现状</h2><h3 id="1-2-1-基因测序的研究现状">1.2.1 基因测序的研究现状</h3><p>在基因测序服务方面，目前全球有上千家厂商提供测序服务，美国是基因测序服务发展较早的国家，因此大部分的服务产商都分布在美国。目前有超过200家分布在中国。在奥巴马政府于2015年初颁布<a href="http://guba.eastmoney.com/news,000788,173474151.html" target="_blank" rel="noopener">“精准医疗计划”</a> ；第二年中国国家科技部也将精准医疗列入<a href="https://www.hottui.com/bencandy-65-197782-1.htm" target="_blank" rel="noopener">重点研发计划</a> ，精准医疗受到中美两国政府的高度重视。政府机构对于个性化精准医疗的战略部署，直接反映了基因测序在当今时代的重要性。</p><p>随着全球市场对基因测序的需求不断提升，一些大型的测序产商也在快速更新自己的测序仪产品。如Illumina测序公司在2014年推出了HiSeqX Ten测序仪系统，是第一个每年处理20,000个基因组的高通量系统，每个成本为1,000美元，从2015年，Illumina开始提供该系统的缩小版本HiSeq X Five。由于测序成本的不断降低，恰好也推动着一些医院和科研机构纷纷加入个性化医疗的研究领域中来，使得个性化精准医疗能够快速发展<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。</p><h3 id="1-2-2-hadoop与基因测序的研究现状">1.2.2 Hadoop与基因测序的研究现状</h3><p>下图是每个DNA序列的测序费用，早在2007年末，测序费用已打破摩尔定律迅猛下降，而截止到2017年对于每条DNA序列的测序费用已低于0.01美元。这十年间测序技术的发展和世界各国科研的投入，使得基因测序的成本和门槛越来越低。</p><p>每段DNA序列的测序成本如图1-3所示，面对如此低廉的测序成本，使得个性化测序医疗的成本也会越来越低。普通人群也可以享受基因测序带来的红利，想通过基因测序了解自己的基因变异位点和遗传病的情况等。单随之而来的会面临大数据量的基因测序问题，因此我们必须寻求其他手段来高效并发的处理基因测序，在此可以利用Hadoop大数据批量处理的优势来并行化测序。在国外已经有科研机构或者公司进行这方面的尝试，如Broad Institute研究所，他们采用Hadoop、Spark的方式和基因测序结合起来，发挥Hadoop和Spark基于内存的实时分析能力，对基因测序和大数据结合的尝试。在GATK4.0的时候推出了<a href="https://software.broadinstitute.org/gatk/documentation/article?id=11244" target="_blank" rel="noopener">“在Spark集群上启用Spark的GATK工具”</a>等系列课题 。</p><p><img src="https://i.imgur.com/BGn56hb.jpg" alt="图1 3 每段DNA序列的测序成本"></p><h2 id="1-3-论文的主要研究内容">1.3 论文的主要研究内容</h2><p>通过全基因组测序流程分析并引入参考基因组，将测序样本进行一系列的处理操作如：</p><ol><li>原始数据质量控制</li><li>数据预处理（包括：序列比对、排序、标记重复序列以及建立索引等）</li><li>基因变异检测</li></ol><p>接着通过Hadoop大数据分析平台，并引入第三方模板引擎来构建分析处理脚本，结合MapReduce计算处理框架和分布式存储系统HDFS来并行计算和存储基因数据，从而实现对基因测序进行并行化测序，最终完成全基因组测序的全过程，获得样本准确的变异基因位点的集合。最后可以将这个变异集合用来指导一些疾病的研究和精准化医疗的应用方面等。</p><h2 id="1-4-章节安排">1.4 章节安排</h2><p>在第一章绪论中，主要介绍全基因组测序的研究背景及意义，其中包括对全基因组测序原理及发展历程的介绍，并对Hadoop分布式平台加以介绍，最后对国内外基因测序的研究现状和本论文主要的研究内容作了阐述。</p><p>第二章中，将会重点介绍基因测序所需要的Hadoop平台，包括HDFS组件和MapReduce组件的内部原理和相关特性。接着对全基因组测序所用到的相关流程模块及测序技术作整体介绍，主要包括三大模块：原始数据质控、数据预处理以及变异检测。最后对测序技术中出现的主要文件格式，如FASTA、FASTQ、gVCF和VCF这四种格式做了概述和格式说明。</p><p>第三章中，基于Hadoop平台基因测序的关键技术作了剖析和研究。其中包括测序逻辑与MapReduce的结合，不同格式数据的访问和存储，以及如何保证分析流程的完整性，最后引入FreeMarker模板引擎完成关键性的定制化脚本的搭建工作。</p><p>第四章中，基于Hadoop平台基因测序的流程处理和MapReduce计算框架的代码实现方面。首先是对Hadoop伪分布式环境和分布式环境的搭建和功能比较比较，其次实现Shell脚本执行引擎的构建，并分析Mappe阶段和Reduce阶段作业设计与分配，最后将对作业进行整体调度的实现。</p><p>第五章中，主要对第四章搭建的大数据处理平台的测试、优化及扩展。考虑到测试数据的易用性和分析平台测序流程的完整性，这里使用E.coli_K12的样本组数据。通过将该项目的样本数据引大数据分析平台，可以很好的对该平台进行测试和系统优化。最后对Hadoop分布式的基因测序效率与传统的脚本式的测序效率作比较，将系统平台进行扩展应用等。</p><p>第六章，对基于Hadoop的基因测序大数据平台研究与设计的总结，通过对基于Hadoop的基因组测序大数据分析平台的研究，实现自动并行化的样本数据的基因测序，大大改善传统串行处理的测序分析处理流程，从而有效的提升基因测序处理效率，并有望将该平台研究成果应用于实际基因精准化测序和个性化医疗领域中。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Sanger, F. &amp; Nicklen, S. DNA sequencing with chain-terminating[P]. 74, 5463–5467 (1977). <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Struster SC.Next-generation sequencing transform today’s biology[J].Nat Methods.5(1):16-18 (2008). <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>解增言,林俊华,谭军,舒坤贤. DNA测序技术的发展历史与最新进展[J]. 生物技术通报. 2010(08). <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p>Rusk N. Cheap third-generation sequecing[J]. Nature. 6(4): 244-245 (2011). <a href="#fnref4" class="footnote-backref">↩</a></p></li><li id="fn5" class="footnote-item"><p>J. Craig Venter, Mark D. Adams, Eugene W. Myers. The Sequence of the Human Genome[J]. Science, 2001, 291(5507): 1304-1351. <a href="#fnref5" class="footnote-backref">↩</a></p></li><li id="fn6" class="footnote-item"><p>高通量DNA测序技术及其应用进展[J]. 于聘飞,王英,葛芹玉. 南京晓庄学院学报2010-05-20 (05). <a href="#fnref6" class="footnote-backref">↩</a></p></li><li id="fn7" class="footnote-item"><p>衣春翔. 哈工大牵头启动十万人基因组计划[N]. 黑龙江日报. 2017-12-29 (003). <a href="#fnref7" class="footnote-backref">↩</a></p></li><li id="fn8" class="footnote-item"><p>Jeffrey Dean, Sanjay Ghemawat. MapReduce: Simplified Data Processing on Large Clusters[C]. America:Google, Inc., 2004. 137-149. <a href="#fnref8" class="footnote-backref">↩</a></p></li><li id="fn9" class="footnote-item"><p>Garry Turkington. Hadoop基础教程[M]. 张治起译. 人民邮电出版社 第1版, 2014. <a href="#fnref9" class="footnote-backref">↩</a></p></li><li id="fn10" class="footnote-item"><p>新一代基因组测序-通往个性化医疗[M]. 贾尼特编著,薛庆中等译. 科学出版社, 2012. <a href="#fnref10" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>摘要</title>
      <link href="/blog/205eb716.html"/>
      <url>/blog/205eb716.html</url>
      
        <content type="html"><![CDATA[<p>本论文主要研究内容是将传统的全基因组测序与Hadoop框架结合的大数据测序平台研发，通过Hadoop中的HDFS分布式存储系统来提供高可靠的存储服务，结合基因测序的一系列软件工具（如：BWA、Samtools、Picard和GATK等）来进行测序流程设计，并引入第三方FreeMarker模板引擎来制定模板脚本，针对不同的样本数据生成定制化的脚本处理文件。将各个样本的处理脚本与Hadoop框架的MapReduce计算框架结合，以Map任务的方式提交到Hadoop集群的各个计算节点的Container容器中运行，从而实现基因测序的并行化测序处理流程，得到样本组中各个样本对的单体变异检测gVCF文件。再通过一个Reduce任务，将各个Map阶段的变异检测结果中包含基因变异位点的信息汇总到一个VCF文件，得到最终多个样本准确的变异集合。</p><a id="more"></a><p>通过本次毕业设计，让我学习了全基因组基因测序的全过程和Hadoop大数据框架的相关组件，并掌握许多关于脚本处理的过程及方法。</p><p>关键词  Hadoop;WGS;HDFS;MapReduce;全基因组测序;Hadoop分布式环境;变异检测</p><hr><p>Title:  Research on Hadoop-based genome sequencing big data analysis platform</p><p>Abstract:<br>The main research content of this paper is the development of the big data sequencing platform combining traditional whole genome sequencing with the Hadoop framework, providing highly reliable storage services through the HDFS distributed storage system in Hadoop, combined with a series of software tools for gene sequencing (eg, : BWA, Samtools, Picard, GATK, etc.) to design the sequencing process, and to introduce a third-party FreeMarker template engine to create a template script to generate customized script processing files for different sample data. Combining the processing scripts of each sample with the MapReduce computing framework of the Hadoop framework and submitting them to the Containers of each computing node of the Hadoop cluster as a Map task, to achieve the parallel sequencing process of gene sequencing, and to obtain each sample group The monomer variation of the sample pair detects the gVCF file. Then through a Reduce task, the information of the gene mutation sites contained in the mutation detection results of each Map stage is aggregated into a VCF file to obtain the final accurate variation set of multiple samples.<br>Through this graduation project, I learned the whole process of genome-wide gene sequencing and related components of Hadoop big data framework, and mastered many processes and methods of script processing.</p><p>Keywords:  Hadoop; WGS; HDFS; MapReduce; whole genome sequencing; Hadoop distributed environment; mutation detection</p>]]></content>
      
      
      <categories>
          
          <category> 我的项目 </category>
          
          <category> Hadoop基因测序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 基因测序 </tag>
            
            <tag> 毕业设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集合与线程实现</title>
      <link href="/blog/f054fe4e.html"/>
      <url>/blog/f054fe4e.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><strong>集合</strong></h2><p>迭代器</p><pre><code class="language-java">public interface Iterator&lt;E&gt;{E next();boolean hasNext();void remove();}</code></pre><a id="more"></a><p>将Java迭代器认为是位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。<br>Iterator接口的remove方法将会删除上次调用next方法时返回的元素。如果在调用之前没有调用next将是不合法的。</p><h2 id="线程"><strong>线程</strong></h2><p><strong>Java多线程的三种实现</strong><br>(1) 继承Thread类，重写run函数<br>(2) 实现Runnable接口，重写run函数<br>(3) 实现Callable接口，重写call函数</p><p>利用继承类或实现接口的MyRunnable类，并重写run函数来创建并启动一个新线程：</p><pre><code class="language-java">new Thread(new MyRunnable()).start()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代器 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>接口与内部类</title>
      <link href="/blog/9ab14111.html"/>
      <url>/blog/9ab14111.html</url>
      
        <content type="html"><![CDATA[<h3 id="接口"><strong>接口</strong></h3><p>重难点总结：<br>1、接口中的所有方法自动地属于public，在接口声明方法时，不必提供关键字public，但是在实现接口 编写具体的接口方法时，需要加上public修饰符。</p><p>2、在接口中可以定义常量(默认就是用public static final修饰)。接口中绝对不能含有实例域或静态方法，也不能在接口中实现方法。</p><a id="more"></a><p>3、接口看成是没有实例域的抽象方法。</p><p>4、Java程序设计语言是一种强类型语言，在调用方法的时候，编译器将会检查这个方法是否存在。</p><p>5、不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象。</p><p>6、接口之间通过继承关系扩展接口。</p><h3 id="克隆"><strong>克隆</strong></h3><p>对象的克隆是指创建一个新对象，且新对象的状态与原始对象的状态相同。当对克隆的新对象进行修改时，不会影响原始对象的状态。</p><h3 id="接口与回调"><strong>接口与回调</strong></h3><p>回调可以指出某个特定事件发生时应该采取的动作，需要实现接口中的方法。</p><h3 id="内部类"><strong>内部类</strong></h3><h4 id="内部类-v2"><strong>内部类</strong></h4><p>顾名思义在类中再定义一个类。</p><pre><code>public class A{int i = 100;class innerClass{int m = i;}}</code></pre><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li><li>内部类可以对同一个包中的其他类隐藏起来</li><li>定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便携</li></ul><p>值得注意的是，外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类的引用参数。因此内部类的对象有一个隐式引用，它指向创建它的外部类对象。<br>所以内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p><h4 id="局部内部类"><strong>局部内部类</strong></h4><p>一个类的方法体中定义的类。</p><pre><code>public class A{int i = 100;public void innerClass(){class B{int m = i;}}}</code></pre><p>局部类 不能用public或private访问说明符进行声明，他的作用域被限定在声明这个局部类的块中。<br>局部类有一个优势，即对外部世界可以完全隐藏起来。</p><h4 id="匿名内部类"><strong>匿名内部类</strong></h4><p>一个类在new 创建一个对象实例时，直接实现其中的接口方法</p><pre><code>ActionListener listener = new ActionListener(){public void actionPerformed(ActionEvent event){...}};</code></pre><h4 id="静态内部类"><strong>静态内部类</strong></h4><p>使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围对象。为此，可以将内部类声明为static，以便取消产生的引用。</p><pre><code>public class A{static int i = 100;static class B{int m = i;}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反射机制与代理机制</title>
      <link href="/blog/cfff76a5.html"/>
      <url>/blog/cfff76a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><strong>反射</strong></h2><h3 id="获得对应的class对象-以及创建其实例">获得对应的Class对象，以及创建其实例</h3><p>三种获取对应Class对象的方法</p><a id="more"></a><p>①通过实例对象获取对应类的类对象</p><pre><code>e.getClass();</code></pre><p>②通过定义一个字符串类名，获取一个类对象</p><pre><code>String str = &quot;java.util.date&quot;;Class.forName(str);</code></pre><p>③通过类名获取类对象</p><pre><code>Employee.class</code></pre><p>通过获得的Class对象，调用其newInstance()方法创建其实例</p><pre><code>AClass.newInstance();</code></pre><h3 id="利用反射分析类的能力">利用反射分析类的能力</h3><p>分析一个类的能力从三方面入手，其域、方法和构造器。反射java.util.reflact包中有这三方面相关的获取方法，可以得知一个类实际的类能力。</p><ul><li>Field 域</li><li>Method 方法</li><li>Constructor 构造器</li></ul><h3 id="在运行时使用反射分析类">在运行时使用反射分析类</h3><p>在运行时，可以通过类属性获得某个指定的实例对象</p><h3 id="使用反射编写泛型数组代码">使用反射编写泛型数组代码</h3><h3 id="反射机制允许你调用任意方法">反射机制允许你调用任意方法</h3><p>允许调用包装在当前Method对象中的方法</p><p>比如：m1代表Employee类的getName方法<br>Method m1 = Employee.class.getMethod(“getName”,String.class);<br>String n = (String)m1.invoke(harry);</p><h3 id="总结">总结</h3><p>反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具体有通用性的程序。这种功能对于编写系统程序来说极其实用。</p><a></a>## **代理**利用代理可以在运行时创建一个实现了一组给定接口的心类，这种功能只有在编译时 无法确定需要实现哪个接口时，才有必要使用。无论何时调用代理对象的方法，调用处理器的invoke方法都会被调用。并向其传递Method对象和原始的调用参数。<p>代理的作用是：为其它对象提供一种代理以控制对这个对象的访问。在某些情况下，一 个客户不想直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。通过代理类这一中间层，能够有效控制对实际委托类对象的直接访问，也可以很好地隐藏和 保护实际对象，实施不同的控制策略，从而在设计上获得了更大的灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射机制 </tag>
            
            <tag> 类对象 </tag>
            
            <tag> Class </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>零碎注意点</title>
      <link href="/blog/3bf9b222.html"/>
      <url>/blog/3bf9b222.html</url>
      
        <content type="html"><![CDATA[<p>在DOS命令行下执行命令运行Java文件：<br>1、运行jar包    <code>java -jar test.jar</code><br>2、编译Java文件 <code>javac test.java</code><br>3、运行Java的字节码文件 <code>java test</code><br>4、调试Java文件 <code>jdb test.java</code><br>5、生成Java doc文件 <code>javadoc test.java</code></p><a id="more"></a><p>JPanel面板的默认布局—流布局管理器 Flow Layout Manager，面板中的元素是按照从左到右的顺序排列的。</p><p>JFrame框架的默认布局—边框布局管理器 Border Layout Manager，页面JFrame框架分上北下南 左西右东 中间 五个模块，组成了边框布局。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>异常与泛型</title>
      <link href="/blog/ea45fa53.html"/>
      <url>/blog/ea45fa53.html</url>
      
        <content type="html"><![CDATA[<h2 id="捕获异常"><strong>捕获异常</strong></h2><p>异常分为两种类型：未检查异常和已检查异常。</p><p><strong>已检查异常</strong>：系统已检查可能发生异常的地方，程序员编写再精细的程序也无法保证不发生异常的地方。(派生于IOException)<br><strong>未检查异常</strong>：派生于Error类或RuntimeException</p><a id="more"></a><p>对于已检查异常，编译器将会检查是否提供了处理器。(在即时编译器的编译阶段就已经检测出来，必须处理或抛出该有可能发生的已检查异常)。<br>然而，有很多常见的异常，例如，访问null引用，都属于未检查异常。编译器不会查看是否为这些错误提供了处理器。毕竟，应该精心地编写代码来避免这些错误的发生，而不是将精力放在编写异常处理器上。</p><p>|—throw在方法体中抛出异常<br>|—throws  在方法头上抛出异常<br>|—try-catch  捕获并处理异常</p><h2 id="泛型"><strong>泛型</strong></h2><p>泛型类可以看作不同类的工厂<br>一个泛型类就是具有一个或多个类型变量的类</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类和对象的易错点</title>
      <link href="/blog/df938bb4.html"/>
      <url>/blog/df938bb4.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>总结Java程序设计语言中方法参数的使用情况:</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型，在Java中只有基本类型不是对象）。当参数是传入一个数值或布尔值时，传入的参数和原数据基本类型参数是两份不同的拷贝，互不影响。</li></ul><a id="more"></a><ul><li>一个方法可以改变一个对象参数的状态（如传入一个数组引用改变某一个数组元素值，或传入一个对象，改变其属性值。原因在于：方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。<strong>但是注意：</strong> 当传入一个字符串对象引用时，由于string是final类型的，所有方法体中的修改相当于新创建了一个字符串对象，而不会改变原字符串变量的值）</li><li>一个方法不能让对象参数引用一个新的对象，如示例代码：</li></ul><pre><code>public static void swap(Employee x, Employee y){Employee temp = x;x = y;y = temp;}</code></pre><pre><code>这个交换方法被swap(a,b)调用时，并不能将a对象和b对象交换，原因在于，方法结束时参数变量x和y被丢弃。原来的变量a和b仍然引用这个方法调用之前所引用的对象。</code></pre></li><li><p>总结调用构造器的具体步骤：<br>1）所有数据域被初始化为默认值（0、false或null）。<br>2）按照在类声明中出现的次序，依次执行所有域初始化语句和初始化快.(即按声明顺序执行静态块和静态语句)<br>3）如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。<br>4）执行这个构造器的主体。</p></li></ul><ul><li><p>总结域与局部变量主要不同点：<br>必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的域（即成员变量），将会被初始化为默认值（0、false或null）</p><p>初始化域变量时，需注意 如果在编写一个类时没有编写构造器 ，那么系统就会提供一个无参数构造器。这个构造器将会为所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。<br>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。因此，在构造一个类时，最好创建一个无参构造器。<br>仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。</p></li><li><p>返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。</p></li><li><p>继承类代码实例说明：</p></li></ul><pre><code>public class test {public static void main(String[] args) {// ****向上转型的注意点****// 向上直接转型，声明时的子类可以直接被更为抽象的父类引用// 声明为 什么类型，该对象就是什么类型，就算其引用的是子类的对象，该对象也只能调用声明的父类中拥有的方法体。// father fat = new son();// fat.fa();// fat.son(); //The method son() is undefined for the type father// ****强转的注意点****// 两个来自不同的类的对象，不存在向上转型的情况下，不可以互相强转。// 编译可以通过，但是会报运行时异常 java.lang.ClassCastException// father fat = new father();// son son = (son) fat; // father cannot be cast to son// 存在向上转型的情况下：// 原本是子类对象，后来向上转型之后，被父类引用后，再被强转为子类是可以的。可以正常运行！// father fat = new son();// son son = (son) fat;// 对于null对象强转，下面示例编译可以通过，但会报运行时空指针异常// ((son) null).so(); // java.lang.NullPointerException}}/* * 子类 */class son extends father {public son() {System.out.println(&quot;子类默认构造器！&quot;);}public son(int a) {System.out.println(&quot;子类带参构造器！&quot;);}public void test() {System.out.println(&quot;子类test方法！&quot;);}public void so() {System.out.println(&quot;子类独有的so方法！&quot;);}}/* * 父类 */class father {father() {System.out.println(&quot;父类默认构造器！&quot;);}father(int i) {System.out.println(&quot;父类带参构造器！&quot;);}void test() {System.out.println(&quot;父类test方法！&quot;);}void fa() {System.out.println(&quot;父类独有的fa方法！&quot;);}}</code></pre><ul><li><p>类型转换总结：</p><ul><li><strong>只能在继承层次内进行类型转换。</strong></li><li>在将超类转换成子类之前，应该使用<code>instance of</code>进行检查。</li><li>继承层次内的转换如：</li></ul><pre><code>Object obj = new Employee(&quot;Harry Hacker&quot;,350000);Employee e = (Employee) obj;</code></pre></li><li><p>抽象类总结:</p><ul><li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。</li><li>除了抽象方法外，抽象类还可以包含具体数据和具体方法。</li><li>类即使不含抽象方法，也可以将类声明为抽象类。</li><li><strong>抽象类不能被实例化</strong></li><li>需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。<em>(就如同可以声明一个父类 引用子类对象一样------向上转型)</em></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java笔试易错点</title>
      <link href="/blog/337c6120.html"/>
      <url>/blog/337c6120.html</url>
      
        <content type="html"><![CDATA[<ul><li>启动线程方法start();线程stop方法已经被弃用；守护线程在非守护线程结束后，会自动结束；等待其他线程通知方法是wait()</li><li>switch结构中没有break的话，匹配完不会跳出，会继续匹配下一个case直到整个结构结束</li><li>Java.awt.*只能导入awt这个包中的所有类，awt中的包中的类不会导入</li><li>public&gt;protected&gt;默认(包访问权限)&gt;private，因为protected除了可以被同一包访问，还可以被包外的子类所访问</li></ul><a id="more"></a><ul><li>在Java中继承是通过extends关键字来描述的，而且只允许继承自一个直接父类。</li><li>向上转型(子类对象被父类引用) 直接指向；向下转型(父类对象被子类引用)，需要强转。</li><li>公式-n=<sub>n+1可推出</sub>n=-n-1，所以~10=-11再加5结果为-6</li><li>getAttribute()接受从request域中传过来的参数，getParameter()接受从页面传过来的参数</li><li>只要记住，不论怎样，必定先执行静态代码，子由父生，所以父类必先执行</li><li>一个类若有抽象方法，其本身也必须声明为抽象类；接口中的方法默认就是public abstract</li><li>abstract不能与final并列修饰同一个类</li><li>接口中的变量声明为public static final默认形式</li><li>java7，字符串常量池从方法区移到堆中。java8 整个常量池从方法区中移除。方法区使用元空间（MetaSpace）实现</li><li>jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。常量池属于 PermGen（方法区）</li><li>事实上只有在我们没有显示声明任何构造方法时java才会为我们提供一个默认的无参构造函数。</li><li>super()必须是子类的第一条语句</li><li>java是解释型语言，在运行时才进行翻译指令  Java不同于一般的编译语言和直译语言。它首先将源代码编译成字节码，然后依赖各种不同平台上的虚拟机来解释执行字节码，<br>从而实现了“一次编写，到处运行”的跨平台特性， 所以说java是一种解释型的语言</li><li>三个基本元素：封装，继承，多态。</li><li>五个基本原则：单一职责原则，开放封闭原则，里氏替换原则，依赖倒置原则，接口隔离原则</li><li>switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。</li><li>MVC概念：<br>A. 模型通常代表应用程序中的数据以及用于操纵数据的业务逻辑；<br>B. 视图是其对应的模型的可视化呈现，视图 将模型渲染成适合于交互的形式（通常为用户界面元素）；<br>C. 控制器是用户与系统之间的纽带，它接受用户输入，并指示模型和视图基于用户输入执行操作（处理数据、展示数据）；</li><li>类方法是指类中被static修饰的方法，无this指针。类方法是可以调用其他类的static方法的。可以在类方法中生成实例对象再调用实例方法</li><li>ANSI码 对于windows系统来说的话就是指当前的系统编码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
